import{_ as c,r as p,o,c as l,d as e,a as n,b as s,h as t}from"./app-CFtgncbC.js";const i={},u=n("h1",{id:"响应式基础",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#响应式基础"},[n("span",null,"响应式基础")])],-1),r=n("h2",{id:"声明响应式状态",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#声明响应式状态"},[n("span",null,"声明响应式状态")])],-1),d=n("p",null,"我们可以使用 reactive() 函数创建一个响应式对象或数组：",-1),k=n("h3",{id:"script-setup",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#script-setup"},[n("span",null,[n("code",null,"<script setup>")])])],-1),v=n("p",null,[s("在 "),n("code",null,"setup()"),s(" 函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用构建工具来简化该操作。"),n("br"),s(" 当使用单文件组件（SFC）时，我们可以使用 "),n("code",null,"<script setup>"),s(" 来大幅度地简化代码。")],-1),m=t('<h3 id="dom-更新时机" tabindex="-1"><a class="header-anchor" href="#dom-更新时机"><span>DOM 更新时机</span></a></h3><p>当你更改响应式状态后，DOM 会自动更新。然而，你得注意 DOM 的更新并不是同步的。<br> 相反，Vue 将缓冲它们直到更新周期的 “下个时机” 以确保无论你进行了多少次状态更改，每个组件都只更新一次。</p><p>若要等待一个状态改变后的 DOM 更新完成，你可以使用 <code>nextTick()</code> 这个全局 API。</p><h3 id="深层响应性" tabindex="-1"><a class="header-anchor" href="#深层响应性"><span>深层响应性</span></a></h3><p>在 Vue 中，状态都是默认深层响应式的。</p><p>你也可以直接创建一个浅层响应式对象 <code>shallowReactive</code>。它们仅在顶层具有响应性，一般仅在某些特殊场景中需要。</p><h3 id="reactive-的局限性" tabindex="-1"><a class="header-anchor" href="#reactive-的局限性"><span>reactive() 的局限性</span></a></h3><p><code>reactive()</code> API 有两条限制：</p><ol><li>仅对对象类型有效（对象、数组和 Map、Set 这样的集合类型），而对 string、number 和 boolean 这样的 原始类型 无效。</li><li>因为 Vue 的响应式系统是通过属性访问进行追踪的，因此我们必须始终保持对该响应式对象的相同引用。这意味着我们不可以随意地“替换”一个响应式对象，因为这将导致对初始引用的响应性连接丢失。<br> 同时这也意味着当我们将响应式对象的属性赋值或解构至本地变量时，或是将该属性传入一个函数时，我们会失去响应性。</li></ol><h2 id="用-ref-定义响应式变量" tabindex="-1"><a class="header-anchor" href="#用-ref-定义响应式变量"><span>用 <code>ref()</code> 定义响应式变量</span></a></h2><p><code>reactive()</code> 的种种限制归根结底是因为 JavaScript 没有可以作用于所有值类型的 “引用” 机制。<br> 为此，Vue 提供了一个 <code>ref()</code> 方法来允许我们创建可以使用任何值类型的响应式 <code>ref</code>。</p><p><code>ref()</code> 将传入参数的值包装为一个带 <code>.value</code> 属性的 <code>ref</code> 对象：</p>',12),b=t(`<div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token comment">// { value: 0 }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 0</span>

count<span class="token punctuation">.</span>value<span class="token operator">++</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和响应式对象的属性类似，<code>ref</code> 的 <code>.value</code> 属性也是响应式的。<br> 同时，当值为对象类型时，会用 <code>reactive()</code> 自动转换它的 <code>.value</code>。</p><p>一个包含对象类型值的 <code>ref</code> 可以响应式地替换整个对象：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> objectRef <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 这是响应式的替换</span>
objectRef<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ref</code> 被传递给函数或是从一般对象上被解构时，不会丢失响应性：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token comment">// 该函数接收一个 ref</span>
<span class="token comment">// 需要通过 .value 取值</span>
<span class="token comment">// 但它会保持响应性</span>
<span class="token function">callSomeFunction</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">)</span>

<span class="token comment">// 仍然是响应式的</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar <span class="token punctuation">}</span> <span class="token operator">=</span> obj
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简言之，<code>ref()</code> 让我们能创造一种对任意值的 “引用”，并能够在不丢失响应性的前提下传递这些引用。</p><p>这个功能很重要，因为它经常用于将逻辑提取到 <strong>组合函数</strong> 中。</p><h3 id="ref-在模板中的解包" tabindex="-1"><a class="header-anchor" href="#ref-在模板中的解包"><span>ref 在模板中的解包</span></a></h3><p>当 ref 在模板中作为顶层属性被访问时，它们会被自动“解包”，所以不需要使用 <code>.value</code>。</p><h3 id="ref-在响应式对象中的解包" tabindex="-1"><a class="header-anchor" href="#ref-在响应式对象中的解包"><span>ref 在响应式对象中的解包</span></a></h3><p>当一个 <code>ref</code> 被嵌套在一个响应式对象中，作为属性被访问或更改时，它会自动解包，因此会表现得和一般的属性一样：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count <span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment">// 0</span>

state<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果将一个新的 <code>ref</code> 赋值给一个关联了已有 <code>ref</code> 的属性，那么它会替换掉旧的 <code>ref</code>：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> otherCount <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>

state<span class="token punctuation">.</span>count <span class="token operator">=</span> otherCount
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment">// 2</span>
<span class="token comment">// 原始 ref 现在已经和 state.count 失去联系</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只有当嵌套在一个深层响应式对象内时，才会发生 <code>ref</code> 解包。当其作为浅层响应式对象 <code>shallowReactive</code> 的属性被访问时不会解包。</p><h3 id="数组和集合类型的-ref-解包" tabindex="-1"><a class="header-anchor" href="#数组和集合类型的-ref-解包"><span>数组和集合类型的 ref 解包</span></a></h3><p>跟响应式对象不同，当 <code>ref</code> 作为响应式数组或像 <code>Map</code> 这种原生集合类型的元素被访问时，不会进行解包。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> books <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">&#39;Vue 3 Guide&#39;</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// 这里需要 .value</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>books<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>

<span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">&#39;count&#39;</span><span class="token punctuation">,</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 这里需要 .value</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&#39;count&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,19);function f(g,h){const a=p("VuePlayground");return o(),l("div",null,[u,r,d,e(a,{title:"reactive%20%E7%A4%BA%E4%BE%8B",key:"6473a9f3",settings:"%7B%7D",files:"eyJBcHAudnVlIjoiPHNjcmlwdD5cbmltcG9ydCB7IHJlYWN0aXZlIH0gZnJvbSAndnVlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNldHVwKCkge1xuICAgIGNvbnN0IHN0YXRlID0gcmVhY3RpdmUoeyBjb3VudDogMCB9KVxuXG4gICAgZnVuY3Rpb24gaW5jcmVtZW50KCkge1xuICAgICAgc3RhdGUuY291bnQrK1xuICAgIH1cblxuICAgIC8vIOS4jeimgeW%2FmOiusOWQjOaXtuaatOmcsiBpbmNyZW1lbnQg5Ye95pWwXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXRlLFxuICAgICAgaW5jcmVtZW50LFxuICAgIH1cbiAgfSxcbn1cbjwvc2NyaXB0PlxuXG48dGVtcGxhdGU%2BXG4gIDxidXR0b24gQGNsaWNrPVwiaW5jcmVtZW50XCI%2Be3sgc3RhdGUuY291bnQgfX08L2J1dHRvbj5cbjwvdGVtcGxhdGU%2BXG4ifQ%3D%3D"}),k,v,e(a,{title:"%3Cscript%20setup%3E%20%E7%A4%BA%E4%BE%8B",key:"41b07c8e",settings:"%7B%7D",files:"eyJBcHAudnVlIjoiPHNjcmlwdCBzZXR1cD5cbmltcG9ydCB7IHJlYWN0aXZlIH0gZnJvbSAndnVlJ1xuXG5jb25zdCBzdGF0ZSA9IHJlYWN0aXZlKHsgY291bnQ6IDAgfSlcblxuZnVuY3Rpb24gaW5jcmVtZW50KCkge1xuICBzdGF0ZS5jb3VudCsrXG59XG48L3NjcmlwdD5cblxuPHRlbXBsYXRlPlxuICA8YnV0dG9uIEBjbGljaz1cImluY3JlbWVudFwiPnt7IHN0YXRlLmNvdW50IH19PC9idXR0b24%2BXG48L3RlbXBsYXRlPlxuIn0%3D"}),m,e(a,{title:"ref%20%E7%A4%BA%E4%BE%8B",key:"6da3e6a1",settings:"%7B%7D",files:"eyJBcHAudnVlIjoiPHNjcmlwdCBzZXR1cD5cbmltcG9ydCB7IHJlZiB9IGZyb20gJ3Z1ZSdcblxuY29uc3QgY291bnQgPSByZWYoMClcblxuZnVuY3Rpb24gaW5jcmVtZW50KCkge1xuICBjb3VudC52YWx1ZSsrXG59XG48L3NjcmlwdD5cblxuPHRlbXBsYXRlPlxuICA8YnV0dG9uIEBjbGljaz1cImluY3JlbWVudFwiPnt7IGNvdW50IH19PC9idXR0b24%2BXG48L3RlbXBsYXRlPlxuIn0%3D"}),b])}const y=c(i,[["render",f],["__file","reactivity-fundamentals.html.vue"]]),I=JSON.parse('{"path":"/notes/frontend/vue/vue3/basic/reactivity-fundamentals.html","title":"响应式基础","lang":"zh-CN","frontmatter":{"order":20,"category":["笔记","frontend","vue"],"tag":["vue3"],"description":"响应式基础 声明响应式状态 我们可以使用 reactive() 函数创建一个响应式对象或数组： <script setup> 在 setup() 函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用构建工具来简化该操作。 当使用单文件组件（SFC）时，我们可以使用 <script setup> 来大幅度地简化代码。 DOM 更新时机 当你...","head":[["meta",{"property":"og:url","content":"https://www.zhaobc.site/notes/frontend/vue/vue3/basic/reactivity-fundamentals.html"}],["meta",{"property":"og:site_name","content":"赵斌的小站"}],["meta",{"property":"og:title","content":"响应式基础"}],["meta",{"property":"og:description","content":"响应式基础 声明响应式状态 我们可以使用 reactive() 函数创建一个响应式对象或数组： <script setup> 在 setup() 函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用构建工具来简化该操作。 当使用单文件组件（SFC）时，我们可以使用 <script setup> 来大幅度地简化代码。 DOM 更新时机 当你..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-23T14:41:24.000Z"}],["meta",{"property":"article:author","content":"Zhao Bin"}],["meta",{"property":"article:tag","content":"vue3"}],["meta",{"property":"article:modified_time","content":"2024-03-23T14:41:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"响应式基础\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-23T14:41:24.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Zhao Bin\\",\\"url\\":\\"zhaobc.site\\",\\"email\\":\\"hi@zhaobc.site\\"}]}"]]},"headers":[{"level":2,"title":"声明响应式状态","slug":"声明响应式状态","link":"#声明响应式状态","children":[{"level":3,"title":"<script setup>","slug":"script-setup","link":"#script-setup","children":[]},{"level":3,"title":"DOM 更新时机","slug":"dom-更新时机","link":"#dom-更新时机","children":[]},{"level":3,"title":"深层响应性","slug":"深层响应性","link":"#深层响应性","children":[]},{"level":3,"title":"reactive() 的局限性","slug":"reactive-的局限性","link":"#reactive-的局限性","children":[]}]},{"level":2,"title":"用 ref() 定义响应式变量","slug":"用-ref-定义响应式变量","link":"#用-ref-定义响应式变量","children":[{"level":3,"title":"ref 在模板中的解包","slug":"ref-在模板中的解包","link":"#ref-在模板中的解包","children":[]},{"level":3,"title":"ref 在响应式对象中的解包","slug":"ref-在响应式对象中的解包","link":"#ref-在响应式对象中的解包","children":[]},{"level":3,"title":"数组和集合类型的 ref 解包","slug":"数组和集合类型的-ref-解包","link":"#数组和集合类型的-ref-解包","children":[]}]}],"git":{"createdTime":1711204884000,"updatedTime":1711204884000,"contributors":[{"name":"Zhao Bin","email":"413853119@qq.com","commits":1}]},"readingTime":{"minutes":4.08,"words":1225},"filePathRelative":"notes/frontend/vue/vue3/basic/reactivity-fundamentals.md","localizedDate":"2024年3月23日","excerpt":"\\n<h2>声明响应式状态</h2>\\n<p>我们可以使用 reactive() 函数创建一个响应式对象或数组：</p>\\n\\n<h3><code>&lt;script setup&gt;</code></h3>\\n<p>在 <code>setup()</code> 函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用构建工具来简化该操作。<br>\\n当使用单文件组件（SFC）时，我们可以使用 <code>&lt;script setup&gt;</code> 来大幅度地简化代码。</p>\\n\\n<h3>DOM 更新时机</h3>\\n<p>当你更改响应式状态后，DOM 会自动更新。然而，你得注意 DOM 的更新并不是同步的。<br>\\n相反，Vue 将缓冲它们直到更新周期的 “下个时机” 以确保无论你进行了多少次状态更改，每个组件都只更新一次。</p>","autoDesc":true}');export{y as comp,I as data};
