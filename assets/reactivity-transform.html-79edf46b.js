const e=JSON.parse('{"key":"v-05d1cb56","path":"/notes/frontend/vue/vue3/extra/reactivity-transform.html","title":"响应性语法糖","lang":"zh-CN","frontmatter":{"index":90,"icon":"vue","category":["笔记","frontend","vue"],"tag":["vue3"],"description":"响应性语法糖 响应性语法糖目前是一个实验性功能，默认是禁用的，需要显式选择使用。 Vue 的响应性语法糖是一个编译时的转换过程，使我们可以像这样书写代码： ref vs. 响应式变量 这里的这个 $ref() 方法是一个编译时的宏命令：它不是一个真实的、在运行时会调用的方法。 而是用作 Vue 编译器的标记，表明最终的 count 变量需要是一个响应式变量。 每一个会返回 ref 的响应性 API 都有一个相对应的、以 $ 为前缀的宏函数。包括以下这些 API：","head":[["meta",{"property":"og:url","content":"https://www.zhaobc.site/notes/frontend/vue/vue3/extra/reactivity-transform.html"}],["meta",{"property":"og:site_name","content":"赵斌的小站"}],["meta",{"property":"og:title","content":"响应性语法糖"}],["meta",{"property":"og:description","content":"响应性语法糖 响应性语法糖目前是一个实验性功能，默认是禁用的，需要显式选择使用。 Vue 的响应性语法糖是一个编译时的转换过程，使我们可以像这样书写代码： ref vs. 响应式变量 这里的这个 $ref() 方法是一个编译时的宏命令：它不是一个真实的、在运行时会调用的方法。 而是用作 Vue 编译器的标记，表明最终的 count 变量需要是一个响应式变量。 每一个会返回 ref 的响应性 API 都有一个相对应的、以 $ 为前缀的宏函数。包括以下这些 API："}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-01-30T14:44:17.000Z"}],["meta",{"property":"article:tag","content":"vue3"}],["meta",{"property":"article:modified_time","content":"2023-01-30T14:44:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"响应性语法糖\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-01-30T14:44:17.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"ref vs. 响应式变量","slug":"ref-vs-响应式变量","link":"#ref-vs-响应式变量","children":[]},{"level":2,"title":"通过 $() 结构","slug":"通过-结构","link":"#通过-结构","children":[]},{"level":2,"title":"响应式 props 解构","slug":"响应式-props-解构","link":"#响应式-props-解构","children":[]},{"level":2,"title":"保持在函数间的响应性","slug":"保持在函数间的响应性","link":"#保持在函数间的响应性","children":[{"level":3,"title":"以参数形式传入函数","slug":"以参数形式传入函数","link":"#以参数形式传入函数","children":[]},{"level":3,"title":"作为函数返回值","slug":"作为函数返回值","link":"#作为函数返回值","children":[]},{"level":3,"title":"在已解构的 prop 上使用 $$()","slug":"在已解构的-prop-上使用","link":"#在已解构的-prop-上使用","children":[]}]},{"level":2,"title":"显式启用","slug":"显式启用","link":"#显式启用","children":[]}],"git":{"createdTime":1675089857000,"updatedTime":1675089857000,"contributors":[{"name":"Zhao Bin","email":"413853119@qq.com","commits":1}]},"readingTime":{"minutes":4,"words":1200},"filePathRelative":"notes/frontend/vue/vue3/extra/reactivity-transform.md","localizedDate":"2023年1月30日","excerpt":"<h1> 响应性语法糖</h1>\\n<p>响应性语法糖目前是一个实验性功能，默认是禁用的，需要显式选择使用。</p>\\n<p>Vue 的响应性语法糖是一个编译时的转换过程，使我们可以像这样书写代码：</p>\\n<h2> ref vs. 响应式变量</h2>\\n\\n<p>这里的这个 <code>$ref()</code> 方法是一个编译时的宏命令：它不是一个真实的、在运行时会调用的方法。\\n而是用作 Vue 编译器的标记，表明最终的 <code>count</code> 变量需要是一个响应式变量。</p>\\n<p>每一个会返回 <code>ref</code> 的响应性 API 都有一个相对应的、以 <code>$</code> 为前缀的宏函数。包括以下这些 API：</p>","autoDesc":true}');export{e as data};
