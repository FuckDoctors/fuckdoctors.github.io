import{_ as p,r as t,o as i,c as l,d as a,a as n,b as s,h as c}from"./app-4c5aeddb.js";const d={},u=n("h1",{id:"响应性语法糖",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#响应性语法糖","aria-hidden":"true"},"#"),s(" 响应性语法糖")],-1),r=n("p",null,"响应性语法糖目前是一个实验性功能，默认是禁用的，需要显式选择使用。",-1),v=n("p",null,"Vue 的响应性语法糖是一个编译时的转换过程，使我们可以像这样书写代码：",-1),k=n("h2",{id:"ref-vs-响应式变量",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#ref-vs-响应式变量","aria-hidden":"true"},"#"),s(" ref vs. 响应式变量")],-1),m=c(`<p>这里的这个 <code>$ref()</code> 方法是一个编译时的宏命令：它不是一个真实的、在运行时会调用的方法。 而是用作 Vue 编译器的标记，表明最终的 <code>count</code> 变量需要是一个响应式变量。</p><p>每一个会返回 <code>ref</code> 的响应性 API 都有一个相对应的、以 <code>$</code> 为前缀的宏函数。包括以下这些 API：</p><ul><li><code>ref</code> -&gt; <code>$ref</code></li><li><code>computed</code> -&gt; <code>$computed</code></li><li><code>shallowRef</code> -&gt; <code>$shalloRef</code></li><li><code>customRef</code> -&gt; <code>$customRef</code></li><li><code>toRef</code> -&gt; <code>$toRef</code></li></ul><p>当启用响应性语法糖时，这些宏函数都是全局可用的、无需手动导入。 但如果你想让它更明显，你也可以选择从 <code>vue/macros</code> 中引入它们：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> $ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue/macros&#39;</span>

<span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">$ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="通过-结构" tabindex="-1"><a class="header-anchor" href="#通过-结构" aria-hidden="true">#</a> 通过 <code>$()</code> 结构</h2><p>我们常常会让一个组合函数返回一个含数个 <code>ref</code> 的对象，然后解构得到这些 <code>ref</code>。对于这种场景，响应性语法糖提供了一个 <code>$()</code> 宏：</p>`,7),b=c('<h2 id="响应式-props-解构" tabindex="-1"><a class="header-anchor" href="#响应式-props-解构" aria-hidden="true">#</a> 响应式 props 解构</h2><p>现在的 <code>&lt;script setup&gt;</code> 中对 <code>defineProps</code> 宏的使用有两个痛点：</p><ol><li>和 <code>.value</code> 类似，为了保持响应性，你需要以 <code>props.x</code> 的方式访问这些 prop。 这意味着你不能通过结构 <code>defineProps</code>，因为得到的变量不是响应式的，不会更新。</li><li>使用基于类型的 <code>props</code> 声明时，无法方便地声明这些 prop 的默认值。 为此，有了 <code>withDefaults()</code> API，但使用起来不方便。</li></ol><p>有了响应式语法糖，我们就可以在 <code>defineProps</code> 时，使用响应式变量相同的结构写法了：</p>',4),g=c(`<h2 id="保持在函数间的响应性" tabindex="-1"><a class="header-anchor" href="#保持在函数间的响应性" aria-hidden="true">#</a> 保持在函数间的响应性</h2><p>虽然响应式变量使我们可以不再受 <code>.value</code> 的困扰，但它也使得我们在函数间传递响应式变量时可能造成<strong>响应性丢失</strong>的问题。 这可能在以下两种场景中出现：</p><h3 id="以参数形式传入函数" tabindex="-1"><a class="header-anchor" href="#以参数形式传入函数" aria-hidden="true">#</a> 以参数形式传入函数</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">trackChange</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">x</span><span class="token operator">:</span> Ref<span class="token operator">&lt;</span>number<span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">watch</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token parameter">x</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;x 改变了！&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">$ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">trackChange</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token comment">// 无效！</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的例子不会正常工作，因为代码被编译成了这样：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">trackChange</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的 <code>count.value</code> 是以一个 <code>number</code> 类型值的形式传入，然而 trackChange 期望接收的是一个真正的 <code>ref</code>。 要解决这个问题，可以在将 count 作为参数传入之前，用 <code>$$()</code> 包装：</p><div class="language-diff line-numbers-mode" data-ext="diff"><pre class="language-diff"><code>let count = $ref(0)
<span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> trackChange(count)
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> trackChange($$(count))
</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码将被编译成：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">trackChange</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以看到，<code>$$()</code> 的效果就像是一个转义标识：<code>$$()</code> 中的响应式变量不会追加上 <code>.value</code>。</p><h3 id="作为函数返回值" tabindex="-1"><a class="header-anchor" href="#作为函数返回值" aria-hidden="true">#</a> 作为函数返回值</h3><p>如果将响应式变量直接放在返回值表达式中会丢失掉响应性：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">useMouse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">$ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> y <span class="token operator">=</span> <span class="token function">$ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

  <span class="token comment">// 监听 mousemove 事件</span>

  <span class="token comment">// 不起效！</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">,</span>
    y<span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的语句将被翻译为：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">return</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">x</span><span class="token operator">:</span> x<span class="token punctuation">.</span>value<span class="token punctuation">,</span>
  <span class="token literal-property property">y</span><span class="token operator">:</span> y<span class="token punctuation">.</span>value<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了保持响应性，我们需要返回的是真正的 <code>ref</code>，而不是返回时 <code>ref</code> 内的值。</p><p>我们还是可以使用 <code>$$()</code> 来解决这个问题。 在这个例子中，<code>$$()</code> 可以直接用在要返回的对象上， <code>$$()</code> 调用时任何对响应式变量的引用都会保留为对相应 <code>ref</code> 的引用：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">useMouse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">$ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> y <span class="token operator">=</span> <span class="token function">$ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

  <span class="token comment">// 监听 mousemove 事件</span>

  <span class="token comment">// 修改后起效</span>
  <span class="token keyword">return</span> <span class="token function">$$</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    x<span class="token punctuation">,</span>
    y<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="在已解构的-prop-上使用" tabindex="-1"><a class="header-anchor" href="#在已解构的-prop-上使用" aria-hidden="true">#</a> 在已解构的 prop 上使用 <code>$$()</code></h3><p><code>$$()</code> 适用于已解构的 prop，因为它们也是响应式的变量。编译器会高效地通过 <code>toRef</code> 来做转换：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> count <span class="token punctuation">}</span> <span class="token operator">=</span> defineProps<span class="token operator">&lt;</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> number <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">passAsRef</span><span class="token punctuation">(</span><span class="token function">$$</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译结果为：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> __props_count <span class="token operator">=</span> <span class="token function">toRef</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> <span class="token string">&#39;count&#39;</span><span class="token punctuation">)</span>
  <span class="token function">passAsRef</span><span class="token punctuation">(</span>__props_count<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="显式启用" tabindex="-1"><a class="header-anchor" href="#显式启用" aria-hidden="true">#</a> 显式启用</h2>`,25),f={href:"https://vuejs.org/guide/extras/reactivity-transform.html#explicit-opt-in",target:"_blank",rel:"noopener noreferrer"};function h(I,x){const e=t("Playground"),o=t("ExternalLinkIcon");return i(),l("div",null,[u,r,v,k,a(e,{key:"12f2f7c9",title:"%E5%93%8D%E5%BA%94%E6%80%A7%E8%AF%AD%E6%B3%95%E7%B3%96",link:"https%3A%2F%2Fsfc.vuejs.org%2F%23eyJBcHAudnVlIjoiPHNjcmlwdCBzZXR1cD5cbmxldCBjb3VudCA9ICRyZWYoMClcbmNvbnNvbGUubG9nKGNvdW50KVxuZnVuY3Rpb24gaW5jcmVtZW50KCkge1xuICBjb3VudCsrXG59XG48L3NjcmlwdD5cblxuPHRlbXBsYXRlPlxuICA8YnV0dG9uIEBjbGljaz1cImluY3JlbWVudFwiPlxuICAgIHt7IGNvdW50IH19XG4gIDwvYnV0dG9uPlxuPC90ZW1wbGF0ZT5cbiJ9"}),m,a(e,{key:"9c02156c",title:"%E9%80%9A%E8%BF%87%20%60%24()%60%20%E7%BB%93%E6%9E%84",link:"https%3A%2F%2Fsfc.vuejs.org%2F%23eyJBcHAudnVlIjoiPHNjcmlwdCBzZXR1cD5cbmltcG9ydCB7IHJlZiB9IGZyb20gJ3Z1ZSdcblxuaW1wb3J0IHsgdXNlTW91c2UgfSBmcm9tICdAdnVldXNlL2NvcmUnXG5cbmNvbnN0IHsgeCwgeSB9ID0gJCh1c2VNb3VzZSgpKVxuXG5jb25zb2xlLmxvZygndXNlTW91c2UnLCB4LCB5KVxuXG5mdW5jdGlvbiBteUNyZWF0ZVJlZihudW0pIHtcbiAgcmV0dXJuIHJlZihudW0pXG59XG5cbmNvbnN0IGNvdW50ID0gJChteUNyZWF0ZVJlZigwKSlcbmNvbnNvbGUubG9nKCdjb3VudCcsIGNvdW50KVxuPC9zY3JpcHQ%2BXG5cbjx0ZW1wbGF0ZT5cbiAgPGRpdj7or7fmn6XnnIvmjqfliLblj7DjgII8L2Rpdj5cbjwvdGVtcGxhdGU%2BXG4iLCJpbXBvcnQtbWFwLmpzb24iOiJ7XG4gIFwiaW1wb3J0c1wiOiB7XG4gICAgXCJ2dWVcIjogXCJodHRwczovL3NmYy52dWVqcy5vcmcvdnVlLnJ1bnRpbWUuZXNtLWJyb3dzZXIuanNcIixcbiAgICBcIkB2dWV1c2UvY29yZVwiOiBcImh0dHBzOi8vdW5wa2cuY29tL0B2dWV1c2UvY29yZS9kaXN0L2luZGV4LmVzbS5qc1wiXG4gIH1cbn0ifQ%3D%3D"}),b,a(e,{key:"3ce36809",title:"%E5%93%8D%E5%BA%94%E5%BC%8F%20props%20%E8%A7%A3%E6%9E%84",link:"https%3A%2F%2Fsfc.vuejs.org%2F%23eyJBcHAudnVlIjoiPHNjcmlwdCBzZXR1cCBsYW5nPVwidHNcIj5cbmltcG9ydCB7IGRlZmluZVByb3BzLCB3YXRjaEVmZmVjdCB9IGZyb20gJ3Z1ZSdcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgbXNnOiBzdHJpbmdcbiAgY291bnQ%2FOiBudW1iZXJcbiAgZm9vPzogc3RyaW5nXG59XG5cbi8vIOatpOasoeeahCBQcm9wcyDop6PmnoTvvIzkvJroh6rliqjnvJbor5HmiJAg5pmu6YCa55qEIHByb3BzIOWumuS5ie%2B8jOaMh%2BWumum7mOiupOWAvFxuY29uc3Qge1xuICBtc2csXG4gIC8vIOiuvue9rum7mOiupOWAvFxuICBjb3VudCA9IDEsXG4gIC8vIOino%2BaehOaXtuWRveWIq%2BWQjVxuICAvLyDov5nph4zmiJHku6zlsIYgcHJvcHMuZm9vIOWRveWQjeacqiBiYXJcbiAgZm9vOiBiYXIsXG59ID0gZGVmaW5lUHJvcHM8UHJvcHM%2BKClcblxud2F0Y2hFZmZlY3QoKCkgPT4ge1xuICBjb25zb2xlLmxvZyhtc2csIGNvdW50LCBiYXIpXG59KVxuPC9zY3JpcHQ%2BXG5cbjx0ZW1wbGF0ZT5cbiAgPGRpdj7or7fmn6XnnIvnvJbor5HlkI7nmoQgSlMuPC9kaXY%2BXG48L3RlbXBsYXRlPlxuIn0%3D"}),g,n("p",null,[s("响应性语法糖目前默认是关闭状态，需要你显式选择"),n("a",f,[s("启用"),a(o)]),s("。")])])}const y=p(d,[["render",h],["__file","reactivity-transform.html.vue"]]);export{y as default};
