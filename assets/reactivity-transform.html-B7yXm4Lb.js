import{_ as e,r as h,o as t,c as l,h as a,a as s,d as n}from"./app-BUWELqnD.js";const p={},k=s("h1",{id:"响应性语法糖",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#响应性语法糖"},[s("span",null,"响应性语法糖")])],-1),d=s("p",null,"响应性语法糖目前是一个实验性功能，默认是禁用的，需要显式选择使用。",-1),r=s("p",null,"Vue 的响应性语法糖是一个编译时的转换过程，使我们可以像这样书写代码：",-1),c=s("h2",{id:"ref-vs-响应式变量",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#ref-vs-响应式变量"},[s("span",null,"ref vs. 响应式变量")])],-1),o=n(`<p>这里的这个 <code>$ref()</code> 方法是一个编译时的宏命令：它不是一个真实的、在运行时会调用的方法。<br> 而是用作 Vue 编译器的标记，表明最终的 <code>count</code> 变量需要是一个响应式变量。</p><p>每一个会返回 <code>ref</code> 的响应性 API 都有一个相对应的、以 <code>$</code> 为前缀的宏函数。包括以下这些 API：</p><ul><li><code>ref</code> -&gt; <code>$ref</code></li><li><code>computed</code> -&gt; <code>$computed</code></li><li><code>shallowRef</code> -&gt; <code>$shalloRef</code></li><li><code>customRef</code> -&gt; <code>$customRef</code></li><li><code>toRef</code> -&gt; <code>$toRef</code></li></ul><p>当启用响应性语法糖时，这些宏函数都是全局可用的、无需手动导入。<br> 但如果你想让它更明显，你也可以选择从 <code>vue/macros</code> 中引入它们：</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">$ref</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;vue/macros&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> count</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> $ref</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre></div><h2 id="通过-结构" tabindex="-1"><a class="header-anchor" href="#通过-结构"><span>通过 <code>$()</code> 结构</span></a></h2><p>我们常常会让一个组合函数返回一个含数个 <code>ref</code> 的对象，然后解构得到这些 <code>ref</code>。对于这种场景，响应性语法糖提供了一个 <code>$()</code> 宏：</p>`,7),g=n('<h2 id="响应式-props-解构" tabindex="-1"><a class="header-anchor" href="#响应式-props-解构"><span>响应式 props 解构</span></a></h2><p>现在的 <code>&lt;script setup&gt;</code> 中对 <code>defineProps</code> 宏的使用有两个痛点：</p><ol><li>和 <code>.value</code> 类似，为了保持响应性，你需要以 <code>props.x</code> 的方式访问这些 prop。<br> 这意味着你不能通过结构 <code>defineProps</code>，因为得到的变量不是响应式的，不会更新。</li><li>使用基于类型的 <code>props</code> 声明时，无法方便地声明这些 prop 的默认值。<br> 为此，有了 <code>withDefaults()</code> API，但使用起来不方便。</li></ol><p>有了响应式语法糖，我们就可以在 <code>defineProps</code> 时，使用响应式变量相同的结构写法了：</p>',4),A=n(`<h2 id="保持在函数间的响应性" tabindex="-1"><a class="header-anchor" href="#保持在函数间的响应性"><span>保持在函数间的响应性</span></a></h2><p>虽然响应式变量使我们可以不再受 <code>.value</code> 的困扰，但它也使得我们在函数间传递响应式变量时可能造成<strong>响应性丢失</strong>的问题。<br> 这可能在以下两种场景中出现：</p><h3 id="以参数形式传入函数" tabindex="-1"><a class="header-anchor" href="#以参数形式传入函数"><span>以参数形式传入函数</span></a></h3><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> trackChange</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">x</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Ref</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">number</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  watch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">x</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;x 改变了！&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  })</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> count</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> $ref</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">trackChange</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 无效！</span></span></code></pre></div><p>上面的例子不会正常工作，因为代码被编译成了这样：</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> count</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ref</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">trackChange</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre></div><p>这里的 <code>count.value</code> 是以一个 <code>number</code> 类型值的形式传入，然而 trackChange 期望接收的是一个真正的 <code>ref</code>。<br> 要解决这个问题，可以在将 count 作为参数传入之前，用 <code>$$()</code> 包装：</p><div class="language-diff" data-highlighter="shiki" data-ext="diff" data-title="diff" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">let count = $ref(0)</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">- trackChange(count)</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">+ trackChange($$(count))</span></span></code></pre></div><p>上面的代码将被编译成：</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ref</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> count</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ref</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">trackChange</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre></div><p>我们可以看到，<code>$$()</code> 的效果就像是一个转义标识：<code>$$()</code> 中的响应式变量不会追加上 <code>.value</code>。</p><h3 id="作为函数返回值" tabindex="-1"><a class="header-anchor" href="#作为函数返回值"><span>作为函数返回值</span></a></h3><p>如果将响应式变量直接放在返回值表达式中会丢失掉响应性：</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> useMouse</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> x</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> $ref</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> y</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> $ref</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  // 监听 mousemove 事件</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  // 不起效！</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>上面的语句将被翻译为：</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  x</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  y</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>为了保持响应性，我们需要返回的是真正的 <code>ref</code>，而不是返回时 <code>ref</code> 内的值。</p><p>我们还是可以使用 <code>$$()</code> 来解决这个问题。<br> 在这个例子中，<code>$$()</code> 可以直接用在要返回的对象上，<br><code>$$()</code> 调用时任何对响应式变量的引用都会保留为对相应 <code>ref</code> 的引用：</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> useMouse</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> x</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> $ref</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> y</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> $ref</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  // 监听 mousemove 事件</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  // 修改后起效</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> $$</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">({</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  })</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><h3 id="在已解构的-prop-上使用" tabindex="-1"><a class="header-anchor" href="#在已解构的-prop-上使用"><span>在已解构的 prop 上使用 <code>$$()</code></span></a></h3><p><code>$$()</code> 适用于已解构的 prop，因为它们也是响应式的变量。编译器会高效地通过 <code>toRef</code> 来做转换：</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> defineProps</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;{ </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">count</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> number</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> }&gt;()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">passAsRef</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$$</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">))</span></span></code></pre></div><p>编译结果为：</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setup</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">props</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> __props_count</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> toRef</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">props</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;count&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  passAsRef</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">__props_count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><h2 id="显式启用" tabindex="-1"><a class="header-anchor" href="#显式启用"><span>显式启用</span></a></h2><p>响应性语法糖目前默认是关闭状态，需要你显式选择<a href="https://vuejs.org/guide/extras/reactivity-transform.html#explicit-opt-in" target="_blank" rel="noopener noreferrer">启用</a>。</p>`,26);function B(y,F){const i=h("Playground");return t(),l("div",null,[k,d,r,c,a(i,{title:"%E5%93%8D%E5%BA%94%E6%80%A7%E8%AF%AD%E6%B3%95%E7%B3%96",link:"https%3A%2F%2Fsfc.vuejs.org%2F%23eyJBcHAudnVlIjoiPHNjcmlwdCBzZXR1cD5cbmxldCBjb3VudCA9ICRyZWYoMClcbmNvbnNvbGUubG9nKGNvdW50KVxuZnVuY3Rpb24gaW5jcmVtZW50KCkge1xuICBjb3VudCsrXG59XG48L3NjcmlwdD5cblxuPHRlbXBsYXRlPlxuICA8YnV0dG9uIEBjbGljaz1cImluY3JlbWVudFwiPlxuICAgIHt7IGNvdW50IH19XG4gIDwvYnV0dG9uPlxuPC90ZW1wbGF0ZT5cbiJ9"}),o,a(i,{title:"%E9%80%9A%E8%BF%87%20%60%24()%60%20%E7%BB%93%E6%9E%84",link:"https%3A%2F%2Fsfc.vuejs.org%2F%23eyJBcHAudnVlIjoiPHNjcmlwdCBzZXR1cD5cbmltcG9ydCB7IHJlZiB9IGZyb20gJ3Z1ZSdcblxuaW1wb3J0IHsgdXNlTW91c2UgfSBmcm9tICdAdnVldXNlL2NvcmUnXG5cbmNvbnN0IHsgeCwgeSB9ID0gJCh1c2VNb3VzZSgpKVxuXG5jb25zb2xlLmxvZygndXNlTW91c2UnLCB4LCB5KVxuXG5mdW5jdGlvbiBteUNyZWF0ZVJlZihudW0pIHtcbiAgcmV0dXJuIHJlZihudW0pXG59XG5cbmNvbnN0IGNvdW50ID0gJChteUNyZWF0ZVJlZigwKSlcbmNvbnNvbGUubG9nKCdjb3VudCcsIGNvdW50KVxuPC9zY3JpcHQ%2BXG5cbjx0ZW1wbGF0ZT5cbiAgPGRpdj7or7fmn6XnnIvmjqfliLblj7DjgII8L2Rpdj5cbjwvdGVtcGxhdGU%2BXG4iLCJpbXBvcnQtbWFwLmpzb24iOiJ7XG4gIFwiaW1wb3J0c1wiOiB7XG4gICAgXCJ2dWVcIjogXCJodHRwczovL3NmYy52dWVqcy5vcmcvdnVlLnJ1bnRpbWUuZXNtLWJyb3dzZXIuanNcIixcbiAgICBcIkB2dWV1c2UvY29yZVwiOiBcImh0dHBzOi8vdW5wa2cuY29tL0B2dWV1c2UvY29yZS9kaXN0L2luZGV4LmVzbS5qc1wiXG4gIH1cbn0ifQ%3D%3D"}),g,a(i,{title:"%E5%93%8D%E5%BA%94%E5%BC%8F%20props%20%E8%A7%A3%E6%9E%84",link:"https%3A%2F%2Fsfc.vuejs.org%2F%23eyJBcHAudnVlIjoiPHNjcmlwdCBzZXR1cCBsYW5nPVwidHNcIj5cbmltcG9ydCB7IGRlZmluZVByb3BzLCB3YXRjaEVmZmVjdCB9IGZyb20gJ3Z1ZSdcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgbXNnOiBzdHJpbmdcbiAgY291bnQ%2FOiBudW1iZXJcbiAgZm9vPzogc3RyaW5nXG59XG5cbi8vIOatpOasoeeahCBQcm9wcyDop6PmnoTvvIzkvJroh6rliqjnvJbor5HmiJAg5pmu6YCa55qEIHByb3BzIOWumuS5ie%2B8jOaMh%2BWumum7mOiupOWAvFxuY29uc3Qge1xuICBtc2csXG4gIC8vIOiuvue9rum7mOiupOWAvFxuICBjb3VudCA9IDEsXG4gIC8vIOino%2BaehOaXtuWRveWIq%2BWQjVxuICAvLyDov5nph4zmiJHku6zlsIYgcHJvcHMuZm9vIOWRveWQjeacqiBiYXJcbiAgZm9vOiBiYXIsXG59ID0gZGVmaW5lUHJvcHM8UHJvcHM%2BKClcblxud2F0Y2hFZmZlY3QoKCkgPT4ge1xuICBjb25zb2xlLmxvZyhtc2csIGNvdW50LCBiYXIpXG59KVxuPC9zY3JpcHQ%2BXG5cbjx0ZW1wbGF0ZT5cbiAgPGRpdj7or7fmn6XnnIvnvJbor5HlkI7nmoQgSlMuPC9kaXY%2BXG48L3RlbXBsYXRlPlxuIn0%3D"}),A])}const b=e(p,[["render",B],["__file","reactivity-transform.html.vue"]]),C=JSON.parse('{"path":"/notes/frontend/vue/vue3/extra/reactivity-transform.html","title":"响应性语法糖","lang":"zh-CN","frontmatter":{"order":90,"category":["笔记","frontend","vue"],"tag":["vue3"],"description":"响应性语法糖 响应性语法糖目前是一个实验性功能，默认是禁用的，需要显式选择使用。 Vue 的响应性语法糖是一个编译时的转换过程，使我们可以像这样书写代码： ref vs. 响应式变量 这里的这个 $ref() 方法是一个编译时的宏命令：它不是一个真实的、在运行时会调用的方法。 而是用作 Vue 编译器的标记，表明最终的 count 变量需要是一个响应式...","head":[["meta",{"property":"og:url","content":"https://www.zhaobc.site/notes/frontend/vue/vue3/extra/reactivity-transform.html"}],["meta",{"property":"og:site_name","content":"赵斌的小站"}],["meta",{"property":"og:title","content":"响应性语法糖"}],["meta",{"property":"og:description","content":"响应性语法糖 响应性语法糖目前是一个实验性功能，默认是禁用的，需要显式选择使用。 Vue 的响应性语法糖是一个编译时的转换过程，使我们可以像这样书写代码： ref vs. 响应式变量 这里的这个 $ref() 方法是一个编译时的宏命令：它不是一个真实的、在运行时会调用的方法。 而是用作 Vue 编译器的标记，表明最终的 count 变量需要是一个响应式..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-21T05:57:34.000Z"}],["meta",{"property":"article:author","content":"Zhao Bin"}],["meta",{"property":"article:tag","content":"vue3"}],["meta",{"property":"article:modified_time","content":"2023-02-21T05:57:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"响应性语法糖\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-02-21T05:57:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Zhao Bin\\",\\"url\\":\\"zhaobc.site\\",\\"email\\":\\"hi@zhaobc.site\\"}]}"]]},"headers":[{"level":2,"title":"ref vs. 响应式变量","slug":"ref-vs-响应式变量","link":"#ref-vs-响应式变量","children":[]},{"level":2,"title":"通过 $() 结构","slug":"通过-结构","link":"#通过-结构","children":[]},{"level":2,"title":"响应式 props 解构","slug":"响应式-props-解构","link":"#响应式-props-解构","children":[]},{"level":2,"title":"保持在函数间的响应性","slug":"保持在函数间的响应性","link":"#保持在函数间的响应性","children":[{"level":3,"title":"以参数形式传入函数","slug":"以参数形式传入函数","link":"#以参数形式传入函数","children":[]},{"level":3,"title":"作为函数返回值","slug":"作为函数返回值","link":"#作为函数返回值","children":[]},{"level":3,"title":"在已解构的 prop 上使用 $$()","slug":"在已解构的-prop-上使用","link":"#在已解构的-prop-上使用","children":[]}]},{"level":2,"title":"显式启用","slug":"显式启用","link":"#显式启用","children":[]}],"git":{"createdTime":1655202702000,"updatedTime":1676959054000,"contributors":[{"name":"Zhao Bin","email":"413853119@qq.com","commits":6}]},"readingTime":{"minutes":3.98,"words":1194},"filePathRelative":"notes/frontend/vue/vue3/extra/reactivity-transform.md","localizedDate":"2022年6月14日","excerpt":"\\n<p>响应性语法糖目前是一个实验性功能，默认是禁用的，需要显式选择使用。</p>\\n<p>Vue 的响应性语法糖是一个编译时的转换过程，使我们可以像这样书写代码：</p>\\n<h2>ref vs. 响应式变量</h2>\\n\\n<p>这里的这个 <code>$ref()</code> 方法是一个编译时的宏命令：它不是一个真实的、在运行时会调用的方法。<br>\\n而是用作 Vue 编译器的标记，表明最终的 <code>count</code> 变量需要是一个响应式变量。</p>\\n<p>每一个会返回 <code>ref</code> 的响应性 API 都有一个相对应的、以 <code>$</code> 为前缀的宏函数。包括以下这些 API：</p>","autoDesc":true}');export{b as comp,C as data};
