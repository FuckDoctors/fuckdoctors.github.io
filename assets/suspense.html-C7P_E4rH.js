import{_ as i,c as e,a,o as t}from"./app-BhCyOiz2.js";const n={};function p(l,s){return t(),e("div",null,s[0]||(s[0]=[a(`<h1 id="suspense" tabindex="-1"><a class="header-anchor" href="#suspense"><span>Suspense</span></a></h1><p><code>&lt;Suspense&gt;</code> 是一个内置组件，用来在组件树中编排异步依赖。它可以在等待组件树下的多个嵌套异步依赖项解析完成时，呈现加载状态。</p><h2 id="异步依赖" tabindex="-1"><a class="header-anchor" href="#异步依赖"><span>异步依赖</span></a></h2><p>有了 <code>&lt;Suspense&gt;</code> 组件后，我们就可以在等待整个多层级组件树中的各个异步依赖获取结果时，在顶层展示出加载中或加载失败的状态。</p><p><code>&lt;Suspense&gt;</code> 可以等待的异步依赖有两种：</p><ol><li>带有异步 <code>setup()</code> 钩子的组件。这也包含了使用 <code>&lt;script setup&gt;</code> 时有顶层 <code>await</code> 表达式的组件。</li><li><a href="https://staging-cn.vuejs.org/guide/components/async.html" target="_blank" rel="noopener noreferrer">异步组件</a></li></ol><h3 id="async-setup" tabindex="-1"><a class="header-anchor" href="#async-setup"><span>async setup()</span></a></h3><p>组合式 API 中组件的 <code>setup()</code> 钩子可以是异步的:</p><div class="language-js" data-highlighter="shiki" data-ext="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">export</span><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;"> default</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  async</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> setup</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> res</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> await</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> fetch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> posts</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> await</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> res</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">json</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">      posts</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>如果使用 <code>&lt;script setup&gt;</code>，那么顶层 <code>await</code> 表达式会自动让该组件成为一个异步依赖：</p><div class="language-vue" data-highlighter="shiki" data-ext="vue" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-vue"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">script</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> setup</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> res</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> await</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> fetch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> posts</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> await</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> res</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">json</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">script</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre></div><h3 id="异步组件" tabindex="-1"><a class="header-anchor" href="#异步组件"><span>异步组件</span></a></h3><p>异步组件默认就是**&quot;suspensible&quot;**的。这意味着如果组件关系链上有一个 <code>&lt;Suspense&gt;</code>，那么这个异步组件就会被当作这个 <code>&lt;Suspense&gt;</code> 的一个异步依赖。<br> 在这种情况下，加载状态是由 <code>&lt;Suspense&gt;</code> 控制，而该组件自己的加载、报错、延时和超时等选项都将被忽略。</p><p>异步组件也可以通过在选项中指定 <code>suspensible: false</code> 表明不用 <code>Suspense</code> 控制，并让组件始终自己控制其加载状态。</p><h2 id="加载中状态" tabindex="-1"><a class="header-anchor" href="#加载中状态"><span>加载中状态</span></a></h2><p><code>&lt;Suspense&gt;</code> 组件有两个插槽：<code>#default</code> 和 <code>#fallback</code>。<br> 两个插槽都只允许一个直接子节点。在可能的时候都将显示默认槽中的节点。否则将显示后备槽中的节点。</p><div class="language-vue" data-highlighter="shiki" data-ext="vue" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-vue"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Suspense</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;!-- 具有深层异步依赖的组件 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;Dashboard /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;!-- 在 #fallback 插槽中显示 “正在加载中”  --&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;template #fallback&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    &lt;div&gt;Loading...&lt;/div&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;/template&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Suspense</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre></div><p>在初始渲染时，<code>&lt;Suspense&gt;</code> 将在内存中渲染其默认的插槽内容。<br> 如果在这个过程中遇到任何异步依赖，则会进入挂起状态。在挂起状态期间，展示的是后备内容。<br> 当所有遇到的异步依赖都完成后，<code>&lt;Suspense&gt;</code> 会进入完成状态，并将展示出默认插槽的内容。</p><p>如果在初次渲染时没有遇到异步依赖，<code>&lt;Suspense&gt;</code> 会直接进入完成状态。</p><p>进入完成状态后，只有当默认插槽的根节点被<strong>替换</strong>时，<code>&lt;Suspense&gt;</code> 才会回到挂起状态。组件树中新的更深层次的异步依赖<strong>不会</strong>造成 <code>&lt;Suspense&gt;</code> 回退到挂起状态。</p><p>发生回退时，后备内容不会立即展示出来。相反，<code>&lt;Suspense&gt;</code> 在等待新内容和异步依赖完成时，会展示之前 <code>#default</code> 插槽的内容。<br> 这个行为可以通过一个 <code>timeout</code> prop 进行配置：<br> 在等待渲染新内容耗时超过 <code>timeout</code> 之后，<code>&lt;Suspense&gt;</code> 将会切换为展示后备内容。若 <code>timeout</code> 值为 <code>0</code> 将导致在替换默认内容时立即显示后备内容。</p><h2 id="事件" tabindex="-1"><a class="header-anchor" href="#事件"><span>事件</span></a></h2><p>除了 <code>pending</code> 事件之外，<code>&lt;suspense&gt;</code> 组件还有 <code>resolve</code> 和 <code>fallback</code> 事件。<br><code>pending</code> 事件是在进入挂起状态时触发。<code>resolve</code> 事件是在 <code>default</code> 插槽完成获取新内容时触发。<code>fallback</code> 事件则是在 <code>fallback</code> 插槽展示时触发。</p><p>例如，可以使用这些事件在加载新组件时在之前的 DOM 最上层显示一个加载指示器。</p><h2 id="错误处理" tabindex="-1"><a class="header-anchor" href="#错误处理"><span>错误处理</span></a></h2><p><code>&lt;Suspense&gt;</code> 组件自身目前还不提供错误处理，不过你可以使用 <code>errorCaptured</code> 选项或者 <code>onErrorCaptured()</code> 钩子，在使用到 <code>&lt;Suspense&gt;</code> 的父组件中捕获和处理异步错误。</p><h2 id="和其他组件结合" tabindex="-1"><a class="header-anchor" href="#和其他组件结合"><span>和其他组件结合</span></a></h2><p>我们常常会将 <code>&lt;Suspense&gt;</code> 和 <code>&lt;Transition&gt;</code>、<code>&lt;KeepAlive&gt;</code> 等组件结合。要保证这些组件都能正常工作，嵌套的顺序非常重要。</p><p>另外，这些组件都通常与 Vue Router 中的 <code>&lt;RouterView&gt;</code> 组件结合使用。</p><div class="language-vue" data-highlighter="shiki" data-ext="vue" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-vue"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">RouterView</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> v-slot</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{ </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">Component</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> }</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;template v-if=&quot;Component&quot;&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    &lt;Transition mode=&quot;out-in&quot;&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      &lt;KeepAlive&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        &lt;Suspense&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">          &lt;!-- 主要内容 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">          &lt;component :is=&quot;Component&quot; /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">          &lt;!-- 加载中的状态 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">          &lt;template #fallback&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            &lt;div&gt;正在加载中...&lt;/div&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">          &lt;/template&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        &lt;/Suspense&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      &lt;/KeepAlive&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    &lt;/Transition&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;/template&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">RouterView</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre></div><p>Vue Router 使用动态导入对<a href="https://next.router.vuejs.org/guide/advanced/lazy-loading.html" target="_blank" rel="noopener noreferrer">懒加载组件</a>进行了内置支持。<br> 这些与异步组件不同，目前他们不会触发 <code>&lt;Suspense&gt;</code>。但是，它们仍然可以有异步组件作为后代，这些组件可以照常触发 <code>&lt;Suspense&gt;</code>。</p>`,31)]))}const k=i(n,[["render",p]]),d=JSON.parse('{"path":"/notes/frontend/vue/vue3/built-ins/suspense.html","title":"Suspense","lang":"zh-CN","frontmatter":{"order":50,"category":["笔记","frontend","vue"],"tag":["vue3"],"description":"Suspense <Suspense> 是一个内置组件，用来在组件树中编排异步依赖。它可以在等待组件树下的多个嵌套异步依赖项解析完成时，呈现加载状态。 异步依赖 有了 <Suspense> 组件后，我们就可以在等待整个多层级组件树中的各个异步依赖获取结果时，在顶层展示出加载中或加载失败的状态。 <Suspense> 可以等待的异步依赖有两种： 带有异步...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Suspense\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-08T03:57:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Zhao Bin\\",\\"url\\":\\"zhaobc.site\\",\\"email\\":\\"hi@zhaobc.site\\"}]}"],["meta",{"property":"og:url","content":"https://www.zhaobc.site/notes/frontend/vue/vue3/built-ins/suspense.html"}],["meta",{"property":"og:site_name","content":"赵斌的小站"}],["meta",{"property":"og:title","content":"Suspense"}],["meta",{"property":"og:description","content":"Suspense <Suspense> 是一个内置组件，用来在组件树中编排异步依赖。它可以在等待组件树下的多个嵌套异步依赖项解析完成时，呈现加载状态。 异步依赖 有了 <Suspense> 组件后，我们就可以在等待整个多层级组件树中的各个异步依赖获取结果时，在顶层展示出加载中或加载失败的状态。 <Suspense> 可以等待的异步依赖有两种： 带有异步..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-08T03:57:26.000Z"}],["meta",{"property":"article:tag","content":"vue3"}],["meta",{"property":"article:modified_time","content":"2024-08-08T03:57:26.000Z"}],["link",{"rel":"alternate","type":"application/rss+xml","href":"https://www.zhaobc.site/rss.xml","title":"赵斌的小站 RSS Feed"}]]},"git":{"createdTime":1652753844000,"updatedTime":1723089446000,"contributors":[{"name":"Zhao Bin","username":"","email":"413853119@qq.com","commits":5}]},"readingTime":{"minutes":3.65,"words":1095},"filePathRelative":"notes/frontend/vue/vue3/built-ins/suspense.md","excerpt":"\\n<p><code>&lt;Suspense&gt;</code> 是一个内置组件，用来在组件树中编排异步依赖。它可以在等待组件树下的多个嵌套异步依赖项解析完成时，呈现加载状态。</p>\\n<h2>异步依赖</h2>\\n<p>有了 <code>&lt;Suspense&gt;</code> 组件后，我们就可以在等待整个多层级组件树中的各个异步依赖获取结果时，在顶层展示出加载中或加载失败的状态。</p>\\n<p><code>&lt;Suspense&gt;</code> 可以等待的异步依赖有两种：</p>\\n<ol>\\n<li>带有异步 <code>setup()</code> 钩子的组件。这也包含了使用 <code>&lt;script setup&gt;</code> 时有顶层 <code>await</code> 表达式的组件。</li>\\n<li><a href=\\"https://staging-cn.vuejs.org/guide/components/async.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">异步组件</a></li>\\n</ol>","autoDesc":true}');export{k as comp,d as data};
