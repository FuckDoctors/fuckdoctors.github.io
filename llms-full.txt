---
url: 'https://zhaobc.site/about.md'
description: 关于赵斌
---
# 关于我
## 个人介绍

网络用名：`zhbchwin`，`UJN-Bin`。~~`FuckDoctors`（确实痛恨无良医生，请见谅，请忽略）~~

真实名称`Zhao Binchen`，所以才用了此域名[zhaobc.site](https://www.zhaobc.site)。

## 兴趣爱好

没啥兴趣爱好，喜欢瞎折腾(ㄒoㄒ)

## 联系方式

* 邮件：<hi@zhaobc.site>
* GitHub: [FuckDoctors](https://github.com/FuckDoctors)

---

---
url: 'https://zhaobc.site/links.md'
description: 链接
---
# 链接
## 工具

## 友情链接

---

---
url: 'https://zhaobc.site/notes/index.md'
---
# 笔记

## 初衷

> 纸上得来终觉浅，绝知此事要躬行。

有些事情看过，感觉自己知道，但是要用的时候又不记得了，所以，学习不能只看，还要动手，加深印象。
本仓库的目的是记录学习的东西，边学边动手，照着学习资料手抄一下，不用全抄，记录重点内容即可。

大体分为前端和后端，主要有一下内容。（感觉会以前端为主，因为感兴趣）
注：内容可能随时更新。

## [前端](frontend/)

主要是基础的 JavaScript, CSS3，TypeScript 以及前端框架，比如 Vue。

目录如下：

* JavaScript
  * [JavaScript 基础教程](frontend/js/)
* CSS3
  * 待定
* [TypeScript](frontend/ts/)
  * TypeScript 官方资料
* [Vue](frontend/vue/)
  * Vue 官方资料

## [后端](backend/)

主要是 Java，.Net 以及后台框架，比如 Spring，SpringBoot 等。

目录结构如下：

* [Java](backend/java/)
  * 待定
* .Net
  * 待定
* [Spring](backend/spring/)
  * 待定
* SpringBoot
  * 待定
* [Python](backend/python/)
  * [Python 官方教程](https://docs.python.org/zh-cn/3/tutorial/index.html)
  * [Python 100 天从新手到大师](https://github.com/jackfrued/Python-100-Days)

## [其他](other/)

其他内容

---

---
url: 'https://zhaobc.site/notes/backend/index.md'
---
# 后端笔记

记录后端相关的学习笔记

---

---
url: 'https://zhaobc.site/notes/backend/java/index.md'
---
# Java 笔记

Java 相关的学习笔记。

---

---
url: 'https://zhaobc.site/notes/backend/java/code-snippets/dbunit.md'
---
# DBUnit 相关代码片段

## 根据不同连接创建不同的数据库连接

```java
private IDatabaseConnection createDatabaseConnection(Connection conn, String schema) {
  IDatabaseConnection dbUnitConn = new DatabaseConnection(conn, schema);
  DatabaseConfig config = dbUnitConn.getConfig();
  config.setProperty(DatabaseConfig.PROPERTY_ESCAPE_PATTERN, "\"?\"");
  config.setProperty(DatabaseConfig.FEATURE_ALLOW_EMPTY_FILEDS, true);

  String dbName = conn.getMetaData().getDatabaseProductName().toLowerCase();
  if (dbName.contains("oracle")) {
    // 注意这里没有使用 OracleDataTypeFactory, 而是自己的 MyOracleDataTypeFactory
    config.setProperty(DatabaseConfig.PROPERTY_DATETYPE_FACTORY, new MyOracleDataTypeFactory());
  } else if (dbName.contains("mysql")) {
    config.setProperty(DatabaseConfig.PROPERTY_DATETYPE_FACTORY, new MySqlDataTypeFactory());
    config.setProperty(DatabaseConfig.PROPERTY_METADATA_HANDLER, new MySqlMetadataHandler());
  }
}
```

## 自定义数据类型

如果想做特殊处理的话，自定义 `DataType`, 然后注册到 `DataTypeFactory`。

比如，对于 Oracle 数据库的 `CHAR` 类型，预期值跟实际值比较时，忽略空格后比较。
可以自定义 DataType 来实现。

### 自定义字符串数据类型

```java
public class StringDataTypeIgnoreSpaceDataType extends StringDataType {
  public StringDataTypeIgnoreSpaceDataType(String name, int sqlType) {
    super(name, sqlType);
  }

  @Override
  protected int compareNonNulls(Object value1, Object value2) throws TypeCastException {
    String val1 = (String) value1;
    String val2 = (String) value2;

    return val1.strip().compareTo(val2.strip());
  }
}
```

### 注册到数据类型工厂

```java

public class MyOracleDataTypeFactory extends OracleDataTypeFactory {

  // 第二个参数的 sqlType 跟原来的 sqlType 保持一致
  public static final DataType MY_CHAR = new StringDataTypeIgnoreSpaceDataType("CHAR", 1);
  public static final DataType MY_NCHAR = new StringDataTypeIgnoreSpaceDataType("NCHAR", -15);

  @Override
  public DataType createDataType(int sqlType, String sqlTypeName) throws DataTypeException {
    if ("CHAR".equals(sqlTypeName)) {
      return MY_CHAR;
    } else {
      return super.createDataType(sqlType, sqlTypeName);
    }
  }

}

```

---

---
url: 'https://zhaobc.site/notes/backend/java/code-snippets/group-by.md'
---
# Group by 使用

## 多个字段的 Group By

```java
list.stream()
  .filter(item -> item.getDate() <= curDate)
  .collect(Collectors.groupingBy(item -> item.getClass() + "_" + item.getName(),
    Collectors.maxBy(Comparator.comparing(ADto::getScore)))
  .values()
  .stream()
  .collect(Collectors.toList())
  .stream()
  .filter(item -> item.isPresent())
  .map(item -> item.get())
  .collect(Collectors.toList());
```

```java
Map<String, List<AClass>> groupedMap = list.stream()
  .collect(Collectors.groupingBy(a -> a.getClass() + "," + a.getName() + "," + a.getType()),
              LinkedHashMap::new,
              Collectors.toList()));
```

---

---
url: 'https://zhaobc.site/notes/backend/java/code-snippets/mockito.md'
---
# Mockito 相关代码片段

## 参数验证

JUnit 测试时，对应 Mocked 方法，我们可以返回自己想要的返回值或异常，但是有时希望验证一下，我们调用时传的参数是否正确。

此时，可以使用 ArgumentCaptor 来收集参数，进而做验证。

示例：

```java
ArgumentCaptor<TestIn> argCaptor = ArgumentCaptor.forClass(TestIn.class);
// 调用 （注意，这里指定了类型，不指定的话有些时候不能正确执行，比如， dao.find(any()) 就不知实际该匹配哪个，可能返回 null）
testService.doMethod(any(TestIn.class)).thenReturn(1);
// 参数收集
verify(testService).doMethod(argCaptor.captor());
// 参数校验
assertEquals("0", argCaptor.getValue().getInArg());
```

多次调用时的验证：

```java
ArgumentCaptor<TestIn> argCaptor = ArgumentCaptor.forClass(TestIn.class);

// 参数收集
verify(testService, times(2)).doMethod(argCaptor.captor());
List<TestIn> inValues = argCaptor.getAllValues();

// 参数校验
// 第一次调用的参数验证
assertEquals("0", inValues.get(0).getInArg());
// 第二次调用的参数验证
assertEquals("1", inValues.get(1).getInArg());
```

## 编程式返回期待值

```java
when(testService.doMethod(any())).thenAnswer(inv -> {
  TestIn in = inv.getArgument(0, TestIn.class);
  TestOut out = new TestOut();

  out.setA(in.getA());
  if ("".equals(in.getB())) {
    out.setOb("1");
  }

  return out;
});

when(testService.doMethod2(eq("1"), any())).thenReturn("0");
```

## 参数为对象时，返回 null （无法正确匹配）

当参数为对象类型时，为了能区分不太的参数，返回不同的内容，需要自定义参数匹配来实现。
单纯的用 `any(InParam.class)` 是无法实现的。

自定义参数匹配示例：

```java
public class MessageMatcher implements ArgumentMatcher<Message> {

    private Message left;

    // constructors

    @Override
    public boolean matches(Message right) {
        return left.getFrom().equals(right.getFrom()) &&
          left.getTo().equals(right.getTo()) &&
          left.getText().equals(right.getText()) &&
          right.getDate() != null &&
          right.getId() != null;
    }
}
```

使用：

```java
// 业务代码
MessageDTO messageDTO = new MessageDTO();
messageDTO.setFrom("me");
messageDTO.setTo("you");
messageDTO.setText("Hello, you!");

messageController.createMessage(messageDTO);

// JUnit 代码
Message message = new Message();
message.setFrom("me");
message.setTo("you");
message.setText("Hello, you!");

verify(messageService, times(1)).deliverMessage(argThat(new MessageMatcher(message)));
```

关于自定义参数匹配，可以参考这篇文章: [Mockito ArgumentMatchers](https://www.baeldung.com/mockito-argument-matchers)。

---

---
url: 'https://zhaobc.site/notes/backend/java/code-snippets/sort.md'
---
# 排序

## 多个字段的排序

```java
Comparator<ADto> comparator = Comparator
  .comparing(ADto::getClass, Comparator.nullsLast(Comparator.naturalOrder()))
  .thenComparing(ADto::getScore, Comparator.nullsLast(Comparator.reverseOrder()))
  .thenComparing(ADto::getName, Comparator.nullsLast(String::compareTo));

list.sort(comparator);
```

## 按语言排序

```java
Comparator<ADto> comparator = Comparator
  .comparing(ADto::getClass, Comparator.nullsLast(Comparator.naturalOrder()))
  .thenComparing(ADto::getScore, Comparator.nullsLast(Comparator.reverseOrder()))
  .thenComparing(ADto::getName, Comparator.nullsLast(Collator.getInstance(Locale.SIMPLIFIED_CHINESE)));

list.sort(comparator);
```

---

---
url: 'https://zhaobc.site/notes/backend/python/index.md'
---
# Python

---

---
url: 'https://zhaobc.site/notes/backend/python/python-100-days/index.md'
---
# Python - 100 天从新手到大师

本笔记以 [Python - 100 天从新手到大师](https://github.com/jackfrued/Python-100-Days) 为学习教程，记录一些学习笔记。

---

---
url: 'https://zhaobc.site/notes/backend/python/python-100-days/day-01-15/index.md'
---
# Day 01-15

---

---
url: >-
  https://zhaobc.site/notes/backend/python/python-100-days/day-01-15/01.初识Python.md
---
# 01.初识 Python

## 安装 Python 解析器

以下以 centos 为例：

```shell
# 安装所需依赖
yum -y install wget gcc zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel

# 下载源代码并解压
wget https://www.python.org/ftp/python/3.7.6/Python-3.7.6.tar.xz
xz -d Python-3.7.6.tar.xz
tar -xvf Python-3.7.6.tar

# 编译安装
cd Python-3.7.6
./configure --prefix=/usr/local/python37 --enable-optimizations
make && make install
```

## 查看 Python 版本

```shell
python --version
# 或
python3 --version
```

::: warning
Unix 系统中，为了不与同时安装的 Python 2.x 冲突，Python 3.x 解释器默认安装的执行文件名不是 python。
:::

可以进入 python 交互环境查看版本号：

```python
import sys

print(sys.version_info)
print(sys.version)
```

## 调用参数

解释器读取命令行参数，把脚本名与其他参数转换为字符串列表，存到 `sys` 模块的 `argv` 变量中。
执行 `import sys`, 可以导入这个模块，并访问该列表。
该列表至少有一个元素，未指定参数时，`sys.argv[0]` 是一个空字符串。
给定脚本名是 `-` 时，`sys.argv[0]` 是 `-`。
使用 `-c command` 时，`sys.argv[0]` 是 `-c`。
如果使用选项 `-m module` 时，`sys.argv[0]` 就是包含目录的模块全名。

解释器不处理 `-c command` 或 `-m module` 之后的选项，而是直接留在 `sys.argv` 中，由命令或模块来处理。

### `-c command`

执行 *command* 中的 Python 代码。*command* 可以是一条语句，也可以是用换行符分割的多条语句。

使用此项时，`sys.argv` 的首个元素为 `-c`，并会把当前目录加入至 `sys.path` 开头。

### `-m module-name`

在 `sys.path` 中搜索指定的模块，并以 `__main__` 模块执行其内容。

该参数是 *模块名*，请勿输入文件扩展名（`.py`）。模块名应为有效的绝对 Python 模块名。

如果给出此选项，`sys.argv` 的首个元素将为模块文件的完整路径 (在定位模块文件期间，首个元素将设为 "-m")。 与 `-c` 选项一样，当前目录将被加入 `sys.path`的开头。

## 编写 Python 源代码

编写 python 源代码，并使用 `.py` 作为文件后缀。

例：

```python
# hello.py
print('hello, world!')
```

## 源文件的字符编码

默认情况下，Python 源码文件的编码是 UTF-8。

如果不使用默认编码时，则要声明文件的编码，文件的 *第一行* 要写成特殊的注释，如下：

```python
# -*- coding: encoding -*-
```

其中，*encoding* 就是 Python 支持的编码，比如：`gb2313`。

第一行也有例外，源代码以 `shebang` 开头时，编码声明则要写在第二行：

```python
#!/usr/bin/env python3
# -*- coding: gb2313 -*-
```

详情：[源文件的字符编码](https://docs.python.org/zh-cn/3/tutorial/interpreter.html#source-code-encoding)

## 运行 Python

```shell
python hello.py
# 或
python3 hello.py
```

## 代码注释

1. 单行注释
   以#和空格开头的部分
2. 多行注释
   3 个引号开头，3 个引号结尾

例：

```python
"""
这里可以写多行注释
这是第二行注释
"""
# 这是单行注释
print('hello, world!')
```

## 开发工具

* PyCharm
* VS Code

## 示例

```python
"""
这里可以写多行注释，比如：
Version: 0.1
Author: zhaobc
"""

print('hello, world!')
print("hello, world!")
print('hello', 'world')
print('hello', 'world', sep=',', end='!')
print('goodbye, world', end='!')
```

试一试：

```shell
python day-01-15/day-01/hello.py
```

---

---
url: 'https://zhaobc.site/notes/backend/python/python-100-days/day-01-15/02.语言元素.md'
---
# 02.语言元素

## 变量和类型

常用的数据类型：

* 整型
  Python 2.x 中有 `int` 和 `long`，Python 3.x 中只有 `int`。
  支持二进制（`0b100`，十进制 4），八进制（`0o100`，十进制 64），十六进制（`0x100`，十进制 256）
* 浮点型
  浮点数除了支持数学写法，如 `123.456`，还支持科学计数法，如 `1.23456e2`
* 字符串型
  以单引号或双引号括起来的任意文本，比如 `'hello'` 或 `"hello"`
* 布尔型
  布尔值只有 `True` 和 `False`，注意大小写。
* 复数型
  形如 `3+5j`，跟数学上的复数一样，只不过是虚部的 `i` 换成了 `j`。

## 变量命名

* 硬性规则
  * 变量由字母，数字和下划线构成，数字不能开头。
  * 大小写敏感
  * 不要跟关键字，保留字冲突
* PEP 8 要求
  * 小写字母拼写，下划线连接
  * 受保护的实例属性用单个下划线开头
  * 私有的实例属性用两个下划线开头

## 变量的使用

在 Python 中可以使用 `type` 函数对变量的类型进行检查。

```python
a = 100
b = 12.345
c = 1 + 5j
d = 'hello, world'
e = True

print(type(a))  # <class 'int'>
print(type(b))  # <class 'float'>
print(type(c))  # <class 'complex'>
print(type(d))  # <class 'str'>
print(type(e))  # <class 'bool'>
```

试一试：

```shell
python day-01-15/day-02/var-type.py
```

可以使用 Python 中的内置函数对变量类型进行变换。

* `int()` 将一个数值或字符串转换成正数，可以指定进制。
* `float()` 将一个字符串转换成浮点数。
* `str()` 将指定的对象转换成字符串形式，可以指定编码。
* `chr()` 将整数转换成该编码对应的字符串（一个字符）。
* `ord()` 将字符串（一个字符）转换成对应的编码（整数）

下面的代码通过键盘输入两个整数来实现对两个整数的算术运算。

```python
a = int(input('a = '))
b = int(input('b = '))

print('%d + %d = %d' % (a, b, a + b))
print('%d - %d = %d' % (a, b, a - b))
print('%d * %d = %d' % (a, b, a * b))
print('%d / %d = %f' % (a, b, a / b))
print('%d // %d = %d' % (a, b, a // b))
print('%d %% %d = %d' % (a, b, a % b))
print('%d ** %d = %f' % (a, b, a ** b))
```

试一试：

```shell
python day-01-15/day-02/calc.py
```

## 运算符

Python 支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符。

| 运算符            | 描述                           |
| ----------------- | ------------------------------ |
| `[]` `[:]`        | 下标，切片                     |
| `**`              | 指数                           |
| `~` `+` `-`       | 按位取反，正负号               |
| `*` `/` `%` `//`  | 乘，除，摸，整除               |
| `+` `-`           | 加，减                         |
| `>>` `<<`         | 右移，左移                     |
| `&`               | 按位与                         |
| `^` `\|`          | 按位异或，按位或               |
| `<=` `<` `>` `>=` | 小于等于，小于，大于，大于等于 |
| `==` `!=`         | 等于，不等于                   |
| `is` `is not`     | 身份运算符                     |
| `in` `not in`     | 成员运算符                     |
| `not` `or` `and`  | 逻辑运算符                     |
| `+=` `-=` 等      | `a +=b` 等价于 `a = a + b`     |

## 练习

### 华氏温度转换为摄氏温度

::: tip
华氏温度到摄氏温度的转换公式为：$C=(F - 32) \div 1.8$。
:::

```python
'''
华氏温度转换为摄氏温度
'''

f = float(input('请输入华氏温度：'))
c = (f - 12) / 1.8
print('%.1f华氏度 = %.1f摄氏度' % (f, c))
```

在使用 `print` 函数输出时，也可以对字符串内容进行格式化处理。
上面的 `print` 函数中的字符串 `%.1f` 是一个占位符，稍后会由一个 `float` 变量替换它。
同理， `%s` 由字符串替换，`%d` 用整数变量替换。

除了这种格式化字符串的方式外，还可以用下面的方式来格式化字符串，其中 `{f:.1f}` 和 `{c:.1f}` 可以先看成 `{f}` 和 `{c}`，表示输出时会用变量 `f` 和 `c` 的值会替换掉这两个占位符，后面的 `%.1f` 表示这是一个浮点数，小数点后保留 1 位有效数字。

```python
print(f'{f:.1f}华氏度 = {c:.1f}摄氏度')
```

试一试：

```shell
python day-01-15/day-02/deg-converter.py
```

### 输入年份判断是不是闰年

```python
"""
输入年份判断是不是闰年
"""

year = int(input("请输入年份："))
is_leap = year % 4 == 0 and year % 100 != 0 \
          or year % 400 == 0
print(is_leap)
```

试一试：

```shell
python day-01-15/day-02/is-leap.py
```

---

---
url: 'https://zhaobc.site/notes/backend/python/python-100-days/day-01-15/03.分支结构.md'
---
# 03.分支结构

## `if` 分支

`if` 结构由 `if`, `elif` 和 `else` 关键字。

Python 中没有用括号来构造代码块，而是使用了**缩进的方式表示代码块**。
如果 `if` 条件成立时需要执行多条语句，只要多条语句保持相同的缩进即可。
缩进可以是任意数量的空格，但通常是 4 个空格。
如果要构造多个分支，可以使用 `if...elif...else...`。分支结构可以嵌套。

### 分段函数求值

$$
f(x)=\begin{cases}
3x - 5,\quad x > 1 \\
x,\quad -1 \leq x \leq 1 \\
5x + 3, \quad x < -1
\end{cases}
$$

```python
"""
分段函数求值

        3x - 5  (x > 1)
f(x) =  x + 2   (-1 <= x <= 1)
        5x + 3  (x < -1)

"""

x = float(input('x = '))
if x > 1:
  y = 3 * x -5
elif x >= -1:
  y = x + 2
else:
  y = 5 * x + 3
print('f(%.2f) = %.2f' % (x, y))
print(f'f({x:.2f}) = {y:.2f}')
```

试一试：

```shell
python day-01-15/day-03/if-demo.py
```

### 三角形

判断输入的边长能否构成三角形，如果能则计算出三角形的周长和面积。

海伦公式[^海伦公式]：$S=\sqrt{p(p - a)(p - b)(p - a)}$

```python
"""
判断输入的边长能否构成三角形，如果能则计算出三角形的周长和面积
"""

a = float(input('a = '))
b = float(input('b = '))
c = float(input('c = '))

if a + b > c and a + c > b and b + c > a:
  print('周长：%.2f' % (a + b + c))
  p = (a + b + c) / 2
  area = (p * (p - a) * (p - b) * (p - c)) ** 0.05
  print(f'面积：{area:.2f}')
else:
  print('不能构成三角形')
```

试一试：

```shell
python day-01-15/day-03/if-demo-triangle.py
```

[^海伦公式]: 海伦公式又译作希伦公式、海龙公式、希罗公式、海伦－秦九韶公式。它是利用三角形的三条边的边长直接求三角形面积的公式。表达式为：S=√p\(p-a\)\(p-b\)\(p-c\)，它的特点是形式漂亮，便于记忆。

```
引用：<https://baike.baidu.com/item/%E6%B5%B7%E4%BC%A6%E5%85%AC%E5%BC%8F/106956>
```

---

---
url: 'https://zhaobc.site/notes/backend/python/python-100-days/day-01-15/04.循环结构.md'
---
# 04.循环结构

Python 中循环有两种，`for-in` 和 `while`。

## `for-in` 循环

```python
"""
用for循环实现1~100求和
"""

sum=0
for x in range(101):
  sum += x
print(sum)
```

`range` 用法非常灵活，下面给出了一个例子：

* `range(101)` : 产生 0 到 100 范围的整数，需要注意的是取不到 101。
* `range(1, 101)` : 产生 1 到 100 范围的整数，相当于前面是闭区间，后面是开区间。
* `range(1, 101, 2)` : 产生 1 到 100 范围的奇数，步长是 2。
* `range(100, 0, -2)` : 产生 100 到 0 的偶数，步长是 -2。

知道了这一点，我们可以用下面的代码来实现 1~100 之间的偶数求和。

```python
"""
用for循环实现1~100之间的偶数求和
"""

sum=0
for x in range(2, 101, 2):
  sum += x
print(sum)
```

## `while` 循环

下面我们通过一个“猜数字”的小游戏来看看如何使用 while 循环。
猜数字游戏的规则是：计算机出一个 1 到 100 之间的随机数，玩家输入自己猜的数字，计算机给出对应的提示信息（大一点、小一点或猜对了），
如果玩家猜中了数字，计算机提示用户一共猜了多少次，游戏结束，否则游戏继续。

```python
"""
猜数字游戏
"""

import random

answer = random.randint(1, 100)
counter = 0

while True:
  counter += 1
  number = int(input('请输入：'))
  if number < answer:
    print('大一点')
  elif number > answer:
    print('小一点')
  else:
    print('恭喜你猜对了!')
    break
print('你一共猜了%d次' % counter)
if counter > 7:
  print('需要加油哦~')
```

试一试：

```shell
python day-01-15/day-04/while-demo.py
```

## 练习

下面的例子演示了如何通过嵌套的循环来输出一个九九乘法表。

```python
"""
输出乘法口诀表(九九表)
"""

for i in range(1, 10):
  for j in range(1, i + 1):
    print('%d * %d = %d' % (i, j, i * j), end='\t')
  print()
```

试一试：

::: playground#python 九九乘法表

@file main.py

```python
"""
输出乘法口诀表(九九表)
"""

for i in range(1, 10):
  for j in range(1, i + 1):
    print('%d * %d = %d' % (i, j, i * j), end='\t')
  print()
```

:::

---

---
url: 'https://zhaobc.site/notes/backend/python/tutorial/index.md'
---
# Python 教程

本笔记以 [Python 官方教程](https://docs.python.org/zh-cn/3/tutorial/index.html) 为学习教程，记录一些学习笔记。

部分代码在 [replit](https://replit.com/@zhaobin/python-tutorial) 上，不过由于它不能在分享可编辑，可运行的示例，所以不再使用。

---

---
url: 'https://zhaobc.site/notes/backend/python/tutorial/3.introduction.md'
---
# 3. 速览

## 3.1 Python 用作计算器

### 3.1.1 数字

除了 int 和 float，Python 还支持其他数字类型，例如 Decimal 或 Fraction。

### 3.1.2 字符串

用单引号（'……'）或双引号（"……"）标注的结果相同，可交替使用，例 `"doesn't"`，`'"Yes," they said.'`。
反斜杠 `\` 用于转义，例 `'doesn\'t'`。

字符串字面值可以包含多行。 一种实现方式是使用三重引号：`"""..."""` 或 `'''...'''`。 字符串中将自动包括行结束符，但也可以在换行的地方添加一个 `\` 来避免此情况（避免换行，就是加 `\` 后不换行）。 参见以下示例：

```python
print("""\
Usage: thingy [OPTIONS]
    -h                      Display this usage message
    -H                      Hostname to connect to
""")
```

输出如下（请注意开始的换行符没有被包括在内）：

```txt
Usage: thingy [OPTIONS]
    -h                      Display this usage message
    -H                      Hostname to connect to
```

字符串可以用 `+` 拼接，也可以用 `*` 重复，相邻的两个或多个 字符串字面值 （引号标注的字符）会自动合并。
拼接分隔开的长字符串时，这个功能特别实用。

```python
print(3 * 'un' + 'ium') # 'unununium'
print('Py' 'thon') # 'Python'
print('Put several strings within parentheses '
      'to have them joined together.')
```

字符串支持 索引 （下标访问），第一个字符的索引是 0。单字符没有专用的类型，就是长度为一的字符串。
索引还支持负数，用负数索引时，从右边开始计数，注意，-0 和 0 一样，因此，负数索引从 -1 开始。

```python
word = "python"
print(word[0])    # p
print(word[-1])   # n
```

除了索引，字符串还支持 切片。索引可以提取单个字符，切片 则提取子字符串，*前闭后开*。
切片索引的默认值很有用；省略开始索引时，默认值为 0，省略结束索引时，默认为到字符串的结尾。
负数代表从右边开始数。
输出结果包含切片开始，但不包含切片结束。因此，`s[:i] + s[i:]` 总是等于 `s`。
索引越界会报错，但是，切片会自动处理越界索引。

```python
print(word[0:2])    # py
print(word[2:5])    # tho
print(word[:2])     # py
print(word[4:])     # on
print(word[-2:])    # on
print(word[42])     # IndexError: string index out of range
print(word[4:42])   # on
print(word[42:])    # ''
```

Python 字符串不能修改，是 immutable 的。因此，为字符串中某个索引位置赋值会报错。

```python
word[0] = 'J'       # TypeError: 'str' object does not support item assignment
word[2:] = 'py'     # TypeError: 'str' object does not support item assignment
```

其他补充：

* `len()` 返回字符串长度

* `str.format()` 格式化字符串

  示例：`"The sum of 1 + 2 is {0}".format(1+2)`，详情。[str.format()](https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format)

* [printf 风格的字符串格式化](https://docs.python.org/zh-cn/3/library/stdtypes.html#old-string-formatting)

试一试：

::: playground#python 字符串

@file main.py

```python
print("""\
Usage: thingy [OPTIONS]
    -h                      Display this usage message
    -H                      Hostname to connect to
""")

print(3 * 'un' + 'ium') # 'unununium'
print('Py' 'thon') # 'Python'
print('Put several strings within parentheses '
      'to have them joined together.')

word = "python"
print(word[0])    # p
print(word[-1])   # n

print(word[0:2])    # py
print(word[2:5])    # tho
print(word[:2])     # py
print(word[4:])     # on
print(word[-2:])    # on
#print(word[42])     # IndexError: string index out of range
print(word[4:42])   # on
print(word[42:])    # ''
```

:::

### 3.1.3 列表

列表 ，是用方括号标注，逗号分隔的一组值。列表 可以包含不同类型的元素，但一般情况下，各个元素的类型相同。
和字符串（及其他内置 sequence 类型）一样，列表也支持索引和切片。
切片操作返回包含请求元素的新列表。
列表还支持合并操作。

```python
squares = [1, 4, 9, 16, 25]
print(squares[0])       # 1
print(squares[-1])      # 25
print(squares[-3:])     # [9, 16, 25] 返回新的列表
print(squares[:])       # [1, 4, 9, 16, 25] 返回列表的浅拷贝
print(squares + [36, 49, 64])   # [1, 4, 9, 16, 25, 36, 49, 64]
```

与 immutable 字符串不同, 列表是 mutable 类型，其内容可以改变。
`append()` 方法 可以在列表结尾添加新元素。
为切片赋值可以改变列表大小，甚至清空整个列表。
内置函数 `len()` 也支持列表。
还可以嵌套列表（创建包含其他列表的列表）。

```python
cubes = [1, 8, 27, 65, 125]  # something's wrong here
cubes[3] = 64
cubes.append(6 ** 3)
print(cubes)          # [1, 8, 27, 64, 125, 216]

letters = ['a', 'b', 'c', 'd', 'e', 'f']
letters[2:5] = ['C', 'D', 'E']
print(letters)        # ['a', 'b', 'C', 'D', 'E', 'f']
letters[2:5] = []     # 删除 2:5
print(letters)        # ['a', 'b', 'f']
```

试一试：

::: playground#python 列表

@file main.py

```python
cubes = [1, 8, 27, 65, 125]  # something's wrong here
cubes[3] = 64
cubes.append(6 ** 3)
print(cubes)          # [1, 8, 27, 64, 125, 216]

letters = ['a', 'b', 'c', 'd', 'e', 'f']
letters[2:5] = ['C', 'D', 'E']
print(letters)        # ['a', 'b', 'C', 'D', 'E', 'f']
letters[2:5] = []     # 删除 2:5
print(letters)        # ['a', 'b', 'f']
```

:::

## 3.2 走向编程的第一步

打印斐波那契数列：

```python
"""
Fibonacci series
"""

a, b = 0, 1
while a < 10:
  # print(a)
  print(a, sep = ', ', end = '\n')   # print 默认带换回，使用 end 改用自己指定的字符
  a, b = b, a + b
```

试一试：

::: playground#python 打印斐波那契数列

@file main.py

```python
"""
Fibonacci series
"""

a, b = 0, 1
while a < 10:
  # print(a)
  print(a, sep = ', ', end = '\n')   # print 默认带换回，使用 end 改用自己指定的字符
  a, b = b, a + b
```

:::

本例引入的新功能：

* 第一行中的 *多重赋值*：变量 `a` 和 `b` 同时获得新值 `0` 和 `1`，最后一行又用了一次多重赋值。
* `while` 循环，循环体缩进。

---

---
url: 'https://zhaobc.site/notes/backend/python/tutorial/4.controlflow.md'
---
# 4. 流程控制

## 4.1 if 语句

`if` 语句包含零个或多个 `elif` 子句及可选的 `else` 子句。

::: playground#python if 语句

@file main.py

```python
x = int(input('Please enter an integer: '))
if x < 0:
  x = 0
  print('Negative changed to zero')
elif x == 0:
  print('Zero')
elif x == 1:
  print('Single')
else:
  print('More')
```

:::

如果要把一个值与多个常量进行比较，或者检查特定类型或属性，`match` 语句更实用。

## 4.2 for 语句

Python 的 for 语句不迭代算术递增数值，或是给予用户定义迭代步骤和暂停条件的能力（如 C），而是迭代列表或字符串等任意序列，元素的迭代顺序与在序列中出现的顺序一致。

```python
words = ['cat', 'window', 'test']
for w in words:
  print(w, len(w))
```

遍历集合时修改集合的内容，会很容易生成错误的结果。因此不能直接进行循环，而是应遍历该集合的副本或创建新的集合：

```python
users = {'Hans': 'active', 'hello': 'inactive', '赵斌': 'active'}

for user, status in users.copy().items():
  if status == 'inactive':
    del users[user]

active_users = {}
for user, status in users.items():
  if status == 'active':
    active_users[user] = status

print('\nactive users:')
for user in active_users:
  print(user)
```

试一试:

::: playground#python for 语句

@file main.py

```python
words = ['cat', 'window', 'test']
for w in words:
  print(w, len(w))

users = {'Hans': 'active', 'hello': 'inactive', '赵斌': 'active'}

for user, status in users.copy().items():
  if status == 'inactive':
    del users[user]

active_users = {}
for user, status in users.items():
  if status == 'active':
    active_users[user] = status

print('\nactive users:')
for user in active_users:
  print(user)
```

:::

## 4.3 range 函数

内置函数 `range()` 常用于遍历数字序列。
range 可以不从 0 开始，还可以按指定幅度递增（递增幅度称为 '步进'，支持负数）

```python
for i in range(5):
  print(i)

sum(range(5))
# 0 + 1 + 2 + 3 + 4

list(range(5, 10))
# [5, 6, 7, 8, 9]

list(range(0, 10, 3))
# [0, 3, 6, 9]

list(range(-10, -100, -30))
# [-10, -40, -70]
```

`range()` 和 `len()` 组合在一起，可以按索引迭代序列：

```python
a = ['Mary', 'had', 'a', 'little', 'lamb']
for i in range(len(a)):
  print(i, a[i])
```

试一试:

::: playground#python range 函数

@file main.py

```python
for i in range(5):
  print(i)

print(sum(range(5)))
# 0 + 1 + 2 + 3 + 4

print(list(range(5, 10)))
# [5, 6, 7, 8, 9]

print(list(range(0, 10, 3)))
# [0, 3, 6, 9]

print(list(range(-10, -100, -30)))
# [-10, -40, -70]

a = ['Mary', 'had', 'a', 'little', 'lamb']
for i in range(len(a)):
  print(i, a[i])
```

:::

## 4.4 循环中的 break、continue 语句及 else 子句

break 语句和 C 中的类似，用于跳出最近的 for 或 while 循环。

循环语句支持 else 子句；for 循环中，可迭代对象中的元素全部循环完毕，或 while 循环的条件为假时，执行该子句；break 语句终止循环时，不执行该子句。

请看下面这个查找素数的循环示例：

```python
for n in range(2, 10):
  for x in range(2, n):
    if n % x == 0:
      print(n, 'equals', x, '*', n // x)
      break
  else:
    # loop fell through without finding a factor
    print(n, 'is a prime number')
```

（没错，这段代码就是这么写。仔细看：else 子句属于 for 循环，不属于 if 语句。）

与 `if` 语句相比，循环的 `else` 子句更像 `try` 的 `else` 子句： `try` 的 `else` 子句在未触发异常时执行，循环的 `else` 子句则在未运行 `break` 时执行。`try` 语句和异常详见 异常的处理。

试一试：

::: playground#python else

@file main.py

```python
for n in range(2, 10):
  for x in range(2, n):
    if n % x == 0:
      print(n, 'equals', x, '*', n // x)
      break
  else:
    # loop fell through without finding a factor
    print(n, 'is a prime number')
```

:::

## 4.5 pass

pass 语句不执行任何动作。语法上需要一个语句，但程序毋需执行任何动作时，可以使用该语句。

这常用于创建一个最小的类：

```python
class MyEmptyClass:
  pass
```

pass 还可用作函数或条件语句体的占位符，让你保持在更抽象的层次进行思考。pass 会被默默地忽略：

```python
def initlog(*args):
  pass  # Remember to implement this!
```

## 4.6 match 语句

`match` 语句接受一个表达式并把它的值与一个或多个 `case` 块给出的一系列模式进行比较。
这表面上像 C、Java 或 JavaScript（以及许多其他程序设计语言）中的 switch 语句，但其实它更像 Rust 或 Haskell 中的模式匹配。
**只有第一个匹配的模式会被执行**，并且它还可以提取值的组成部分（序列的元素或对象的属性）赋给变量。

最简单的形式是将一个主语值与一个或多个字面值进行比较：

```python
def http_error(status):
  match status:
    case 400:
      return "Bad request"
    case 404:
      return "Not found"
    case 418:
      return "I'm a teapot"
    case 401 | 403: # 你可以使用 | （“ or ”）在一个模式中组合几个字面值:
      return "Not allowed"
    case _:
      return "Something's wrong with the internet"
```

注意最后一个代码块：“变量名” `_` 被作为 *通配符* 并必定会匹配成功。如果没有 case 匹配成功，则不会执行任何分支。

试一试：

::: playground#python match 语句

@file main.py

```python
def http_error(status):
  match status:
    case 400:
      return "Bad request"
    case 404:
      return "Not found"
    case 418:
      return "I'm a teapot"
    case 401 | 403: # 你可以使用 | （“ or ”）在一个模式中组合几个字面值:
      return "Not allowed"
    case _:
      return "Something's wrong with the internet"

print(http_error(400))
print(http_error(401))
print(http_error(500))
```

:::

形如解包赋值的模式，可用于绑定变量：

```python
# point is an (x, y) tuple
match point:
  case (0, 0):
    print("Origin")
  case (0, y):
    print(f"Y={y}")
  case (x, 0):
    print(f"X={x}")
  case (x, y):
    print(f"X={x}, Y={y}")
  case _:
    raise ValueError("Not a point")
```

```python
from enum import Enum
class Color(Enum):
  RED = 'red'
  GREEN = 'green'
  BLUE = 'blue'

color = Color(input("Enter your choice of 'red', 'green' or 'blue': "))

match color:
  case COLOR.RED:
    print("I see red!")
  case COLOR.GREEN:
    print("Grass is green.")
  case COLOR.BLUE:
    print("I'm feeling the blues :(")
```

试一试：

## 4.7 定义函数

下列代码创建一个可以输出限定数值内的斐波那契数列函数：

```python
def fib(n): # write Fibonacci series up to n
  """Print a Fibonacci series up to n."""
  a, b = 0, 1
  while a < n:
    print(a, end = " ")
    a,b = b, a + b
  print()

# Now call the function we just defined:
fib(10)
```

*定义* 函数使用关键字 `def`，后跟函数名与括号内的形参列表。函数语句从下一行开始，并且必须缩进。

函数内的第一条语句是字符串时，该字符串就是文档字符串，也称为 docstring，详见 [文档字符串](https://docs.python.org/zh-cn/3/tutorial/controlflow.html#tut-docstrings)。

`fib` 不返回值，因此，其他语言不把它当作函数，而是当作过程。事实上，没有 return 语句的函数也返回值，只不过这个值比较是 `None` （是一个内置名称）。一般来说，解释器不会输出单独的返回值 None ，如需查看该值，可以使用 `print()`：

```python
print(fib(0))
# None
```

::: playground#python 定义函数

@file main.py

```python
def fib(n): # write Fibonacci series up to n
  """Print a Fibonacci series up to n."""
  a, b = 0, 1
  while a < n:
    print(a, end = " ")
    a,b = b, a + b
  print()

# Now call the function we just defined:
print(fib(10))

print(fib(0))
```

:::

## 4.8 函数详解

函数定义支持可变数量的参数。这里列出三种可以组合使用的形式。

### 4.8.1 默认参数

为参数指定默认值是非常有用的方式。调用函数时，可以使用比定义时更少的参数，例如：

```python
def ask_ok(prompt, retries=4, reminder="Please try again!"):
  while True:
    ok = input(prompt)
    if ok in ("y", "ye", "yes"):
      return True
    if ok in ("N", "no", "nop", "nope"):
      return False
    retries = retries - 1
    if retries < 0:
      raise ValueError("invalid user response")
    print(reminder)
```

该函数可以用以下方式调用：

* 只给出必选参数
  `ask_ok('Do you really want to quit?')`
* 给出一个可选参数
  `ask_ok('OK to overwrite the file?', 2)`
* 给出所有参数
  `ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')`

本例还使用了关键字 `in` ，用于确认序列中是否包含某个值。

::: warning
重要警告： 默认值只计算一次。默认值为列表、字典或类实例等可变对象时，会产生与该规则不同的结果。
:::

例如，下面的函数会累积后续调用时传递的参数：

```python
i = 5

def f(arg=i):
  print(arg)

i = 6
f()
# 输出： 5

def f(a, L=[]):
  L.append(a)
  return L

print(f(1))
print(f(2))
print(f(3))

# 输出结果：
# [1]
# [1, 2]
# [1, 2, 3]
```

不想在后续调用之间共享默认值时，应以如下方式编写函数：

```python
def f(a, L=None):
  if L is None:
    L = []
  L.append(a)
  return L
```

### 4.8.2 关键字参数

`kwarh=value` 形式的[关键字参数](https://docs.python.org/zh-cn/3/glossary.html#term-keyword-argument)也可以用于调用参数。函数示例如下：

```python
def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
  print("-- This parrot wouldn't", action, end = ' ')
  print("if you put", voltage, "volts through it.")
  print("-- Lovely plumage, the", type)
  print("-- It's", state, "!")
```

该函数接受一个必选参数（voltage）和三个可选参数（state, action 和 type）。该函数可用下列方式调用：

```python
parrot(1000)                                          # 1 positional argument （位置参数）
parrot(voltage=1000)                                  # 1 keyword argument （关键字参数）
parrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments （关键字参数）
parrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments （关键字参数）
parrot('a million', 'bereft of life', 'jump')         # 3 positional arguments （位置参数）
parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword （位置参数，关键字参数）
```

以下调用函数的方式都无效：

```python
parrot()                     # required argument missing
parrot(voltage=5.0, 'dead')  # non-keyword argument after a keyword argument
parrot(110, voltage=220)     # duplicate value for the same argument
parrot(actor='John Cleese')  # unknown keyword argument
```

* 函数调用时，关键字参数必须跟在位置参数后面。
* 所有传递的关键字参数都必须匹配一个函数接受的参数，关键字参数的顺序并不重要。

::: playground#python 关键字参数

@file main.py

```python
def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
  print("-- This parrot wouldn't", action, end = ' ')
  print("if you put", voltage, "volts through it.")
  print("-- Lovely plumage, the", type)
  print("-- It's", state, "!")

parrot(1000)                                          # 1 positional argument （位置参数）
parrot(voltage=1000)                                  # 1 keyword argument （关键字参数）
parrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments （关键字参数）
parrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments （关键字参数）
parrot('a million', 'bereft of life', 'jump')         # 3 positional arguments （位置参数）
parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword （位置参数，关键字参数）
```

:::

默认情况下，参数可以按位置或显式关键字传递给 Python 函数。为了让代码易读、高效，最好限制参数的传递方式，这样，开发者只需查看函数定义，即可确定参数项是仅按位置、按位置或关键字，还是仅按关键字传递。

函数定义如下：

```txt
def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
      -----------    ----------     ----------
        |             |                  |
        |        Positional or keyword   |
        |                                - Keyword only
         -- Positional only
```

```txt
def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
      -----------    ----------     ----------
        |             |                  |
        |        位置或关键字   |
        |                                - 仅限关键字
         -- 仅限位置
```

`/` 和 `*` 是可选的。这些符号表明形参如何把参数值传递给函数：位置、位置或关键字、关键字。关键字形参也叫作命名形参。

#### 4.8.3.1 位置或关键字参数

函数定义中未使用 `/` 和 `*` 时，参数可以按位置或关键字传递给函数。

#### 4.8.3.2 仅位置参数

此处再介绍一些细节，特定形参可以标记为 仅限位置。仅限位置 时，形参的顺序很重要，且这些形参不能用关键字传递。仅限位置形参应放在 `/` （正斜杠）前。`/` 用于在逻辑上分割仅限位置形参与其它形参。如果函数定义中没有 /，则表示没有仅限位置形参。

/ 后可以是 位置或关键字 或 仅限关键字 形参。

#### 4.8.3.3 仅限关键字参数

把形参标记为 仅限关键字，表明必须以关键字参数形式传递该形参，应在参数列表中第一个 仅限关键字 形参前添加 `*`。

### 4.8.4 任意实参列表

调用函数时，使用任意数量的实参是最少见的选项。这些实参包含在元组中（详见 元组和序列 ）。在可变数量的实参之前，可能有若干个普通参数：

```python
def write_multiple_items(file, separator, *args):
    file.write(separator.join(args))
```

variadic 参数用于采集传递给函数的所有剩余参数，因此，它们通常在形参列表的末尾。`*args` 形参后的任何形式参数只能是仅限关键字参数，即只能用作关键字参数，不能用作位置参数：

```python
def concat(*args, sep="/"):
    return sep.join(args)

concat("earth", "mars", "venus")
# 'earth/mars/venus'
concat("earth", "mars", "venus", sep=".")
# 'earth.mars.venus'
```

::: playground#python 任意实参列表

@file main.py

```python
def concat(*args, sep="/"):
    return sep.join(args)

print(concat("earth", "mars", "venus"))
# 'earth/mars/venus'
print(concat("earth", "mars", "venus", sep="."))
# 'earth.mars.venus'
```

:::

### 4.8.5 解包实参列表

函数调用要求独立的位置参数，但实参在列表或元组里时，要执行相反的操作。
例如，内置的 range() 函数要求独立的 start 和 stop 实参。
如果这些参数不是独立的，则要在调用函数时，用 `*` 操作符把实参从列表或元组解包出来：

```python
list(range(3, 6))            # 两个参数的正常调用
# [3, 4, 5]
args = [3, 6]
list(range(*args))            # 从一个数组解包出参数的调用
# [3, 4, 5]
```

同样，字典可以用 `**` 操作符传递关键字参数：

```python
def parrot(voltage, state='a stiff', action='voom'):
    print("-- This parrot wouldn't", action, end=' ')
    print("if you put", voltage, "volts through it.", end=' ')
    print("E's", state, "!")

d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
parrot(**d)
# This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !
```

## 4.9 Lambda 表达式

lambda 关键字用于 *创建小巧的匿名函数*。lambda a, b: a+b 函数返回两个参数的和。Lambda 函数可用于任何需要 *函数对象* 的地方。
在语法上，匿名函数只能是单个表达式。在语义上，它只是常规函数定义的语法糖。与嵌套函数定义一样，lambda 函数可以引用包含作用域中的变量：

```python
def make_incrementor(n):
  return lambda x: x + n

f = make_incrementor(42)
f(0)
# 42
f(1)
# 43
```

上例用 lambda 表达式返回函数。还可以把匿名函数用作传递的实参：

```python
pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
pairs.sort(key=lambda pair: pair[1])
pairs
# [(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]
```

## 4.10 文档字符串

以下是文档字符串内容和格式的约定。

* 第一行应为对象用途的简短摘要。
  这一行应以大写字母开头，以句点结尾。

* 文档字符串为多行时，第二行应为空白行，在视觉上将摘要与其余描述分开。
  后面的行可包含若干段落，描述对象的调用约定、副作用等。

* 文档字符串第一行 之后 的第一个非空行决定了整个文档字符串的缩进量。
  第一行通常与字符串开头的引号相邻，其缩进在字符串中并不明显，因此，不能用第一行的缩进。
  然后，删除字符串中所有行开头处与此缩进“等价”的空白符。
  不能有比此缩进更少的行，但如果出现了缩进更少的行，应删除这些行的所有前导空白符。

```python
def my_function():
    """Do nothing, but document it.

    No, really, it doesn't do anything.
    """
    pass

print(my_function.__doc__)
#Do nothing, but document it.
#
#    No, really, it doesn't do anything.
```

## 4.11 函数注解

函数注解 是可选的用户自定义函数类型的元数据完整信息。

标注 以字典的形式存放在函数的 `__annotations__` 属性中而对函数的其他部分没有影响。

下面的示例有一个必须的参数、一个可选的关键字参数以及返回值都带有相应的标注:

```python
def f(ham: str, eggs: str = 'eggs') -> str:
    print("Annotations:", f.__annotations__)
    print("Arguments:", ham, eggs)
    return ham + ' and ' + eggs

f('spam')
#Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>}
#Arguments: spam eggs
#'spam and eggs'
```

---

---
url: 'https://zhaobc.site/notes/backend/spring/index.md'
---
# Spring 笔记

Spring 相关的学习笔记

---

---
url: 'https://zhaobc.site/notes/frontend/index.md'
---
# 前端笔记

记录前端相关的学习笔记。

---

---
url: 'https://zhaobc.site/notes/frontend/js/index.md'
---
# JavaScript 笔记

---

---
url: 'https://zhaobc.site/notes/frontend/js/bosn/index.md'
---
# JavaScript 深入浅出

## 前言

原视频链接：[慕课网上 Bosn 老师的《JavaScript 深入浅出》](https://www.imooc.com/learn/277)

## 目录

* [第 1 章 数据类型](./chapter01.md)
* [第 2 章 表达式和运算符](./chapter02.md)
* [第 3 章 语句](./chapter03.md)
* [第 4 章 对象](./chapter04.md)
* [第 5 章 数组](./chapter05.md)
* 第 6 章 函数和作用域（函数、this）
* 第 7 章 函数和作用域（闭包、作用域）
* 第 8 章 OOP（上）
* 第 9 章 OOP（下）
* 第 10 章 正则与模式匹配

---

---
url: 'https://zhaobc.site/notes/frontend/js/bosn/chapter01.md'
---
# 第 1 章 数据类型

## 1-1 深入浅出课程介绍

略

## 1-2 六种数据类型

原始类型（基本类型）：

* `number`
* `string`
* `boolean`
* `null`
* `undefined`

除此之外，JavaScript 还有一种对象类型（复合类型）`object`。

`object` 包含以下类型：

* `Function`
* `Array`
* `Date`
* ...

## 1-3 隐式转换

关于`+`和`-`：
`+`隐式转为字符串，`-`隐式转换为数字。

```js
'37' - 7 // 30
'37' + 7 // 377
```

因此可以巧用`+`和`-`转换数据类型，比如使用`- 0`（减 0），转换为数字，使用`+ ''`（加空字符串）转换为字符串。

因此可以巧用`+`和`-`转换数据类型，比如使用`- 0`（减 0），转换为数字，使用`+ ''`（加空字符串）转换为字符串。

## 1-4 包装对象

[1-2 六种数据类型](#_1-2-六种数据类型) 中介绍的 5 种基本类型和一种对象类型，其中 5 中基本类型都有其对应的包装类型。

当把一个基本类型作为对象使用时，JavaScript 会尝试将基本类型转换为包装对象，想定于 new 了一个临时对象，对象的值为基本类型的值。

使用基本对象访问对象的方法后，这个临时对象会被销毁掉，所以再次访问对象的方法时就会变成 undefined。

如下图：
![图片1](./images/1-4.figure01.png)

::: warning
图片名中不能出现`#`，否则会会有问题：

1. Markdown 插入图片的方式，不能显示图片
2. HTML 插入图片的方式会报错。
   :::

## 1-5 类型检查

JavaScript 中检查类型的方法有很多，比如：

* `typeof`

* `instanceof`

* `Object.prototype.toString`

* `constructor`

  注意：使用 textlint 时，报`TypeError: entry.split is not a function`，所以上面加了引号。

* duck type

### `typeof`

`typeof`返回一个字符串，它非常适合函数对象和基本类型的判断。

比如：

|                 命令 | 结果        |
| -------------------: | :---------- |
|           typeof 100 | "number"    |
|          typeof true | "boolean"   |
| typeof function() {} | "function"  |
|      typeof Function | "function"  |
|     typeof undefined | "undefined" |
|          typeof null | "object"    |
|  typeof new Object() | "object"    |
|        typeof \[1, 2] | "object"    |
|           typeof NaN | "number"    |

### `instanceof`

`instanceof`常用于对象类型的判断，它是基于`原型链`的形式去判断的操作符。

它期望左操作树是一个对象，如果不是对象而是基本类型的话，直接返回 false。

|                    命令 | 结果  |
| ----------------------: | :---- |
|     1 instanceof Number | false |
| true instanceof Boolean | false |

它期望右操作树是一个函数对象，或函数构造器，如果不是的话就会跑出一个 TypeError 异常。

|                          命令 | 结果  |
| ----------------------------: | :---- |
|       \[1, 2] instanceof Array | true  |
| new Object() instanceof Array | false |

`instanceof`的大概原理就是它会判断左边的操作树的对象的原型链上，是否有右边的构造函数的 prototype 属性。

例子：

::: normal-demo instanceof 示例

```js
function Person() {}
function Student() {}
Student.prototype = new Person()
Student.prototype.constructor = Student
var bosn = new Student()
console.log(bosn instanceof Student)
var one = new Person()
console.log(one instanceof Person)

console.log(one instanceof Student)
console.log(bosn instanceof Person)
```

:::

打开开发者工具看结果，或者打开 Codepen 在线调试。

::: tip
Caution!
不同 window 或 iframe 间的对象类型检查不能使用 instanceof!
:::

### `Object.prototype.toString`

|                                          命令 | 结果                 |
| --------------------------------------------: | :------------------- |
|           Object.prototype.toString.apply(\[]) | "\[object Array]"     |
| Object.prototype.toString.apply(function(){}) | "\[object Function]"  |
|         Object.prototype.toString.apply(null) | "\[object Null]"      |
|    Object.prototype.toString.apply(undefined) | "\[object Undefined]" |

::: tip
IE6/7/8 Object.prototype.toString.apply(null)返回"\[object Object]"
:::

### 类型检查小结

* `typeof`
  适合基本类型及 function 检测，遇到 null 失效。
* `Object.prototype.toString`
  通过 Object.prototype.toString 拿到，适合内置对象和基本类型，遇到 null 和 undefined 失效（IE6/7/8 等返回\[object Object]）。
* `instanceof`
  适合自定义对象，也可以用来检测原生对象，在不同 iframe 和 window 间检测时失效。

---

---
url: 'https://zhaobc.site/notes/frontend/js/bosn/chapter02.md'
---
# 第 2 章 表达式和运算符

## 2-1 表达式

### 原始表达式

* 常量、直接量
* 关键字
* 变量

原始表达式和原始表达式可以复合成复合表达式，比如`10 * 20`就是两个原始表达式通过运算符构成了复合表达式。

### 数组、对象的初始化表达式

比如：

|       表达式 | 等价表达式                                   |
| -----------: | :------------------------------------------- |
|       \[1, 2] | new Array(1, 2)                              |
|   \[1, , , 4] | \[1, undefined, undefined, 4]                 |
| {x: 1, y: 2} | var o = new Object();o.x = 1; o.y = 2; |

### 函数表达式

把函数赋给一个变量，或者，把函数用括号阔起来直接调用,这样的就是函数表达式。

比如：

```js
var f = function () {}

;(function () {
  console.log('Hello World!')
})()
```

### 属性访问表达式

如下：

```js
var o = { x: 1 }
o.x
o['x']
```

### 调用表达式

比如：`func();`。

### 对象创建表达式

比如：

```js
new Func(1, 2)
new Object() // 无参数时，括号可以省略。
```

## 2-2 运算符

### 常见的运算符

* 一元运算符

  比如：`+num`，`+`可以将字符串转换成数字，`-`可以将字符串转换成数字；也可以正数变负数，负数变正数。

* 二元运算符

  比如：`a + b`

* 三元运算符

  比如：`c ? a : b`，它会将`c`强制转换为布尔型去比较。

除此之外，还有其他运算符：

![运算符](./images/2-2.figure01.png)

### 逗号运算符`,`

`var val = (1, 2, 3); // val = 3`

逗号运算符是从左往右依次计算表达式的值，最后取最右边的值。

### `delete`运算符

```js
var obj = { x: 1 }
obj.x // 1
delete obj.x
obj.x // undefined
```

后来新增了一个`Object.defineProperty`，可以给对象新增属性，或者修改已经存在的属性，并返回改对象。但不是说有的属性都能`delete`，只有定义的时候，`configurable: true`的才可以`delete`。

例：

```js
var obj = {}
Object.defineProperty(obj, 'x', {
  configurable: false,
  value: 1,
})
delete obj.x // false
obj.x // 1
```

### `in`运算符

使用`in`运算符来判断一个对象里有没有特定的`key`。

```js
window.x = 1
'x' in window // true
```

### instanceof, typeof 运算符

`instanceof`判断对象的类型，基于原型链判断。

`typeof`返回一个字符串，一般用来判断原始类型或者函数对象。

```js
{} instanceof Object; // true
typeof 100 === 'number'; // true
```

### `new`运算符

可以通过`new`来创建一个构造器的实例。

```js
function Foo() {}
Foo.prototype.x = 1
var obj = new Foo()
obj.x // 1
obj.hasOwnProperty('x') // false
obj.__proto__.hasOwnProperty('x') // true
```

可以通过`hasOwnProperty`来判断一个属性到底属于这个对象上的，还是这个对象原型链上的。

可以通过`__proto__`拿到这个对象的原型。

### `this`运算符

`this`比较复杂，后面会详细再说。

```js
this // window（浏览器）
var obj = {
  func: function () {
    return this
  },
}
obj.func() // obj
```

注：上面的`obj.func`，在 chrome 78.0.3904.108 中，返回`obj.func`对象。

注：可以使用`apply`改变`this`指向。

### `void`运算符

无论`void`后面是多少，都会返回`undefined`。

```js
void 0 // undefined
void 0 // undefined
```

---

---
url: 'https://zhaobc.site/notes/frontend/js/bosn/chapter03.md'
---
# 第 3 章 语句

## 3-1 block 语句、var 语句

### 块 block

块语句常用于组合 0~多个语句。块语句用一对花括号定义。

语句：

```txt
{
  语句1;
  语句2;
  ...
  语句N;
}
```

请注意：没有块级作用域。

### 定义 var

::: tip
使用一个`var`定义多个变量时，后面的变量会被隐式的创建为全局变量。
:::

比如：

```js
function foo() {
  var a = (b = 1)
}
foo()

console.log(typeof a) // undifined
console.log(typeof b) // number
```

所以，如果一行里面定义多个变量时，应用逗号分割。

## 3-2 try-catch

```js
try {
  throw 'test'
} catch (ex) {
  console.log(ex) // test
} finally {
  console.log('finally')
}
```

try 后面跟着 catch 或者 finally.

```js
try {
  try {
    throw new Error('oops')
  } finally {
    console.log('finally')
  }
} catch (ex) {
  console.error('outer', ex.message)
}
```

结果为：

```md
finally
outer oops
```

## 3-3 函数、swith、循环

### function

函数声明：

```js
function fd() {
  // do sth.
  return true
}
```

函数表达式：

```js
var fe = function () {
  // do sth.
}
```

两者比较重要的一个区别：函数声明会被预先处理，也叫函数前置，所以在函数声明的前面调用也是可以的，但是函数表达式却不可以。

也可通过`new Function`来定义，具体区别稍后讨论。

### for...in

```js
var p
var obj = { x: 1, y: 2 }
for (p in obj) {
  // do sth.
}
```

::: tip

1. 顺序不确定
2. enumerable 为 false 时不会出现
3. for in 对象属性时受原型链影响

:::

### switch

```js
var val = 2

switch (val) {
  case 1:
  case 2:
  case 3:
    console.log(123)
    break
  case 4:
  case 5:
    console.log(45)
    break
  default:
    console.log(0)
}

// 123
```

### 循环

```js
while (isTrue) {
  // do sth.
}

do {
  // do sth.
} while (isTrue)

var i
for (i = 0; i < n; i++) {
  // do sth.
}
```

### with

with 可以修改作用域。

```js
with ({ x: 1 }) {
  console.log(x)
}

with (document.forms[0]) {
  console.log(name.value)
}
```

JavaScript 中，已经不建议使用 with.

* 让 JS 引擎优化困难
* 可读性差
* 可被变量定义代替
* 严格模式下被禁用

## 3-4 严格模式

严格模式是一种特殊的执行模式，它修复了部分语言上的不足，提供更强的错误检查，并增强安全性。

如何使用：

```js
// 限制某个方法，在方法的第一句
function func() {
  'use strict' // 好处是，如果旧的浏览器不支持严格模式，这句话会被作为一个普通的字符串
}

// 也可以在.js文件的开头加
;('use strict')
function func() {}
```

坑：'use strict'不一定非要在第一句，如果前面是'a','b'也是可以的，但是`var a; var b;`这种是不行的。

### 不允许使用 with，SyntaxError

### 不允许未声明的变量被赋值

```js
!(function () {
  'use strict'
  x = 1
  console.log(window.x)
})()

// ReferenceError
```

如果不加`'use strict'`，`x` 会是一个全局变量。

### arguments 变为参数的静态副本

```js
!(function (a) {
  arguments[0] = 100
  console.log(a)
})(1)

// 参数为1时，由于内部修改了，所以结果为100
// 但是，参数不传时，a为undefined，单机原来的参数不会被改，还是undefined
```

如果加上`'use strict'`的话，arguments 只是参数的副本，所以不会影响原来的参数，所以结果为 1.

如果参数是一个`object`的话，由于 js 是 call by sharing，所以，修改了对象的属性的值，会保持下来。

### delete 参数、函数名报错

```js
!(function (a) {
  console.log(delete a)
})(1)

// false

!(function (a) {
  'use strict'
  delete a
})(a)

// SyntaxError
```

### delete 不可配置的报错

```js
!(function (a) {
  var obj = {}
  Object.defineProperty(obj, 'a', { configurable: false })
  console.log(delete obj.a)
})(1)

// false

!(function (a) {
  'use strict'
  var obj = {}
  Object.defineProperty(obj, 'a', { configurable: false })
  console.log(delete obj.a)
})(1)

// TypeError
```

### 对象字面量重复属性名报错

```js
!(function () {
  var obj = { x: 1, x: 2 }
  console.log(obj.x)
})()

// 2

!(function () {
  'use strict'
  var obj = { x: 1, x: 2 }
  console.log(obj.x)
})()

// SyntaxError
```

### 禁止八进制字面量

```js
!(function () {
  console.log(0123)
})()

// 83

!(function () {
  'use strict'
  console.log(0123)
})()

// SyntaxError
```

### eval, arguments 变为关键字，不能作为变量、函数名

```js
!(function () {
  function eval() {}
  console.log(eval)
})()

// function eval() {}

!(function () {
  'use strict'
  function eval() {}
  console.log(eval)
})()

// SyntaxError
```

### eval 独立作用域

```js
!(function () {
  eval('var evalVal = 2;')
  console.log(typeof evalVal)
})()

// number

!(function () {
  'use strict'
  eval('var evalVal = 2;')
  console.log(typeof evalVal)
})()

// undefined
```

### 其他

!['use strict'](./images/3-1.use-strict.png)

严格模式是一种特殊的运行模式，它修复了部分语言上的不足，提供更强的错误检查，并增强安全性。

---

---
url: 'https://zhaobc.site/notes/frontend/js/bosn/chapter04.md'
---
# 第 4 章 对象概述

## 4 - 1 对象概述

### 概述

对象中包含一系列属性，这些属性是**无序**的。
每个属性都有一个**字符串 key**和对应的 value。

```js
var obj = {}
obj[1] = 1
obj['1'] = 2
obj // Object {1: 2}
// 上面可以看错，不管是数字型的1作为属性，还是字符串型的'1'作为属性，他们指向同一个属性。

obj[{}] = false
obj[{ x: 1 }] = true
obj // Object {1:2, [object Object]: true}
// 同样，这里不管是空对象，还是属性x为1的对象作为key，都是把它们toString()之后作为key，他们最终指向同一个属性。
```

### 对象结构

对象的每个属性都有一些便签，比如：

* writable
* enumerable
* configurable
* value
* get/set
* `__proto__`
* 等等

图示：

![对象构造](./images/4-1.structure.png)

## 4 - 2 创建对象、原型链

### 对象创建-字面量

`var obj1 = {x: 1, y: 2};`

### 对象创建-new/原型链

使用 new 构造对象的好处，对象的原型会指向构造器的 prototype 属性。

当访问一个对象的属性时，先看该对象有没有这个属性，如果有就使用该对象的该属性值，如果没有，则向上查找该对象的原型链上有没有这个属性。
当查找到最后的 prototype 为 null 时还没有查找到，就返回 undefined.

注意`in`和`hasOwnProperty`的区别。

原型链示意图：

![原型链示意图](./images/4-2.prototype-01.png)

但是，当给对象的属性赋值的时候，不会通过原型链向上查找。
也就是说，当给对象的属性赋值时，会看这个对象上有没有这个属性，如果有，直接修改属性的值；
如果没有，直接在这个对象上新加这个属性，而不会修改对象原型链上的值。

示意图：

![示意图](./images/4-2.prototype-02.png)

如果给一个对象的属性赋值为 undefined 的话，这个属性还是存在的，只不过值为 undefined。
所以，如果访问一个对象的属性时返回 undefined，不一定是对象没有这个属性，可能是有这个属性，只不过值为 undefined。
此时，可以通过`hasOwnProperty`和`in`来区分。

如果所示：

![属性赋值undefined](./images/4-2.prototype-03.png)

那么，如果要删掉对象的属性的话，使用`delete obj.z`去删除，删除后就可以通过`obj.z`访问到原型链上的值了。
但是，如果继续`delete obj.z`的话，是不起作用的。
也就是说，delete 只会删掉对象上的属性，而原型链上的属性不会受影响。

这样的话，就通过原型链实现了继承，对象可以访问原型链上的属性，但是有不会修改原型链上的属性。

### 对象创建-`Object.create`

除了用原型之外，还可以通过`Object.create`这个内置函数来创建对象。
这个方法的作用是，创建一个对象，并且让这个对象的原型执行这个方法的参数。

如果所示：

![Object.create](./images/4-2.prototype-04.png)

使用 obj.x 可以访问，但是这个 x 是 obj 的原型链上的，所以，hasOwnProperty 返回 false。

并不是所有对象的原型链末端都是 Object.prototype，也就是说不是说有的对象都有 toString 方法。

比如上图所示，使用`Object.create(null)`创建的对象，它的原型直接就是 null 了，所以这个对象就不会 包含任何方法。

## 4 - 3 属性操作

### 属性读写

使用`obj.x`或`obj['y']`形式。

使用`for...in`遍历属性时，会把原型链上的东西遍历出来，并且他的顺序时不确定的。

```js
var p
for (p in obj) {
  console.log(obj[p])
}
```

### 属性读写-异常

使用`obj.x = y`时，如果 x 属性存在就赋为 y，如果不存在就新建 x 属性，并赋值。

### 属性删除

使用`delete obj.x`或`delete obj[x]`形式删除，删除之后 obj.x 就变为 undefined。

如果去删除不存在的属性，js 不去做任何事情，但是仍然返回 true，所以，返回 true 并不代表它删除成功了，而是说这个对象上不存在这个属性了。

但是，有些属性是不允许删除的，这时会返回 false，比如：

```js
delete Object.prototype // false
```

每个属性都有自己的一些权限配置，我们可以通过下面的方式获取：

```js
var descriptor = Object.getOwnPropertyDescriptor(Object, 'prototype')
descriptor.configurable // false
```

除此之外，使用 var 定义的全局变量或局部变量，仍然不能被删除，虽然它不是对象的属性。比如：

```js
var globalVal = 1
delete globalVal // false;
;(function () {
  var localVal = 1
  return delete localVal
})() // false

// 同理，函数也一样
function fd() {}
delete fd // false
;(function () {
  function fd() {}
  return delete fd
})() // false

// 注意，不使用var定义的这种可以删除。
ohNo = 1
window.ohNo // 1
delete ohNo // true

// 还有中情况，eval里定义的变量是可以删除的。
eval('var a = 1;')
delete a // true
```

### 属性检测

可以使用 in 操作符来检测，它能访问原型链上的属性，可以用 hasOwnProperty 来检测是否是原型链上的属性。

但是，使用 in 遍历时，不是每个属性都会输出，可以使用`obj.propertyIsEnumerable('x')`的形式来判断属性是否可以被枚举。

我们可以使用 defineProperty 来自定义属性，并且可以设为不可枚举。

```js
Object.defineProperty(cat, 'price', { enumerable: false, value: 1000 })
cat.propertyIsEnumerable('price') // false
cat.hasOwnProperty('price') // true
```

我们使用对象字面量或者`new`创建的对象，或者赋值创建的属性，它的属性都是可读可写，也是可以枚举，也可以 delete 掉。

而使用 defineProperty 创建的属性，如果不指定的话，它的标签都是 false 的，比如上面的 enumerable 不写也可以，默认 false。

补充，`if (a != undefined)`，等价于`if (a !== undefined || a !== null)`，不使用严格等于时，undefined 跟 null 当成一个东西。

### 属性枚举

可以使用 propertyIsEnumerable 或者 hasOwnProperty 来枚举。
注意，使用`var obj = Object.create(xxx)`创建出来的对象，它的原型指向后面的参数，比如这个 obj 的原型指向 xxx。

## 4-4 get/set 方法

### getter/setter 使用

Getter/Setter 的使用，是使用 get/set 关键字，加上字段名，紧接着跟着方法体。

Getter/Setter 跟其他属性之间，依然使用逗号隔开。

```js
var man = {
  name: 'Bosn',
  weibo: '@Boson',
  get age() {
    return new Date().getFullYear() - 1988
  },
  set age(val) {
    console.log("Age can't be set to " + val)
  },
}

console.log(man.age) // 27
man.age = 100 // Age can't be set to 100
console.log(man.age) // 27
```

一个稍微复杂的例子：

```js
var man = {
  name: 'Bosn',
  weibo: '@Boson',
  $age: null, // 这里使用$，是为了不想把这个变量暴露给外面。注：实际man.$age还是可以访问的
  get age() {
    if (this.$age == undefined) {
      // 这里没有使用严格等于，所以，这里实现了null和undefined判断
      return new Date().getFullYear() - 1988
    } else {
      return this.$age
    }
  },
  set age(val) {
    val = +val // 这里使用一元操作符+，可以将字符串转为数值。注：+不会将负值转为正值，+(-10)为-10
    if (!isNaN(val) && val > 0 && val < 150) {
      this.$age = +val
    } else {
      throw new Error('Incorrect val = ' + val)
    }
  },
}

console.log(man.age) // 27
man.age = 100
console.log(man.age) // 100
man.age = 'abc' // error: Incorrect val = NaN 注：这里是NaN，而不是'abc'，因为在val = +val中就出错了。+'abc'为NaN
// 如果去掉val = +val，执行man.age = 'abc'时，返回：Incorrect val = abc
man.age = -10 // error: Incorrect val = -10
```

### get/set 与原型链

如图所示：

![get/set与原型链](./images/4-4-get-set-prototype.png)

`obj.z; // 1`

右上部分，为 foo.prototype 定义了一个 z 的 get 方法，使用 obj.z，由于 obj 中没有 z，所以向上查找原型链，得到原型上的 get 方法，所以返回 1。

```js
obj.z = 10
obj.z // still 1
```

给 z 赋值时，由于 obj 上没有 z，按之前的讲解，应该会在 obj 上创建一个 z 属性，但是这里是失败了，因为仍然返回 1。

原因是，当 obj 上没有这个属性时，并且 obj 的原型链上有对应的 get/set 方法时，当对属性赋值时，它会走原型链上对应的 get/set 方法，而不会做对当前对象创建新属性的方式这样的处理。

那么，如果实现对 obj 上这样的属性进行修改呢。我们可以通过`Object.DefineProperty`来添加新属性。

如右下所示，使用`configurable: true`来指定属性可以被修改，这里没有指定 writebale 和 enumerable，所以默认是 false。

## 4 - 5 属性标签

### 查看属性标签

查看一个对象上的属性有哪些属性标签使用`Object.getOwnPropertyDescriptor(obj, prop)`，如下所示：

```js
Object.getOwnPropertyDescriptor({ pro: true }, 'pro')
// Object {value: true, writable: true, enumerable: true, configurable: true}
// value: 属性的值
// writable: 属性是否可修改，默认为true
// enumerable: 属性是否可以被遍历，可被枚举(for..in或者Object.keys('xx'))，默认为true
// configurable: 是表示这些属性标签是否可以再被修改，另外，也表示是否可以通过delete去删除这个属性，默认为true

Object.getOwnPropertyDescriptor({ pro: true }, 'a') // undefined
// 如果去获取一个不存在的属性的属性标签，将返回undefined

// 定义属性使用Object.defineProperty
// 第一个参数为对象，
// 第二个参数为属性名
// 第三个参数为属性标签对象
var person = {}
Object.defineProperty(person, 'name', {
  configurable: false,
  writable: false,
  enumerable: true,
  value: 'Bosn Ma',
})

// 运行结果
person.name // Bosn Ma
person.name = 1
person.name // still Bosn Ma
// 上面的name没有赋值成功，因为writable为false
delete person.name // false
// delete也不成功，因为configurable为false
```

一次性定义多个属性时，使用`Object.defineProperties(obj, properties)`，注意这里是复数形式。

第一个参数为对象，第二个参数是一个属性对象，这个对象的 key 是对象的属性，值为属性描述。

```js
Object.defineProperties(person, {
  title: { value: 'fe', enumerable: true },
  corp: { value: 'BABA', enumerable: true },
  salary: { value: 50000, enumerable: true, writable: true },
})

Object.getOwnPropertyDescriptor(person, 'salary')
// Object {value: 50000, writable: true, enumerable: true, configurable: false}
// 使用defineProperty定义时，没有明确知道的标签，默认为false

Object.getOwnPropertyDescriptor(person, 'corp')
// Object {value: 'BABA', writable: false, enumerable: true, configurable: false}
```

属性的标签是可以重复设置的，我们可以再次使用 defineProperty 去修改对应属性的标签。

不同的标签是做不同的事情的，如下所示：
![属性标签](./images/4-5-properties.png)

::: tip
如果 configurable 为 true，即使其他标签为 false 也是可以被修改的，因为可以使用 defineProperty 再次定义为 true。
:::

## 4 - 6 对象标签，对象序列化

### 对象标签

* \[\[proto]]
* \[\[class]]
* \[\[extensible]]

### 原型标签**proto**

![原型链](./images/4-6-proto.png)

### class 标签

没有直接的方式获取 class 标签，可以通过间接的方式`Object.prototype.toString`获取。

```js
var toString = Object.prototype.toString
function getType(o) {
  return toString.call(o).slice(8, -1) // 从第9位截取，-1代表从后面数1位，即不包含最后一位。
}

toString(null) // [object Null]
getType(null) // Null
getType(undefined) // Undefined
getType(1) // Number
getType(new Number(1)) // Number
typeof new Number(1) // object
getType(true) // Boolean
getType(new Boolean(true)) // Boolean
```

### extensible 标签

---

---
url: 'https://zhaobc.site/notes/frontend/js/bosn/chapter05.md'
---
# 第 5 章 数组

---

---
url: 'https://zhaobc.site/notes/frontend/js/code-snippets/group-by.md'
---
# Javascript Group By

## Object 数组分组

下面的代码是用来按数组对象的指定属性来排序。

### 代码

```ts
export const groupBy = (arr: any[], key: string): any[] | null => {
  if (arr) {
    const grouped = arr.reduce((group: any, obj: any) => {
      const data = obj[key]
      group[data] = group[data] ?? []
      group[data].push(obj)
      return group
    }, {})

    return grouped
  }

  return null
}
```

### 示例

::: playground#ts 对象数组分组

@file index.ts

```ts
const groupBy = (arr: any[], key: string): any[] | null => {
  if (arr) {
    const grouped = arr.reduce((group: any, obj: any) => {
      const data = obj[key]
      group[data] = group[data] ?? []
      group[data].push(obj)
      return group
    }, {})

    return grouped
  }

  return null
}

const arr = [
  {
    name: 'zhaobc',
    commit: 'test1',
  },
  {
    name: 'zhaobc2',
    commit: 'test1',
  },
  {
    name: 'zhaobc',
    commit: 'test2',
  },
]

console.log(arr)
console.log(groupBy(arr, 'name'))
```

:::

---

---
url: 'https://zhaobc.site/notes/frontend/js/code-snippets/reduce.md'
---
# reduce 使用

## 使用 reduce 切分字符串然后重新拼接

业务上有一个需求，后台传过来一个字符串，里面有括号 `（` `）` 和顿号 `、`，但是在前台展示时，要切分之后给每段文字加链接。
另外，字符串不确认内容，最多包含包含 4 段文字。

示例：

文字 1、（文字 2、文字 3）、文字 4

分隔完上面的文字后，就可以对 `（`, `）`, `、`以外的文字加链接了。

### 代码

```js
function reduceText(val) {
  if (val === null || val.length === 0) {
    return []
  }

  const arr = val.split('、').reduce((pre, cur) => {
    if (cur.includes('（') && cur.includes('）')) {
      // 同时包含左右括号
      let tmp = cur.split('（')
      pre.push(tmp[0])
      pre.push('（')
      tmp = tmp[1].split('）')
      pre.push(tmp[0])
      pre.push('）')
      pre.push(tmp[1])
    } else if (cur.includes('（')) {
      const tmp = cur.split('（')
      pre.push(tmp[0])
      pre.push('（')
      pre.push(tmp[1])
    } else if (cur.includes('）')) {
      const tmp = cur.split('）')
      pre.push(tmp[0])
      pre.push('）')
      pre.push(tmp[1])
    } else {
      pre.push(cur)
    }

    // 按原来的顺序，把顿号也加上
    pre.push('、')

    return pre
  }, [])

  // 删除最后一个顿号
  arr.splice(arr.length - 1, 1)

  // 删除空白元素
  return arr.filter(item => item.length !== 0)
}
```

### 示例

::: normal-demo 使用 reduce 切分字符串然后重新拼接

```js
function reduceText(val) {
  if (val === null || val.length === 0) {
    return []
  }

  const arr = val.split('、').reduce((pre, cur) => {
    if (cur.includes('（') && cur.includes('）')) {
      // 同时包含左右括号
      let tmp = cur.split('（')
      pre.push(tmp[0])
      pre.push('（')
      tmp = tmp[1].split('）')
      pre.push(tmp[0])
      pre.push('）')
      pre.push(tmp[1])
    } else if (cur.includes('（')) {
      const tmp = cur.split('（')
      pre.push(tmp[0])
      pre.push('（')
      pre.push(tmp[1])
    } else if (cur.includes('）')) {
      const tmp = cur.split('）')
      pre.push(tmp[0])
      pre.push('）')
      pre.push(tmp[1])
    } else {
      pre.push(cur)
    }

    // 按原来的顺序，把顿号也加上
    pre.push('、')

    return pre
  }, [])

  // 删除最后一个顿号
  arr.splice(arr.length - 1, 1)

  // 删除空白元素
  return arr.filter(item => item.length !== 0)
}

console.log(reduceText('文字1')) // ["文字1"]
console.log(reduceText('文字1、文字2')) // ["文字1","、","文字2"]
console.log(reduceText('文字1、（文字2）')) // ["文字1","、","（","文字2","）"]
console.log(reduceText('文字1、（文字2、文字3）')) // ["文字1","、","（","文字2","、","文字3","）"]
console.log(reduceText('文字1、（文字2、文字3）、文字4')) // ["文字1","、","（","文字2","、","文字3","）","、","文字4"]
```

:::

---

---
url: 'https://zhaobc.site/notes/frontend/ts/index.md'
---
# TypeScript 笔记

TypeScript 学习笔记

---

---
url: 'https://zhaobc.site/notes/frontend/ts/handbook/index.md'
---
# Handbook

[The TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)

[Source Code](https://github.com/microsoft/TypeScript-Website/tree/v2/packages/documentation/copy/en/handbook-v2)

---

---
url: 'https://zhaobc.site/notes/frontend/ts/handbook/more_on_function.md'
---
# More on Functions

## Function Type Expressions

The simplest way to describe a function is with a *function type expression*.
These types are syntactically similar to arrow functions:

```ts twoslash
function greeter(fn: (a: string) => void) {
  fn('Hello World')
}

function printToConsole(s: string) {
  console.log(s)
}

greeter(printToConsole)
```

The syntax `(a: string) => void` means "a function with one parameter, named `a`, of type `string`, that doesn't have a return value".
Just like with function declarations, if a parameter type isn't specified, it's implicitly `any`.

> Note that the parameter name is **required**. The function type `(string) => void` means "a function with a parameter named `string` of type `any`"!

Of course, we can use a type alias to name a function type:

```ts twoslash
type GreetFunction = (a: string) => void

function greeter(fn: GreetFunction) {
  // ...
}
```

## Call Signatures

In JavaScript, functions can have properties in addition to being callable.
However, the function type expression syntax doesn't allow for declaring properties.
If we want to describe something callable with properties, we can write a *call signature* in an object type:

```ts twoslash
type DescribableFunction = {
  description: string
  (someArg: number): boolean
}

function doSomething(fn: DescribableFunction) {
  console.log(fn.description + ' returned ', fn(6))
}

function myFunc(someArg: number) {
  return someArg > 3
}
myFunc.description = 'default description: is greater than 3'

doSomething(myFunc)
```

Note that the syntax is slightly different compared to a function type expression - use `:` between the parameter list and the return type rather than `=>`.

## Construct Signatures

JavaScript functions can also be invoked with the `new` operator.
TypeScript refers to these as *constructors* because they usually create a new object.
You can write a *construct signature* by adding the `new` keyword in front of a call signature:

```ts twoslash
type SomeObject = any
// ---cut---
type SomeConstructor = {
  new (s: string): SomeObject
}

function fn(ctor: SomeConstructor) {
  return new ctor('hello')
}
```

Some objects, like JavaScript's `Date` object, can be called with or without `new`.
You can combine call and construct signatures in the same type arbitrarily:

```ts twoslash
interface CallConstructor {
  (n?: number): string
  new (s: string): Date
}
```

## Generic Functions

It's common to write a function where the types of the input relate to the type of the output, or where the types of two inputs are related in some way.

In TypeScript, *generics* are used when we want to describe a correspondence between two values.
We do this by declaring a *type parameter* in the function signature:

```ts twoslash
function firstElement<Type>(arr: Type[]): Type | undefined {
  return arr[0]
}
```

By adding a type parameter `Type` to this function and using it in two places, we've created a link between the input of the function (the array) and the output (the return value).
Now when we call it, a more specific type comes out:

```ts twoslash
declare function firstElement<Type>(arr: Type[]): Type | undefined
// ---cut---
// s is of type 'string'
const s = firstElement(['a', 'b', 'c'])
// n is of type 'number'
const n = firstElement([1, 2, 3])
// u is of type undefined
const u = firstElement([])
```

### Inference

Note that we didn't have to specify `Type` in this sample.
The type was *inferred* - chosen automatically - by TypeScript.

```ts twoslash
// prettier-ignore
function map<Input, Output>(arr: Input[], func: (arr: Input) => Output): Output[] {
  return arr.map(func)
}

// Parameter 'n' is of type 'string'
// 'parsed' is of type 'number[]'
const parsed = map(['1', '2', '3'], n => parseInt(n))
```

Note that in this example, TypeScript could infer both the type of the `Input` type parameter (from the given `string` array), as well as the `Output` type parameter based on the return value of the function expression (`number`).

### Constraints

We've written some generic functions that can work on *any* kind of value.
Sometimes we want to relate two values, but can only operate on a certain subset of values.
In this case, we can use a *constraint* to limit the kinds of types that a type parameter can accept.

Let's write a function that returns the longer of two values.
To do this, we need a `length` property that's a number.
We *constrain* the type parameter to that type by writing an `extends` clause:

```ts twoslash
// @errors: 2345 2322
function longest<Type extends { length: number }>(a: Type, b: Type) {
  if (a.length >= b.length) {
    return a
  } else {
    return b
  }
}

// longerArray is of type 'number[]'
const longerArray = longest([1, 2], [1, 2, 3])
// longerString is of type 'alice' | 'bob'
const longerString = longest('alice', 'bob')
// Error! Numbers don't have a 'length' property
const notOK = longest(10, 100)
```

Because we constrained `Type` to `{ length: number }`, we were allowed to access the `.length` property of the `a` and `b` parameters.

### Working with Constrained Values

Here's a common error when working with generic constraints:

```ts twoslash
// @errors: 2322
function minimumLength<Type extends { length: number }>(
  obj: Type,
  minimum: number
): Type {
  if (obj.length >= minimum) {
    return obj
  } else {
    return { length: minimum }
  }
}
```

It might look like this function is OK - `Type` is constrained to `{ length: number }`, and the function either returns `Type` or a value matching that constraint.
The problem is that the function promises to return the *same* kind of object as was passed in, not just *some* object matching the constraint.

### Specifying Type Arguments

TypeScript can usually infer the intended type arguments in a generic call, but not always.

```ts twoslash
function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {
  return arr1.concat(arr2)
}
```

Normally it would be an error to call this function with mismatched arrays:

```ts twoslash
// @errors: 2322
declare function combine<Type>(arr1: Type[], arr2: Type[]): Type[]
// ---cut---
const arr = combine([1, 2, 3], ['hello'])
```

If you intended to do this, however, you could manually specify `Type`:

```ts twoslash
declare function combine<Type>(arr1: Type[], arr2: Type[]): Type[]
// ---cut---
const arr = combine<string | number>([1, 2, 3], ['hello'])
//                  ^^^^^^^^^^^^^^^
```

### Guidelines for Writing Good Generic Functions

Writing generic functions is fun, and it can be easy to get carried away with type parameters.
Having too many type parameters or using constraints where they aren't needed can make inference less successful, frustrating callers of your function.

#### Push Type Parameters Down

Here are two ways of writing a function that appear similar:

```ts twoslash
function firstElement1<Type>(arr: Type[]) {
  return arr[0]
}

function firstElement2<Type extends any[]>(arr: Type) {
  return arr[0]
}

// a: number (good)
const a = firstElement1([1, 2, 3])
// b: any (bad)
const b = firstElement2([1, 2, 3])
```

These might seem identical at first glance, but `firstElement1` is a much better way to write this function.
Its inferred return type is `Type`, but `firstElement2`'s inferred return type is `any` because TypeScript has to resolve the `arr[0]` expression using the constraint type, rather than "waiting" to resolve the element during a call.

> **Rule**: When possible, use the type parameter itself rather than constraining it

#### Use Fewer Type Parameters

> **Rule**: Always use as few type parameters as possible

#### Type Parameters Should Appear Twice

> **Rule**: If a type parameter only appears in one location, strongly reconsider if you actually need it

## Optional Parameters

We can model this in TypeScript by marking the parameter as *optional* with `?`:

```ts twoslash
function f(x?: number) {
  // ...
}

f() // OK
f(10) // OK
```

Although the parameter is specified as type `number`, the `x` parameter will actually have the type `number | undefined` because unspecified parameters in JavaScript get the value `undefined`.

You can also provide a parameter *default*:

```ts twoslash
function f(x = 10) {
  // ...
}
```

Now in the body of `f`, `x` will have type `number` because any `undefined` argument will be replaced with `10`.
Note that when a parameter is optional, callers can always pass `undefined`, as this simply simulates a "missing" argument:

### Optional Parameters in Callbacks

```ts twoslash
function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
  for (let i = 0; i < arr.length; i++) {
    callback(arr[i], i)
  }
}
```

What people usually intend when writing `index?` as an optional parameter is that they want both of these calls to be legal:

```ts twoslash
declare function myForEach(
  arr: any[],
  callback: (arg: any, index?: number) => void
): void
// ---cut---
myForEach([1, 2, 3], a => console.log(a))
myForEach([1, 2, 3], (a, i) => console.log(a, i))
```

What this *actually* means is that *`callback` might get invoked with one argument*.

TypeScript will enforce this meaning and issue errors that aren't really possible:

```ts twoslash
// @errors: 2532 18048
declare function myForEach(
  arr: any[],
  callback: (arg: any, index?: number) => void
): void
// ---cut---
myForEach([1, 2, 3], (a, i) => {
  console.log(i.toFixed())
})
```

In JavaScript, if you call a function with more arguments than there are parameters, the extra arguments are simply ignored.
TypeScript behaves the same way.
Functions with fewer parameters (of the same types) can always take the place of functions with more parameters.

> **Rule**: When writing a function type for a callback, *never* write an optional parameter unless you intend to *call* the function without passing that argument

## Function Overloads

Some JavaScript functions can be called in a variety of argument counts and types.

In TypeScript, we can specify a function that can be called in different ways by writing *overload signatures*.

```ts twoslash
// @errors: 2575
function makeDate(timestamp: number): Date
function makeDate(m: number, d: number, y: number): Date
function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {
  if (d !== undefined && y !== undefined) {
    return new Date(y, mOrTimestamp, d)
  } else {
    return new Date(mOrTimestamp)
  }
}
const d1 = makeDate(12345678)
const d2 = makeDate(5, 5, 5)
const d3 = makeDate(1, 3)
```

In this example, we wrote two overloads: one accepting one argument, and another accepting three arguments.
These first two signatures are called the *overload signatures*.

Then, we wrote a function implementation with a compatible signature.
Functions have an *implementation* signature, but this signature can't be called directly.
Even though we wrote a function with two optional parameters after the required one, it can't be called with two parameters!

### Overload Signatures and the Implementation Signature

Again, the signature used to write the function body can't be "seen" from the outside.

> The signature of the *implementation* is not visible from the outside.
> When writing an overloaded function, you should always have *two* or more signatures above the implementation of the function.

The implementation signature must also be *compatible* with the overload signatures.

### Writing Good Overloads

Like generics, there are a few guidelines you should follow when using function overloads.
Following these principles will make your function easier to call, easier to understand, and easier to implement.

> Always prefer parameters with union types instead of overloads when possible

This function is fine; we can invoke it with strings or arrays.
However, we can't invoke it with a value that might be a string *or* an array, because TypeScript can only resolve a function call to a single overload:

```ts twoslash
// @errors: 2769
declare function len(s: string): number
declare function len(arr: any[]): number
// ---cut---
len('') // OK
len([0]) // OK
len(Math.random() > 0.5 ? 'hello' : [0])
```

Because both overloads have the same argument count and same return type, we can instead write a non-overloaded version of the function:

```ts twoslash
function len(x: any[] | string) {
  return x.length
}
```

This is much better!
Callers can invoke this with either sort of value, and as an added bonus, we don't have to figure out a correct implementation signature.

## Other Types to Know About

### `void`

`void` represents the return value of functions which don't return a value.
It's the inferred type any time a function doesn't have any `return` statements, or doesn't return any explicit value from those return statements:

```ts twoslash
// The inferred return type is void
function noop() {
  return
}
```

In JavaScript, a function that doesn't return any value will implicitly return the value `undefined`.
However, `void` and `undefined` are not the same thing in TypeScript.

> `void` is not the same as `undefined`.

### `object`

The special type `object` refers to any value that isn't a primitive (`string`, `number`, `bigint`, `boolean`, `symbol`, `null`, or `undefined`).
This is different from the *empty object type* `{ }`, and also different from the global type `Object`.

> `object` is not `Object`. **Always** use `object`!

### `unknown`

The `unknown` type represents *any* value.
This is similar to the `any` type, but is safer because it's not legal to do anything with an `unknown` value:

```ts twoslash
// @errors: 2571 18046
function f1(a: any) {
  a.b() // OK
}
function f2(a: unknown) {
  a.b() // NG
}
```

```ts twoslash
declare const someRandomString: string
// ---cut---
function safeParse(s: string): unknown {
  return JSON.parse(s)
}

// Need to be careful with 'obj'!
const obj = safeParse(someRandomString)
```

### `never`

Some functions *never* return a value:

```ts twoslash
function fail(msg: string): never {
  throw new Error(msg)
}
```

The `never` type represents values which are *never* observed.
In a return type, this means that the function throws an exception or terminates execution of the program.

`never` also appears when TypeScript determines there's nothing left in a union.

```ts twoslash
function fn(x: string | number) {
  if (typeof x === 'string') {
    // do something
  } else if (typeof x === 'number') {
    // do something else
  } else {
    console.log(x) // has type 'never'!
    //          ^?
  }
}
```

### `Function`

The global type `Function` describes properties like `bind`, `call`, `apply`, and others present on all function values in JavaScript.
It also has the special property that values of type `Function` can always be called; these calls return `any`:

```ts twoslash
function doSomething(f: Function) {
  return f(1, 2, 3)
}
```

## Rest Parameters and Arguments

::: tip
Background Reading:
[Rest Parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters)
[Spread Syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)
:::

### Rest Parameters

In addition to using optional parameters or overloads to make functions that can accept a variety of fixed argument counts, we can also define functions that take an *unbounded* number of arguments using *rest parameters*.

A rest parameter appears after all other parameters, and uses the `...` syntax:

```ts twoslash
function multiply(n: number, ...m: number[]) {
  return m.map(x => n * x)
}
// 'a' gets value [10, 20, 30, 40]
const a = multiply(10, 1, 2, 3, 4)
```

In TypeScript, the type annotation on these parameters is implicitly `any[]` instead of `any`, and any type annotation given must be of the form `Array<T>` or `T[]`, or a tuple type (which we'll learn about later).

### Rest Arguments

Conversely, we can *provide* a variable number of arguments from an iterable object (for example, an array) using the spread syntax.
For example, the `push` method of arrays takes any number of arguments:

```ts twoslash
const arr1 = [1, 2, 3]
const arr2 = [4, 5, 6]
arr1.push(...arr2)
```

Note that in general, TypeScript does not assume that arrays are immutable.
This can lead to some surprising behavior:

```ts twoslash
// @errors: 2556
// Inferred type is number[] -- "an array with zero or more numbers",
// not specifically two numbers
const args = [8, 5]
const angle = Math.atan2(...args)
```

The best fix for this situation depends a bit on your code, but in general a `const` context is the most straightforward solution:

```ts twoslash
// Inferred as 2-length tuple
const args = [8, 5] as const
// OK
const angle = Math.atan2(...args)
```

## Parameter Destructuring

::: tip
Background Reading:
[Destructuring Assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)
[Spread Syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)
:::

You can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body.
In JavaScript, it looks like this:

```js
function sum({ a, b, c }) {
  console.log(a + b + c)
}
sum({ a: 10, b: 3, c: 9 })
```

The type annotation for the object goes after the destructuring syntax:

```ts twoslash
function sum({ a, b, c }: { a: number; b: number; c: number }) {
  console.log(a + b + c)
}
```

This can look a bit verbose, but you can use a named type here as well:

```ts twoslash
type ABC = { a: number; b: number; c: number }
function sum({ a, b, c }: ABC) {
  console.log(a + b + c)
}
```

## Assignability of Functions

### Return type `void`

The `void` return type for functions can produce some unusual, but expected behavior.

Contextual typing with a return type of `void` does **not** force functions to **not** return something. Another way to say this is a contextual function type with a `void` return type (`type voidFunc = () => void`), when implemented, can return *any* other value, but it will be ignored.

Thus, the following implementations of the type `() => void` are valid:

```ts twoslash
type voidFunc = () => void

const f1: voidFunc = () => {
  return true
}

const f2: voidFunc = () => true

const f3: voidFunc = function () {
  return true
}
```

And when the return value of one of these functions is assigned to another variable, it will retain the type of `void`:

```ts twoslash
type voidFunc = () => void

const f1: voidFunc = () => {
  return true
}

const f2: voidFunc = () => true

const f3: voidFunc = function () {
  return true
}
// ---cut---
const v1 = f1()

const v2 = f2()

const v3 = f3()
```

This behavior exists so that the following code is valid even though `Array.prototype.push` returns a number and the `Array.prototype.forEach` method expects a function with a return type of `void`.

```ts twoslash
const src = [1, 2, 3]
const dst = [0]

src.forEach(el => dst.push(el))
```

There is one other special case to be aware of, when a literal function definition has a `void` return type, that function must **not** return anything.

```ts twoslash
function f2(): void {
  // @ts-expect-error
  return true
}

const f3 = function (): void {
  // @ts-expect-error
  return true
}
```

---

---
url: 'https://zhaobc.site/notes/frontend/ts/handbook/narrowing.md'
---
# Narrowing

Imagine we have a function called `padLeft`.

```ts twoslash
function padLeft(padding: number | string, input: string): string {
  throw new Error('Not implemented yet!')
}
```

If `padding` is a `number`, it will treat that as the number of spaces we want to prepend to `input`.
If `padding` is a `string`, it should just prepend `padding` to `input`.

Let's try to implement the logic for when `padLeft` is passed a `number` for `padding`.

```ts twoslash
function padLeft(padding: number | string, input: string): string {
  if (typeof padding === 'number') {
    return ' '.repeat(padding) + input
    //                ^?
  }

  return padding + input
  //     ^?
}
```

## `typeof` type guards

JavaScript supports a `typeof` operator which can give very basic information about the type of values we have at runtime.
TypeScript expects this to return a certain set of strings:

* `"string"`
* `"number"`
* `"bigint"`
* `"boolean"`
* `"symbol"`
* `"undefined"`
* `"object"`
* `"function"`

In TypeScript, checking against the value returned by `typeof` is a *type guard*.

`typeof` doesn't return the string `null`, `typeof null` is actually `"object"`!

```ts twoslash
// @errors: 18047
function printAll(strs: string | string[] | null) {
  if (typeof strs === 'object') {
    for (const s of strs) {
      console.log(s)
    }
  } else if (typeof strs === 'string') {
    console.log(strs)
  } else {
    // do nothing
  }
}
```

In the `printAll` function, we try to check if `strs` is an object to see if it's an array type, But it turns out that in JavaScript, `typeof null` is actually `"object"`!

## Truthiness narrowing

Values like

* `0`
* `NaN`
* `''` (the empty string)
* `0n` (the `bigint` version of zero)
* `null`
* `undefined`

all coerce to `false`, and other values get coerced to `true`.

You can always coerce values to `boolean`s by running them through the `Boolean` function, or by using the shorter double-Boolean negation.

It's fairly popular to leverage this behavior, especially for guarding against values like `null` or `undefined`.

```ts twoslash
// @errors: 2872
// both of these result in 'true'
Boolean('hello')
!!'world'
```

### Equality narrowing

TypeScript also uses `switch` statements and equality checks like `===`, `!==`, `==`, and `!=` to narrow types.
For example:

```ts twoslash
function example(x: string | number, y: string | boolean) {
  if (x === y) {
    // We can now call any 'string' method on 'x' or 'y'.
    console.log(x.toUpperCase())
    //          ^?

    console.log(y.toUpperCase())
    //          ^?
  } else {
    console.log(x)
    //          ^?

    console.log(y)
    //          ^?
  }
}
```

Since `string` is the only common type that both `x` and `y` could take on, TypeScript knows that `x` and `y` must be `string`s in the first branch.

JavaScript's looser equality checks with `==` and `!=` also get narrowed correctly.

If you're unfamiliar, checking whether something `== null` actually not only checks whether it is specifically the value `null` - it also checks whether it's potentially `undefined`.
The same applies to `== undefined`: it checks whether a value is either `null` or `undefined`.

```ts twoslash
interface Container {
  value: number | null | undefined
}

function multiplyValue(container: Container, factor: number) {
  // Remove both 'null' and 'undefined' from the type.
  if (container.value != null) {
    console.log(container.value)
    //                    ^?

    // Now we can safely multiply 'container.value'.
    container.value *= factor
  }
}
```

### The `in` operator narrowing

TypeScript takes this into account as a way to narrow down potential types.

```ts twoslash
type Fish = {
  swim: () => void
}

type Bird = {
  fly: () => void
}

function move(animal: Fish | Bird) {
  if ('swim' in animal) {
    return animal.swim()
  }

  return animal.fly()
}
```

To reiterate, optional properties will exist in both sides for narrowing.
For example, a human could both swim and fly (with the right equipment) and thus should show up in both sides of the `in` check:

```ts twoslash
type Fish = {
  swim: () => void
}

type Bird = {
  fly: () => void
}

type Human = {
  swim: () => void
  fly: () => void
}

function move(animal: Fish | Bird | Human) {
  if ('swim' in animal) {
    return animal.swim()
    //     ^?
  }

  return animal.fly()
  //     ^?
}
```

### `instanceof` narrowing

```ts twoslash
function logValue(x: Date | string) {
  if (x instanceof Date) {
    console.log(x.toUTCString())
  } else {
    console.log(x.toUpperCase())
  }
}
```

### Assignments

When we assign to any variable, TypeScript looks at the right side of the assignment and narrows the left side appropriately.

### Control flow analysis

TypeScript narrows within specific branches.

### Using type predicates

Sometimes you want more direct control over how types change throughout your code.

To define a user-defined type guard, we simply need to define a function whose return type is a type *predicate*:

```ts twoslash
type Fish = {
  swim: () => void
}

type Bird = {
  fly: () => void
}
// ---cut---
function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined
}
```

`pet is Fish` is our type predicate in this example. A predicate takes the form `parameterName is Type`, where `parameterName` must be the name of a parameter from the current function signature.

Any time `isFish` is called with some variable, TypeScript will *narrow* that variable to that specific type if the original type is compatible.

```ts twoslash
type Fish = {
  swim: () => void
}

type Bird = {
  fly: () => void
}

declare function getSmallPet(): Fish | Bird

function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined
}
// ---cut---
// Both calls to 'swim' and 'fly' are now okay.
let pet = getSmallPet()

if (isFish(pet)) {
  pet.swim()
} else {
  pet.fly()
}
```

Notice that TypeScript not only knows that `pet` is a `Fish` in the `if` branch; it also knows that in the `else` branch, you don’t have a `Fish`, so you must have a `Bird`.

You may use the type guard `isFish` to filter an array of `Fish | Bird` and obtain an array of `Fish`:

```ts twoslash
type Fish = {
  name: string
  swim: () => void
}

type Bird = {
  name: string
  fly: () => void
}

declare function getSmallPet(): Fish | Bird

function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined
}
// ---cut---
const zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()]
const underWater1: Fish[] = zoo.filter(isFish)
// or, equivalently
const underWater2: Fish[] = zoo.filter(isFish) as Fish[]

// The predicate may need repeating for more complex examples
const underWater3: Fish[] = zoo.filter((pet): pet is Fish => {
  if (pet.name === 'sharkey') {
    return false
  }

  return isFish(pet)
})
```

In addition, classes can use `this is Type` to narrow their type.

## Discriminated unions

```ts twoslash
interface Shape {
  kind: 'circle' | 'square'
  radius?: number
  sideLength?: number
}
```

Notice we're using a union of string literal types: `"circle"` and `"square"` to tell us whether we should treat the shape as a circle or square respectively. By using `"circle" | "square"` instead of `string`, we can avoid misspelling issues.

```ts twoslash
// @errors: 2367
interface Shape {
  kind: 'circle' | 'square'
  radius?: number
  sideLength?: number
}
// ---cut---
function handleShape(shape: Shape) {
  // oops!
  if (shape.kind === 'rect') {
    // ...
  }
}
```

We can write a `getArea` function that applies the right logic based on if it's dealing with a circle or square. We'll first try dealing with circles.

```ts twoslash
// @errors: 2532 18048
interface Shape {
  kind: 'circle' | 'square'
  radius?: number
  sideLength?: number
}
// ---cut---
function getArea(shape: Shape) {
  return Math.PI * shape.radius ** 2
}
```

Under `strictNullChecks` that gives us an error - which is appropriate since `radius` might not be defined.
But what if we perform the appropriate checks on the kind property?

```ts twoslash
// @errors: 2532 18048
interface Shape {
  kind: 'circle' | 'square'
  radius?: number
  sideLength?: number
}
// ---cut---
function getArea(shape: Shape) {
  if (shape.kind === 'circle') {
    return Math.PI * shape.radius ** 2
  }
}
```

Hmm, TypeScript still doesn't know what to do here.

We've hit a point where we know more about our values than the type checker does. We could try to use a non-null assertion (a `!` after `shape.radius`) to say that radius is definitely present.

```ts twoslash
interface Shape {
  kind: 'circle' | 'square'
  radius?: number
  sideLength?: number
}
// ---cut---
function getArea(shape: Shape) {
  if (shape.kind === 'circle') {
    return Math.PI * shape.radius! ** 2
  }
}
```

But this doesn't feel ideal. We had to shout a bit at the type-checker with those non-null assertions (`!`) to convince it that `shape.radius` was defined, but those assertions are error-prone if we start to move code around.

```ts twoslash
interface Circle {
  kind: 'circle'
  radius: number
}

interface Square {
  kind: 'square'
  sideLength: number
}

type Shape = Circle | Square
```

Here, we've properly separated `Shape` out into two types with different values for the `kind` property, but `radius` and `sideLength` are declared as required properties in their respective types.

Let's see what happens here when we try to access the `radius` of a `Shape`.

```ts twoslash
// @errors: 2339
interface Circle {
  kind: 'circle'
  radius: number
}

interface Square {
  kind: 'square'
  sideLength: number
}

type Shape = Circle | Square
// ---cut---
function getArea(shape: Shape) {
  return Math.PI * shape.radius ** 2
}
```

Like with our first definition of Shape, this is still an error.
because TypeScript couldn't tell whether the property was present.

But what if we tried checking the kind property again?

```ts twoslash
interface Circle {
  kind: 'circle'
  radius: number
}

interface Square {
  kind: 'square'
  sideLength: number
}

type Shape = Circle | Square
// ---cut---
function getArea(shape: Shape) {
  if (shape.kind === 'circle') {
    return Math.PI * shape.radius ** 2
    //               ^?
  }
}
```

That got rid of the error! When every type in a union contains a common property with literal types, TypeScript considers that to be a *discriminated union*, and can narrow out the members of the union.

In this case, `kind` was that common property (which is what's considered a *discriminant* property of `Shape`). Checking whether the `kind` property was `"circle"` got rid of every type in `Shape` that didn't have a `kind` property with the type `"circle"`. That narrowed shape down to the type `Circle`.

## The `never` type

When narrowing, you can reduce the options of a union to a point where you have removed all possibilities and have nothing left. In those cases, TypeScript will use a `never` type to represent a state which shouldn't exist.

## Exhaustiveness checking

The `never` type is assignable to every type; however, no type is assignable to `never` (except `never` itself). This means you can use narrowing and rely on `never` turning up to do exhaustive checking in a `switch` statement.

```ts twoslash
interface Circle {
  kind: 'circle'
  radius: number
}

interface Square {
  kind: 'square'
  sideLength: number
}

type Shape = Circle | Square
// ---cut---
function getArea(shape: Shape) {
  switch (shape.kind) {
    case 'circle':
      return Math.PI * shape.radius ** 2
    case 'square':
      return shape.sideLength ** 2
    default:
      const _exhaustiveCheck: never = shape
      return _exhaustiveCheck
  }
}
```

Adding a new member to the Shape union, will cause a TypeScript error:

```ts twoslash
// @errors: 2322
interface Circle {
  kind: 'circle'
  radius: number
}

interface Square {
  kind: 'square'
  sideLength: number
}
// ---cut---

interface Triangle {
  kind: 'triangle'
  sideLength: number
}

type Shape = Circle | Square | Triangle

function getArea(shape: Shape) {
  switch (shape.kind) {
    case 'circle':
      return Math.PI * shape.radius ** 2
    case 'square':
      return shape.sideLength ** 2
    default:
      const _exhaustiveCheck: never = shape
      return _exhaustiveCheck
  }
}
```

---

---
url: 'https://zhaobc.site/notes/frontend/ts/handbook/types.md'
---
# Types

## The primitives: `string`, `number`, and `boolean`

JavaScript has three very commonly used primitives: `string`, `number`, and `boolean`.

`number`: JavaScript does not have a special runtime value for integers, so there’s no equivalent to int or float - everything is simply number

::: tip
The type names `String`, `Number`, and `Boolean` (starting with *capital letters*) are legal, but refer to some special *built-in types* that will very rarely appear in your code. *Always* use `string`, `number`, or `boolean` for types.
:::

## Arrays

To specify the type of an array, you can use the syntax `number[]`.
this syntax works for any type (e.g. `string[]` is an array of strings, and so on).
You may also see this written as `Array<number>`, which means the same thing

## any

TypeScript also has a special type, `any`, that you can use whenever you don’t want a particular value to cause typechecking errors.

When a value is of type `any`, you can access any properties of it (which will in turn be of type any), call it like a function, assign it to (or from) a value of any type, or pretty much anything else that’s syntactically legal:

```ts
let obj: any = { x: 0 }
// None of the following lines of code will throw compiler errors.
// Using `any` disables all further type checking, and it is assumed
// you know the environment better than TypeScript.
obj.foo()
obj()
obj.bar = 100
obj = 'hello'
const n: number = obj
```

### `noImplicitAny`

When you don’t specify a type, and TypeScript can’t infer it from context, the compiler will typically default to `any`.

You usually want to avoid this, though, because any isn’t type-checked. Use the compiler flag `noImplicitAny` to flag any implicit any as an error.

## Type Annotations on Variables

When you declare a variable using `const`, `var`, or `let`, you can optionally add a type annotation to explicitly specify the type of the variable.

In most cases, though, this isn’t needed. Wherever possible, TypeScript tries to automatically *infer* the types in your code.

```ts
const myName: string = 'Alice'

// No type annotation needed -- 'myName' inferred as type 'string'
const myName2 = 'Alice'
```

## Functions

### Parameter Type Annotations

When you declare a function, you can add type annotations after each parameter to declare what types of parameters the function accepts. Parameter type annotations go after the parameter name:

```ts twoslash
function greet(name: string) {
  console.log('Hello, ' + name.toUpperCase() + '!!')
}
```

When a parameter has a type annotation, arguments to that function will be checked:

```ts twoslash
declare function greet(name: string): void
// ---cut---
// @errors: 2345
// Would be a runtime error if executed!
greet(42)
```

### Return Type Annotations

You can also add return type annotations. Return type annotations appear after the parameter list:

```ts twoslash
function getFavoriteNumber(): number {
  //                          ^^^^^^
  return 26
}
```

Much like variable type annotations, you usually don't need a return type annotation because TypeScript will infer the function's return type based on its `return` statements.

### Functions Which Return Promises

If you want to annotate the return type of a function which returns a promise, you should use the `Promise` type:

```ts twoslash
async function getFavoriteNumber(): Promise<number> {
  return 26
}
```

### Anonymous Functions

When a function appears in a place where TypeScript can determine how it’s going to be called, the parameters of that function are automatically given types.

This process is called *contextual typing* because the *context* that the function occurred within informs what type it should have.

```ts twoslash
const names = ['Alice', 'Bob', 'Eve']

// Contextual typing for function - parameter s inferred to have type string
names.forEach(function (s) {
  console.log(s.toUpperCase())
})

// Contextual typing also applies to arrow functions
names.forEach(s => {
  console.log(s.toUpperCase())
})
```

## Object Types

Apart from primitives, the most common sort of type you’ll encounter is an object type. This refers to any JavaScript value with properties, which is almost all of them! To define an object type, we simply list its properties and their types.

```ts twoslash
// The parameter's type annotation is an object type
function printCoord(pt: { x: number; y: number }) {
  console.log("The coordinate's x value is " + pt.x)
  console.log("The coordinate's y value is " + pt.y)
}
printCoord({ x: 3, y: 7 })
```

### Optional Properties

Object types can also specify that some or all of their properties are optional. To do this, add a `?` after the property name:

In JavaScript, if you access a property that doesn't exist, you'll get the value `undefined` rather than a runtime error.
Because of this, when you *read* from an optional property, you'll have to *check* for `undefined` before using it.

```ts twoslash
// @errors: 18048
function printName(obj: { first: string; last?: string }) {
  // Error - might crash if 'obj.last' wasn't provided!
  console.log(obj.last.toUpperCase())
  if (obj.last !== undefined) {
    // OK
    console.log(obj.last.toUpperCase())
  }

  // A safe alternative using modern JavaScript syntax:
  console.log(obj.last?.toUpperCase())
}
```

## Union Types

TypeScript’s type system allows you to build new types out of existing ones using a large variety of operators.
Now that we know how to write a few types, it’s time to start combining them in interesting ways.

### Defining a Union Type

A union type is a type formed from two or more other types, representing values that may be any one of those types.

```ts twoslash
// @errors: 2345
function printId(id: number | string) {
  console.log('Your ID is: ' + id)
}
// OK
printId(101)
// OK
printId('202')
// Error
printId({ myId: 1234 })
```

### Working with Union Types

It's easy to *provide* a value matching a union type - simply provide a type matching any of the union's members.

TypeScript will only allow an operation if it is valid for *every* member of the union.
For example, if you have the union `string | number`, you can't use methods that are only available on `string`:

```ts twoslash
// @errors: 2339
function printId(id: number | string) {
  console.log(id.toUpperCase())
}
```

The solution is to *narrow* the union with code, the same as you would in JavaScript without type annotations.
*Narrowing* occurs when TypeScript can deduce a more specific type for a value based on the structure of the code.

```ts twoslash
function printId(id: number | string) {
  if (typeof id === 'string') {
    // In this branch, id is of type 'string'
    console.log(id.toUpperCase())
  } else {
    // Here, id is of type 'number'
    console.log(id)
  }
}
```

Another example is to use a function like `Array.isArray`:

```ts twoslash
function welcomePeople(x: string[] | string) {
  if (Array.isArray(x)) {
    // Here: 'x' is 'string[]'
    console.log('Hello, ' + x.join(' and '))
  } else {
    // Here: 'x' is 'string'
    console.log('Welcome lone traveler ' + x)
  }
}
```

If every member in a union has a property in common, you can use that property without narrowing:

```ts twoslash
// Return type is inferred as number[] | string
function getFirstThree(x: number[] | string) {
  return x.slice(0, 3)
}
```

## Type Aliases

It's common to want to use the same type more than once and refer to it by a single name.

A *type alias* is exactly that - a *name* for any *type*.
The syntax for a type alias is:

```ts twoslash {1}
type Point = {
  x: number
  y: number
}

function printCoord(pt: Point) {
  console.log("The coordinate's x value is " + pt.x)
  console.log("The coordinate's y value is " + pt.y)
}

printCoord({ x: 100, y: 200 })
```

You can actually use a type alias to give a name to any type at all, not just an object type.
For example, a type alias can name a union type:

```ts twoslash
type ID = number | string
```

When you use the alias, it's exactly as if you had written the aliased type.

```ts twoslash
type UserInputSanitizedString = string
declare function getInput(): string
declare function sanitize(str: string): string
// ---cut---
function sanitizeInput(str: string): UserInputSanitizedString {
  return sanitize(str)
}

// Create a sanitized input
let userInput = sanitizeInput(getInput())

// Can still be re-assigned with a 'string' though
userInput = 'new input'
```

## Interfaces

An *interface declaration* is another way to name an object type:

```ts twoslash {1}
interface Point {
  x: number
  y: number
}

function printCoord(pt: Point) {
  console.log("The coordinate's x value is " + pt.x)
  console.log("The coordinate's y value is " + pt.y)
}

printCoord({ x: 100, y: 200 })
```

### Differences Between Type Aliases and Interfaces

Type aliases and interfaces are very similar, and in many cases you can choose between them freely.
Almost all features of an `interface` are available in `type`, the key distinction is that a *type cannot be re-opened to add new properties* vs *an interface which is always extendable*.

::: tabs

@tab Interface#interface

Extending an interface

```ts twoslash {5}
declare function getBear(): Bear
// ---cut---
interface Animal {
  name: string
}

interface Bear extends Animal {
  honey: boolean
}

const bear = getBear()
bear.name
bear.honey
```

Adding new fields to an existing interface

```ts
interface Window {
  title: string
}

interface Window {
  ts: TypeScriptAPI
}

const src = 'const a = "Hello World"'
window.ts.transpileModule(src, {})
```

@tab Type#type

Extending a type via intersections

```ts twoslash {5}
declare function getBear(): Bear
// ---cut---
type Animal = {
  name: string
}

type Bear = Animal & {
  honey: boolean
}

const bear = getBear()
bear.name
bear.honey
```

A type cannot be changed after being created

```ts
interface Window {
  title: string
}

// Error: Duplicate identifier 'Window'.
interface Window {
  ts: TypeScriptAPI
}
```

:::

## Type Assertions

Sometimes you will have information about the type of a value that TypeScript can’t know about.

In this situation, you can use a *type assertion* to specify a more specific type:

```ts twoslash
const myCanvas = document.getElementById('main_canvas') as HTMLCanvasElement
```

You can also use the angle-bracket syntax (except if the code is in a `.tsx` file), which is equivalent:

```ts twoslash
const myCanvas = <HTMLCanvasElement>document.getElementById('main_canvas')
```

TypeScript only allows type assertions which convert to a *more specific* or *less specific* version of a type.
This rule prevents "impossible" coercions like:

```ts twoslash
// @errors: 2352
const x = 'hello' as number
```

Sometimes this rule can be too conservative and will disallow more complex coercions that might be valid.
If this happens, you can use two assertions, first to `any` (or `unknown`, which we'll introduce later), then to the desired type:

```ts twoslash
declare const expr: any
type T = { a: 1; b: 2; c: 3 }
// ---cut---
const a = expr as any as T
```

## Literal Types

Both `var` and `let` allow for changing what is held inside the variable, and `const` does not.
This is reflected in how TypeScript creates types for literals.

```ts twoslash
let changingString = 'Hello World'
changingString = 'zhaobc'

// Because `changingString` can represent any possible string, that
// is how TypeScript describes it in the type system
changingString
// ^?

const constantString = 'Hello World'
// Because `constantString` can only represent 1 possible string, it
// has a literal type representation
constantString
// ^?
```

By themselves, literal types aren't very valuable:

```ts twoslash
// @errors: 2322
let x: 'hello' = 'hello'
// OK
x = 'hello'
// NG
x = 'zhaobc'
```

It's not much use to have a variable that can only have one value!

But by *combining* literals into unions, you can express a much more useful concept - for example, functions that only accept a certain set of known values:

```ts twoslash
// @errors: 2345
function printText(s: string, alignment: 'left' | 'center' | 'right') {
  // ...
}

printText('Hello', 'left')
printText('World', 'centre')
```

Numeric literal types work the same way:

```ts twoslash
function compare(a: string, b: string): -1 | 0 | 1 {
  return a === b ? 0 : a > b ? 1 : -1
}
```

Of course, you can combine these with non-literal types:

```ts twoslash
// @errors: 2345
interface Options {
  width: number | string
}

function configure(x: Options | 'auto') {
  // ...
}

configure({ width: 100 })
configure('auto')
configure('automatic')
```

### Literal Inference

When you initialize a variable with an object, TypeScript assumes that the properties of that object might change values later. For example, if you wrote code like this:

```ts twoslash
declare const someCondition = true
// ---cut---
const obj = {
  counter: 0,
  // ^?
}

if (someCondition) {
  obj.counter = 1
}
```

TypeScript *doesn’t* assume the assignment of `1` to a field which previously had `0` is an error. Another way of saying this is that `obj.counter` must have the type `number`, not `0`, because types are used to determine both reading and writing behavior.

The same applies to strings:

```ts twoslash
// @errors: 2345
declare function handleRequest(url: string, method: 'GET' | 'POST'): void

const req = {
  url: 'http://example.com',
  method: 'GET',
}
handleRequest(req.url, req.method)
```

In the above example `req.method` is inferred to be `string`, not `"GET"`. Because code can be evaluated between the creation of `req` and the call of `handleRequest` which could assign a new string like `"GUESS"` to `req.method`, TypeScript considers this code to have an error.

There are two ways to work around this.

1. You can change the inference by adding a type assertion in either location:

   ```ts twoslash
   declare function handleRequest(url: string, method: 'GET' | 'POST'): void
   // ---cut---
   // Change 1:
   const req = { url: 'https://example.com', method: 'GET' as 'GET' }
   // Change 2
   handleRequest(req.url, req.method as 'GET')
   ```

   Change 1 means "I intend for `req.method` to always have the *literal type* `"GET"`", preventing the possible assignment of `"GUESS"` to that field after.
   Change 2 means "I know for other reasons that `req.method` has the value `"GET"`".

2. You can use `as const` to convert the entire object to be type literals:

   ```ts twoslash
   declare function handleRequest(url: string, method: 'GET' | 'POST'): void
   // ---cut---
   const req = { url: 'https://example.com', method: 'GET' } as const
   handleRequest(req.url, req.method)
   ```

The `as const` suffix acts like `const` but for the type system, ensuring that all properties are assigned the literal type instead of a more general version like `string` or `number`.

## `null` and `undefined`

JavaScript has two primitive values used to signal absent or uninitialized value: `null` and `undefined`.

TypeScript has two corresponding *types* by the same names. How these types behave depends on whether you have the \[`strictNullChecks`] option on.

### `strictNullChecks` off

With \[`strictNullChecks`] *off*, values that might be `null` or `undefined` can still be accessed normally, and the values `null` and `undefined` can be assigned to a property of any type.
The lack of checking for these values tends to be a major source of bugs; we always recommend people turn [`strictNullChecks`](/tsconfig#strictNullChecks) on if it's practical to do so in their codebase.

### `strictNullChecks` on

With \[`strictNullChecks`] *on*, when a value is `null` or `undefined`, you will need to test for those values before using methods or properties on that value.
Just like checking for `undefined` before using an optional property, we can use *narrowing* to check for values that might be `null`:

```ts twoslash
function doSomething(x: string | null) {
  if (x === null) {
    // do nothing
  } else {
    console.log(x.toUpperCase())
  }
}
```

### Non-null Assertion Operator (Postfix `!`)

TypeScript also has a special syntax for removing `null` and `undefined` from a type without doing any explicit checking.
Writing `!` after any expression is effectively a type assertion that the value isn't `null` or `undefined`:

```ts twoslash
function liveDangerously(x?: number | null) {
  // No error
  console.log(x!.toFixed())
}
```

Just like other type assertions, this doesn't change the runtime behavior of your code,
so it's important to only use `!` when you know that the value *can't* be `null` or `undefined`.

## Enums

Enums allow a developer to define a set of named constants.

```ts twoslash
enum Direction {
  Up,
  Down,
  Left,
  Right,
}
```

## Less Common Primitives

### `bigint`

From ES2020 onwards, there is a primitive in JavaScript used for very large integers, `BigInt`:

```ts twoslash
// @target: es2020

// Creating a bigint via the BigInt function
const oneHundred: bigint = BigInt(100)
// Creating a BigInt via the literal syntax
const anotherHundred: bigint = 100n
```

### `symbol`

There is a primitive in JavaScript used to create a globally unique reference via the function `Symbol()`:

```ts twoslash
// @errors: 2367
const firstName = Symbol('name')
const secondName = Symbol('name')

if (firstName === secondName) {
  // Can't even happen
}
```

---

---
url: 'https://zhaobc.site/notes/frontend/vue/index.md'
---
# Vue 笔记

Vue 学习笔记

* [Vue2 学习笔记](https://github.com/FuckDoctors/hello-vue-2.0)

  只是照着官方指南敲了敲代码

* Vue3 学习笔记

  只是照着官方指南敲了敲代码

  * [第一部分](https://github.com/FuckDoctors/hello-vue3)
  * [第二部分](./vue3/README.md)

* [Vue.js 设计与实现](./vue3-book/)

  本书源代码: <https://github.com/HcySunYang/code-for-vue-3-book>

* [Pinia 学习笔记](./pinia/)

  只是照着官方指南敲了敲代码

---

---
url: 'https://zhaobc.site/notes/frontend/vue/pinia/index.md'
---
# Pinia 官方资料笔记

---

---
url: 'https://zhaobc.site/notes/frontend/vue/pinia/core-concepts/index.md'
---
# Core Concepts

---

---
url: 'https://zhaobc.site/notes/frontend/vue/pinia/core-concepts/actions.md'
---
# Actions

Actions are the equivalent of methods in components.
They can be defined with the actions property in `defineStore()` and they are perfect to define **business logic**.

Like getters, actions get access to the whole store instance through `this` with full typing (and autocompletion ✨) support.
Unlike getters, `actions` **can be asynchronous**, you can await inside of actions any API call or even other actions!

```js
import { defineStore } from 'pinia'
import { mande } from 'mande'

import { useAuthStore } from './auth-store'

const api = mande('/api/users')

export const useUsers = defineStore('users', {
  state: () => ({
    userData: null,
    preferences: null,
  }),

  actions: {
    // async
    async registerUser(login, password) {
      this.userData = await api.post({ login, password })
    },
    async fetchUserPreferences() {
      // use another store
      const auth = useAuthStore()
      if (auth.isAuthenticated) {
        this.preferences = await fetchPreferences()
      }
    },
  },
})
```

If you would prefer not to use Composition API at all, you can use the `mapActions()` helper to map actions properties as methods in your component:

```js
import { mapActions } from 'pinia'
import { useCounterStore } from '../stores/counterStore'

export default {
  methods: {
    // gives access to this.increment() inside the component
    // same as calling from store.increment()
    ...mapActions(useCounterStore, ['increment'])
    // same as above but registers it as this.myOwnName()
    ...mapActions(useCounterStore, { myOwnName: 'doubleCounter' }),
  },
}
```

## Subscribing to actions

It is possible to observe actions and their outcome with `store.$onAction()`.

The callback passed to it is executed **before** the action itself.
`after` handle promises and allows you to execute a function after the action resolves.
In a similar way, onError allows you execute a function if the action throws or rejects.

Here is an example that logs before running actions and after they resolve/reject.

```js
const unsubscribe = someStore.$onAction(
  ({
    name, // name of the action
    store, // store instance, same as 'someStore'
    args, // array of parameters passed to the action
    after, // hook after the action returns or resolves
    onError, // hook if the action throws or reject
  }) => {
    // a shared variable for this specific action call
    const startTime = Date.now()
    // this will trigger before an action on `store` is executed
    console.log(`Start "${name}" with params [${args.join(', ')}].`)

    // this will trigger if the action succeeds and after it has fully run.
    // it waits for any returned promised
    after(result => {
      console.log(
        `Finished "${name}" after ${
          Date.now() - startTime
        }ms.\nResult: ${result}`
      )
    })

    // this will trigger if the action throws or returns a promise that rejects
    onError(error => {
      console.warn(
        `Failed "${name}" after ${Date.now() - startTime}ms.\nError: ${error}.`
      )
    })
  }
)

// manually remove the listener
unsubscribe()
```

By default, action subscriptions are bound to the component where they are added (if the store is inside a component's `setup()`).
Meaning, they will be automatically removed when the component is unmounted.
If you want to keep them after the component is unmounted,
pass `true` as the second argument to detach the action subscription from the current component:

```js
export default {
  setup() {
    const someStore = useSomeStore()

    // this subscription will be kept after the component is unmounted
    someStore.$onAction(callback, true)
  },
}
```

---

---
url: 'https://zhaobc.site/notes/frontend/vue/pinia/core-concepts/define-store.md'
---
# Defining a Store

A store is defined using `defineStore()` and that it requires a **unique** name, passed as the first argument:

```js
import { defineStore } from 'pinia'

// useStore could be anything like useUser, useCart
// the first argument is a unique id of the store across your application
export const useStore = defineStore('main', {
  // other options
})
```

This *name*, also referred as id, is necessary and is used by Pinia to connect the store to the devtools.
Naming the returned function use... is a convention across composables to make its usage idiomatic.

## Using a store

We are *defining* a store because the store won't be created until `useStore()` is called inside of `setup()`:

```js
import { useStore } from '@/store/counter'

export default {
  setup() {
    const store = useStore()

    return {
      // you can return the whole store instance to use it in the template
      store,
    }
  },
}
```

You can define as many stores as you want and **you should define each store in a different file** to get the most out of pinia (like automatically allow your bundle to code split and TypeScript inference).

Note that store is an object wrapped with `reactive`, meaning there is no need to write `.value` after getters but, like `props` in setup, **we cannot destructure it**:

```js
export default defineComponent({
  setup() {
    const store = userStore()

    // ❌ This won't work because it breaks reactivity
    // it's the same as destructuring from `props`
    const { name, doubleCount } = store

    name // "eduardo"
    doubleCount // 2

    return {
      // will always be "eduardo"
      name,
      // will always be 2
      doubleCount,
      // this one will be reactive
      doubleValue: computed(() => store.doubleCount),
    }
  },
})
```

::: playground#vue Destructure example

@file App.vue

```vue
<script setup>
import { computed } from 'vue'
import { useStore } from './store.js'

const store = useStore()

let { name, doubleCount } = store
const { increment } = store
const doubleValue = computed(() => store.doubleCount)
</script>

<template>
  <div>Name: {{ name }} &lt;- not reactive</div>
  <div>Double count: {{ doubleCount }} &lt;- not reactive</div>
  <div>Double value: {{ doubleValue }} &lt;- reactive</div>
  <button @click="name = 'bin'">change name</button>
  <button @click="increment">increment</button>
</template>
```

@file store.js

```js
import { defineStore } from 'pinia'

export const useStore = defineStore('test', {
  state: () => ({
    name: 'zhaobc',
    count: 0,
  }),
  getters: {
    doubleCount: state => state.count * 2,
  },
  actions: {
    increment() {
      this.count++
    },
  },
})
```

@setting

```json
{
  "service": "https://play.zhaobc.site"
}
```

:::

In order to extract properties from the store while keeping its reactivity, you need to use `storeToRefs()`.
It will create refs for every reactive property.
Note you can destructure actions directly from the store as they are bound to the store itself too:

```js
import { storeToRefs } from 'pinia'

export default defineComponent({
  setup() {
    const store = useStore()

    // `name` and `doubleCount` are reactive refs
    // This will also create refs for properties added by plugins
    // but skip any action or non reactive (non ref/reactive) property
    const { name, doubleCount } = storeToRefs(store)
    // the increment action can be just extracted
    const { increment } = store

    return {
      name,
      doubleCount,
      increment,
    }
  },
})
```

::: playground#vue Destructure example using storeToRefs

@file App.vue

```vue
<script setup>
import { computed } from 'vue'
import { storeToRefs } from 'pinia'
import { useStore } from './store.js'

const store = useStore()

const { name, doubleCount } = storeToRefs(store)
const { increment } = store
const doubleValue = computed(() => store.doubleCount)
</script>

<template>
  <div>Name: {{ name }} &lt;- reactive</div>
  <div>Double count: {{ doubleCount }} &lt;- reactive</div>
  <div>Double value: {{ doubleValue }} &lt;- reactive</div>
  <button @click="name = 'bin'">change name</button>
  <button @click="increment">increment</button>
</template>
```

@file store.js

```js
import { defineStore } from 'pinia'

export const useStore = defineStore('test', {
  state: () => ({
    name: 'zhaobc',
    count: 0,
  }),
  getters: {
    doubleCount: state => state.count * 2,
  },
  actions: {
    increment() {
      this.count++
    },
  },
})
```

@setting

```json
{
  "service": "https://play.zhaobc.site"
}
```

:::

---

---
url: 'https://zhaobc.site/notes/frontend/vue/pinia/core-concepts/getters.md'
---
# Getters

Getters are exactly the equivalent of computed values for the state of a Store.
They can be defined with the getters property in `defineStore()`.
They receive the state as the first parameter to encourage the usage of arrow function:

we can get access to the whole store instance through `this` when defining a regular function,
but it is necessary to define the type of the return type (in TypeScript).

```js
export const useStore = defineStore('main', {
  state: () => ({
    counter: 0,
  }),
  getters: {
    // Passing arguments to getters
    doubleCount(state) {
      return state.counter * 2
    },
    // the return **must** be explicitly set
    doublePlusOne(): number {
      // autocompletion and typings for the whole store
      // Accessing other getters
      return this.doubleCount + 1
    },
  },
})
```

To use another store getters, you can directly use it inside of the getter:

```js
import { useOtherStore } from './other-store'

export const useStore = defineStore('main', {
  state: () => ({
    // ...
  }),
  getters: {
    otherGetter(state) {
      const otherStore = useOtherStore()
      return state.localData + otherStore.data
    },
  },
})
```

---

---
url: 'https://zhaobc.site/notes/frontend/vue/pinia/core-concepts/plugins.md'
---
# Plugins

Pinia stores can be fully extended thanks to a low level API. Here is a list of things you can do:

* Add new properties to stores
* Add new options when defining stores
* Add new methods to stores
* Wrap existing methods
* Change or even cancel actions
* Implement side effects like Local Storage
* Apply only to specific stores

Plugins are added to the pinia instance with `pinia.use()`.
The simplest example is adding a static property to all stores by returning an object:

```js
import { createPinia } from 'pinia'

// add a property named `secret` to every store that is created after this plugin is installed
// this could be a different file
function SecretPiniaPlugin() {
  return {
    secret: 'the cake is a lie',
  }
}

const pinia = createPinia()
// give the plugin to pinia
pinia.use(SecretPiniaPlugin)

// in another file
const store = useStore()
store.secret // 'the cake is a lie'
```

This is useful to add global objects like the router, modal, or toast managers.

## Introduction

A Pinia plugin is a function that optionally returns properties to be added to a store. It takes one optional argument, a context:

```js
export function myPiniaPlugin(context) {
  context.pinia // the pinia created with `createPinia`
  context.app // the current app created with `createApp` (Vue3 only)
  context.store // the store the plugin is augmenting
  context.options // the options object defining the store passed to `defineStore()`
  // ...
}

pinia.use(myPiniaPlugin)
```

Plugins are only applied to stores **created after** `pinia` is passed to the app, otherwise they won't be applied.

## Augmenting(扩大，增大，增强) a Store

You can add properties to every store by simply returning an object of them in a plugin:

```js
pinia.use(() => ({
  hello: 'world',
}))
```

You can also set the property directly on the store but if possible `use the return version` so they can be automatically tracked by devtools:

```js
pinia.use(({ store }) => {
  store.hello = 'world'
})
```

Note that every store is wrapped with `reactive`, **automatically unwrapping** any `Ref` (`ref()`, `computed()`, ...) it contains:

```js
const sharedRef = ref('shared')
pinia.use(({ store }) => {
  // each store has its individual `hello` property
  store.hello = ref('secret')
  // it gets automatically unwrapped
  store.hello // 'secret'

  // all stores are sharing the value `shared` property
  store.shared = sharedRef
  store.shared // 'shared'
})
```

This is why you can access all computed properties without .value and why they are reactive.

## Adding new state

If you want to add new state properties to a store or properties that are meant to be used during hydration,
you will have to add it in two places:

* On the `store` so you can access it with `store.myState`
* On `store.$state` so it can be used in devtools and, be serialized during SSR.

On top of that, you will certainly have to use a `ref()` (or other reactive API) in order to share the value across different accesses:

```js
import { toRef, ref } from 'vue'

pinia.use(({ store }) => {
  // to correctlly handle SSR, we need to make sure we are not overriding an existing value
  if (!Object.prototype.hasOwnProperty(store.$state, 'hasError')) {
    // hasError is defined within the plugin, so each store has their individual state property
    const hasError = ref(false)
    // setting the variable on `$state`, allows it be serialized during SSR
    store.$state.hasError = hasError
  }

  // we need to transfer the ref from the state to the store,
  // this way both accesses: store.hasError and store.$state.hasError
  // will work and share the same variable
  store.hasError = toRef(store.$state, 'hasError')

  // in this case it's better not to return `hasError` since it
  // will be displayed in the `state` section in the devtools
  // anyway and if we return it, devtools will display it twice.
})
```

## Adding new external properties

When adding external properties, class instances that come from other libraries, or simply things that are not reactive,
you should wrap the object with `markRaw()` before passing it to pinia.

```js
import { markRaw } from 'vue'

import { router } from './router'

pinia.use(store => {
  store.router = markRaw(router)
})
```

## Calling `$subscribe` inside plugins

You can use [`store.$subscribe`](https://pinia.vuejs.org/core-concepts/state.html#subscribing-to-the-state) and [`store.$onAction`](https://pinia.vuejs.org/core-concepts/actions.html#subscribing-to-actions) inside plugins too:

```js
pinia.use(({ store }) => {
  store.$subscribe(() => {
    // react to store changes
  })
  store.$onAction(() => {
    // react to store anctions
  })
})
```

## Adding new options

It is possible to create new options when defining stores to later on consume them from plugins.

For example, you could create a `debounce` option that allows you to debounce any action:

```js
const useSearchStore = defineStore('search', {
  actions: {
    searchContacts() {
      // ...
    }
  }
  // this will be read by a plugin later on
  debounce: {
    // debounce the action searchContacts by 300ms
    searchContacts: 300
  }
})
```

The plugin can then read that option to wrap actions and replace the original ones:

```js
// use any debounce library
import debounce from 'loadash/debounce'

pinia.use(({ options, store }) => {
  if (options.debounce) {
    // we are overriding the actions with new ones
    return Object.keys(options.debounce).reduce((debounceActions, action) => {
      debounceActions[action] = debounce(
        store[action],
        options.debounce[action]
      )
    })
  }
})
```

Note that custom options are passed as the 3rd argument when using the setup syntax:

```js
defineStore(
  'search',
  () => {
    // ...
  },
  {
    // this will be read by a plugin later on
    debounce: {
      searchContacts: 300,
    },
  }
)
```

## TypeScript

### A Pinia plugin can be typed as follows

```ts
import { PiniaPluginContext } from 'pinia'

export function myPiniaPlugin(context: PiniaPluginContext) {
  // ...
}
```

### Typing new store properties

When adding new properties to stores, you should also extend the `PiniaCustomProperties` interface.

```ts
import 'pinia'

declare module 'pinia' {
  export interface PiniaCustomProperties {
    // by using a setter we can allow string and refs
    set hello(value: string | Ref<string>)
    get hello(): string

    // you can define simpler value too
    simpleNumber: number
  }
}
```

It can then be written and read safely:

```ts
pinia.use(({ store }) => {
  store.hello = 'hola'
  store.hello = ref('hola')

  store.simpleNumber = Math.random()
  // @ts-expect-error: we haven't typed this correctlly
  sotre.simpleNumber = ref<Math.random>
})
```

`PiniaCustomProperties` is a generic type that allows you to reference properties of a store.

```ts
pinia.use(({ options }) => ({ $options options }))
```

We can properly type this by using the 4 generic types of `PiniaCustomProperties:`

```ts
import 'pinia'

declare module 'pinia' {
  export interface PiniaCustomProperties<Id, S, G, A) {
    $options: {
      id: Id,
      state?: () => s
      options? A
    }

  }
}
```

### Typing new state

When adding new state properties (to both, the `store` and `store.$state`), you need to add the type to `PiniaCustomStateProperties` instead. Differently from `PiniaCustomProperties`, it only receives the State generic:

```ts
import 'pinia'

declare module 'pinia' {
  export interface DefineCustomStateProperties<S> {
    hello: string
  }
}
```

### Typing new creation options

When creating new options for `defineStore()`, you should extend the `DefineStoreOptionsBase`.
Differently from `PiniaCustomProperties`, it only exposes two generics: the State and the Store type, allowing you to limit what can be defined.
For example, you can use the names of the actions:

```ts
import 'pinia'

define module 'pinia' {
  export interface DefineStoreOptionsBase<S, Store> {
    // allow defining a number of ms for any of the actions
    debounce?: Partial<Record<keyof StoreActions<Store>, number>>
  }
}
```

---

---
url: 'https://zhaobc.site/notes/frontend/vue/pinia/core-concepts/state.md'
---
# State

The state is, most of the time, the central part of your store.
In Pinia the state is **defined as a function that returns the initial state**.

```js
import { defineStore } from 'pinia'

const useStore = defineStore('storeId', {
  // arrow function recommended for full type inference
  state: () => {
    return {
      // all these properties will have their type inferred automatically
      counter: 0,
      name: 'Eduardo',
      isAdmin: true,
    }
  },
})
```

::: tip
If you are using Vue 2, the data you create in state follows the same rules as the data in a Vue instance,
ie the state object must be plain and you need to call `Vue.set()` when adding new properties to it.
See also: [Vue#data](https://v2.vuejs.org/v2/api/#data).
:::

## Accessing the `state`

By default, you can directly read and write to the state by accessing it through the `store` instance:

```js
const store = useStore()
store.counter++
```

## Resetting the state

You can *reset* the state to its initial value by calling the `$reset()` method on the store:

```js
const store = useStore()
store.$reset()
```

## Usage with the Options API

```js
// src/stores/counterStore.js
import { defineStore } from 'pinia'

const useCounterStore = defineStore('counterStore', {
  state: () => ({
    counter: 0,
  }),
})
```

If you are not using the Composition API, and you are using `computed`, `methods`, ...,
you can use the `mapState()` helper to map state properties as readonly computed properties:

```js
import { mapState } from 'pinia'
import { useCounterStore } from '@/stores/counterStore'

export default {
  computed: {
    // gives access to this.counter inside the component
    // same as reading from store.counter
    ...mapState(useCounterStore, ['counter']),
    // same as above but registers is as this.myOwnName
    ...mapState(useCounterStore, {
      myOwnName: 'counter',
      // you can also write a function that gets access to the store
      double: store => store.counter * 2,
      // it can have access to `this` but it won't be typed correctlly
      magicValue(store) {
        return store.someGetter + this.counter + this.double
      },
    }),
  },
}
```

### Modifiable state

If you want to be able to write to these state properties (e.g. if you have a form),
you can use `mapWritableState()` instead.
Note you cannot pass a function like with `mapState()`:

```js
import { mapWritableState } from 'pinia'
import { useCounterStore } from '../stores/counterStore'

export default {
  computed: {
    // gives access to this.counter inside the component and allows setting it
    // this.counter++
    // same as reading from store.counter
    ...mapWritableState(useCounterStore, ['counter'])
    // same as above but registers it as this.myOwnName
    ...mapWritableState(useCounterStore, {
      myOwnName: 'counter',
    }),
  },
}
```

::: tip
You don't need `mapWritableState()` for collections like arrays unless you are replacing the whole array with cartItems = \[],
`mapState()` still allows you to call methods on your collections.
:::

::: playground#vue Usage with the Options API

@file App.vue

```vue
<script>
import { mapState, mapStores, mapActions, mapWritableState } from 'pinia'
import { useCounterStore } from './counterStore.js'

export default {
  computed: {
    ...mapStores(useCounterStore),
    ...mapWritableState(useCounterStore, ['count']),
    ...mapState(useCounterStore, ['doubleCount']),
    ...mapWritableState(useCounterStore, {
      myCounter: 'count',
    }),
  },
  methods: {
    ...mapActions(useCounterStore, ['increment']),
  },
}
</script>

<template>
  <div>Counter: {{ count }}</div>
  <div>MyCounter: {{ myCounter }}</div>
  <div>Double count: {{ doubleCount }}</div>
  <div>Change counter: <input type="number" v-model.number="count" /></div>
  <button @click="increment">increment</button>
  <button @click="counterStore.$reset()">reset</button>
</template>
```

@file counterStore.js

```js
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', {
  state: () => ({
    count: 0,
  }),
  getters: {
    doubleCount: state => state.count * 2,
  },
  actions: {
    increment() {
      this.count++
    },
  },
})
```

@setting

```json
{
  "service": "https://play.zhaobc.site"
}
```

:::

## Mutating the state

Apart from directly mutating the store with store.counter++, you can also call the `$patch` method.
It allows you to apply multiple changes at the same time with a partial state object:

```js
store.$patch({
  counter: store.counter + 1,
  name: 'zhaobc',
})
```

However, some mutations are really hard or costly to apply with this syntax: any collection modification
(e.g. pushing, removing, splicing an element from an array) requires you to create a new collection.
Because of this, the `$patch` method also accepts a function to group this kind of mutations that are difficult to apply with a patch object:

```js
cartStore.$patch(state => {
  state.items.push({
    name: 'shoes',
    quantity: 1,
  })
  state.hasChanged = true
})
```

## Replacing the state

You can replace the whole state of a store by setting its `$state` property to a new object:

```js
store.$state = {
  counter: 666,
  name: 'zhaobc',
}
```

You can also replace the whole state of your application by changing the state of the pinia instance:

```js
pinia.state.value = {}
```

## Subscribing to the state

You can watch the state and its changes through the `$subscribe()` method of a store, similar to Vuex's subscribe method.

The advantage of using `$subscribe()` over a regular `watch()` is that subscriptions will trigger only **once** after patches (e.g. when using the function version from above).

```js
cartStore.$subscribe((mutation, state) => {
  // import { MutationType } from 'pinia'
  mutation.type // 'direct' | 'patch object' | 'patch function'
  mutation.storeId // cart
  mutation.payload // patch object passed to cartStore.$patch

  // persist the whole state to the local storage whenever it changes
  localStorage.setItem('cart', JSON.stringify(state))
})
```

By default, state subscriptions are bound to the component where they are added (if the store is inside a component's `setup()`).
Meaning, they will be automatically removed when the component is unmounted.

If you want to keep them after the component is unmounted,
pass `{ detached: true }` as the second argument to detach the state subscription from the current component:

```js
export default {
  setup() {
    const someState = useSomeStore()

    // this subscription will be kept after the component is unmounted
    someStore.$subscribe(callback, { detached: true })
  },
}
```

You can watch the whole state on the pinia instance:

```js
watch(
  pinia.state,
  state => {
    // persist the whole state to the local storage whenever it changes
    localStorage.setItem('piniaState', JSON.stringify(state))
  },
  {
    deep: true,
  }
)
```

---

---
url: 'https://zhaobc.site/notes/frontend/vue/pinia/intro/index.md'
---
# Intro

---

---
url: 'https://zhaobc.site/notes/frontend/vue/pinia/intro/get-started.md'
---
# Get Started

## Installation

Create a pinia (the root store) and pass it to the app:

```js
import { createPinia } from 'pinia'

app.use(createPinia())
```

If you are using Vue 2, you also need to install a plugin and inject the created pinia at the root of the app:

```js
import { PiniaVuePlugin, createPinia } from 'pinia'

Vue.use(PiniaVuePlugin)
const pinia = createPinia()

new Vue({
  el: '#app',
  // other options
  // ...
  // note the same `pinia` instance can be used across multiple Vue apps on the same page
  pinia,
})
```

## What is a Store?

A Store (like Pinia) is an entity holding state and business logic that isn't bound to your Component tree.

In other words, **it hosts global state**.
It's a bit like a component that is always there and that everybody can read off and write to.

It has **three concepts**, the **state**, **getters** and **actions** and it's safe to assume these concepts are the equivalent of **data**, **computed** and **methods** in components.

## When should I use a Store

A store should contain data that can be accessed throughout your application. This includes data that is used in many places, e.g. User information that is displayed in the navbar, as well as data that needs to be preserved through pages, e.g. a very complicated multi-step form.

Not all applications need access to a global state, but if yours need one, Pinia will make your life easier.

---

---
url: 'https://zhaobc.site/notes/frontend/vue/pinia/intro/intro.md'
---
# Introduction

Pinia (pronounced /piːnjʌ/, like "peenya" in English) is a store library for Vue, it allows you to share a state across components/pages.

* Works for both Vue 2 and Vue 3
* Optional composition API
* The same API for SSR.
* TypeScript support
* Hot module replacement
* Plugins

## Basic example

Create a store:

```js
// stores/counter.js
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', {
  state: () => {
    return {
      count: 0,
    }
  },
  // could also be defined as
  // state: () => ({ count: 0 })
  actions: {
    increment() {
      this.count++
    },
  },
})
```

And then you use it in a component:

```js
import { useCounterStore } from '@/stores/counter'

export default {
  setup() {
    const counter = useCounterStore()
    counter.count++

    // with autocompletion
    counter.$patch({ count: counter.count + 1 })
    // or using a action instead
    counter.increment()
  },
}
```

::: playground#vue Basic example

@file App.vue

```vue
<script setup>
import { useCounterStore } from './counterStore.js'

const counter = useCounterStore()
counter.count++

counter.$patch({
  count: counter.count + 1,
})
counter.increment()
</script>

<template>
  <div>Count: {{ counter.count }}</div>
</template>
```

@file counterStore.js

```js
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', {
  state: () => {
    return {
      count: 0,
    }
  },
  actions: {
    increment() {
      this.count++
    },
  },
})
```

@setting

```json
{
  "service": "https://play.zhaobc.site"
}
```

:::

You can even use a function (similar to a component `setup()`) to define a Store for more advanced use cases:

```js
export const useCounterStore = defineStore('counter', () => {
  const count = ref(0)
  function increment() {
    count.value++
  }

  return {
    count,
    increment,
  }
})
```

::: playground#vue setup example

@file App.vue

```vue
<script setup>
import { useCounterStore } from './counterStore.js'

const counter = useCounterStore()
counter.count++

counter.$patch({
  count: counter.count + 1,
})
counter.increment()
</script>

<template>
  <div>Count: {{ counter.count }}</div>
</template>
```

@file counterStore.js

```js
import { ref } from 'vue'
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', () => {
  const count = ref(0)
  function increment() {
    count.value++
  }

  return {
    count,
    increment,
  }
})
```

@setting

```json
{
  "service": "https://play.zhaobc.site"
}
```

:::

If you are still not into `setup()` and Composition API,
don't worry, Pinia also support a similar set of map helpers like Vuex.
You define stores the same way but then use `mapStores()`, `mapState()`, or `mapActions()`:

```js
const useCounterStore = defineStore('counter', {
  state: () => ({ count: 0 }),
  getters: {
    double: state => state.count * 2,
  },
  actions: {
    increment() {
      this.count++
    },
  },
})

const useUserStore = defineStore('user', {
  // ...
})

export default {
  computed: {
    // other computed properties
    // ...
    // gives access to this.counterStore and this.userStore
    ...mapStores(useCounterStore, useUserStore),
    // gives read access to this.count and this.double
    ...mapState(useCounterStore, ['count', 'double']),
  },
  methods: {
    // gives access to this.increment()
    ...mapActions(useCounterStore, ['increment']),
  },
}
```

::: playground#vue Option API example

@file App.vue

```vue
<script>
import { mapActions, mapState, mapStores } from 'pinia'

import { useCounterStore } from './counterStore.js'
import { useUserStore } from './userStore.js'

export default {
  computed: {
    ...mapStores(useCounterStore, useUserStore),
    ...mapState(useCounterStore, ['count', 'double']),
  },
  methods: {
    ...mapActions(useCounterStore, ['increment']),
  },
}
</script>

<template>
  <div>
    <div>Hi {{ userStore.name }}, age: {{ userStore.age }}</div>
    <div>Count: {{ count }}, double: {{ double }}</div>
    <button @click="increment">increment</button>
  </div>
</template>
```

@file counterStore.js

```js
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', {
  state: () => ({
    count: 0,
  }),
  getters: {
    double: state => state.count * 2,
  },
  actions: {
    increment() {
      this.count++
    },
  },
})
```

@file userStore.js

```js
import { defineStore } from 'pinia'

export const useUserStore = defineStore('user', {
  state: () => ({
    name: 'zhaobc',
    age: 18,
    isLogin: false,
    roles: [],
  }),
  getters: {
    isAdmin: state => state.roles.includes('admin'),
  },
  actions: {
    login() {
      this.isLogin = true
    },
  },
})
```

@setting

```json
{
  "service": "https://play.zhaobc.site"
}
```

:::

## A more realistic example

Here is a more complete example of the API you will be using with Pinia with types even in JavaScript.

```js
import { defineStore } from 'pinia'

export const todos = defineStore('todos', {
  state: () => ({
    /** @type {{ text: string, id: number, isFinished: boolean }[]} */
    todos: [],
    /** @type {'all' | 'finished' | 'unfinished'} */
    filter: 'all',
    // type will be automatically inferred to number
    nextId: 0,
  }),
  getters: {
    finishedTodos(state) {
      // autocompletion
      return state.todos.filter(todo => todo.isFinished)
    },
    unfinishedTodos(state) {
      return state.todos.filter(todo => !todo.isFinished)
    },
    /**
     * @returns  {{ text: string, id: number, isFinished: boolean }[]}
     */
    filteredTodos(state) {
      if (this.filter === 'finished') {
        // call other getters with autocompletion
        return this.finishedTodos
      } else if (this.filter === 'unfinished') {
        return this.unfinishedTodos
      }
      return this.todos
    },
  },
  actions: {
    // any amount of arguments, return a promise or not
    addTodo(text) {
      // you can directly mutate the state
      this.todos.push({
        text,
        id: this.nextId++,
        isFinished: false,
      })
    },
  },
})
```

## Comparison with Vuex

Compared to Vuex, Pinia provides a simpler API with less ceremony, offers Composition-API-style APIs,
and most importantly, has solid type inference support when used with TypeScript.

### Comparison with Vuex 3.x/4.x

> Vuex 3.x is Vuex for Vue 2 while Vuex 4.x is for Vue 3

Pinia API is very different from Vuex ≤4, namely:

* Mutations no longer exist
* TypeScript support
* No more magic strings to inject
* No need to dynamically add stores, they are all dynamic by default
* No more nested structuring of modules, Pinia offers a flat structuring by design
* No namespaced modules. Given the flat architecture of stores, "namespacing" stores is inherent to how they are defined and you could say all stores are namespaced.

For more detailed instructions on how to convert an existing Vuex ≤4 project to use Pinia, see the [Migration from Vuex Guide](https://pinia.vuejs.org/cookbook/migration-vuex.html).

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3-book/index.md'
---
# Vue.js 设计与实现

## 前言

记录 Vue.js 设计与实现的部分学习笔记。

## 第一篇 框架设计概览

* [第 1 章 权衡的艺术](./chapter01.md)
* [第 2 章 框架设计的核心要素](./chapter02.md)
* [第 3 章 Vue.js 3 的设计思路](./chapter03.md)

## 第二篇 响应系统

* [第 4 章 响应系统的作用与实现](./chapter04.md)

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3-book/chapter01.md'
---
# 第 1 章 权衡的艺术

## 1.1 命令式和声明式

从范式上来看，视图层框架通常分为命令式和声明式。

* 命令式**关注过程**
* 声明式**关注结果**

早年流行的 jQuery 是典型的命令式框架，Vue.js 是声明式框架。

例如，我们把下面的这段话翻译成对应的代码：

```txt
- 获取 id 为 app 的 div 标签
- 它的文本内容为 hello world
- 为其绑定点击事件
- 当点击时弹出提示：ok
```

jQuery 代码：

```js
$('#app')
  .text('hello world')
  .on('click', () => {
    alert('ok')
  })
```

原生 JavaScript 代码：

```js
const div = document.querySelector('#app')
div.innerText = 'hello world'
div.addEventListener('click', () => {
  alert('ok')
})
```

以上代码本身是在描述“做事的过程”。

Vue.js 代码：

```vue
<div
  @click="
    () => {
      alert('ok')
    }
  "
>hello world</div>
```

可以看到，我们提供的是一个“结果”，至于如何实现这个“结果”，我们并不关心。实现这个“结果”，是 Vue.js 帮我们实现的，它内部是**命令式**的，而暴露给用户的却更加**声明式**。

## 1.2 性能与可维护性的权衡

命令式和声明式各有优缺点，在框架设计方面，则体现在性能与可维护性的权衡。这里先抛出一个结论：**声明式代码的性能不优于命令式代码的性能**。

**毕竟框架本省就是封装了命令式代码才实现了面向用户的声明式**。

## 1.3 虚拟 DOM 的性能到底如何

性能：**声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗**

如果我们能够**最小化找出差异的性能消耗**，就可以让声明式代码的性能无限接近命令式的性能。

涉及 DOM 的运算要远比 JavaScript 层面的计算性能差。

虚拟 DOM 在创建页面时的性能：**创建 JavaScript 对象的计算量 + 创建真实 DOM 的计算量**

虚拟 DOM 在更新页面时的性能：**创建新的 JavaScript 对象 + Diff + 渲染 HTML 字符串**

## 1.4 运行时和编译时

设计框架的三种选择：

* 纯运行时
* 运行时 + 编译时
* 编译时

设计一个运行时框架，为它提供一个 Render 函数，Render 函数根据用户提供的树形结构的数据对象，渲染成 DOM 元素。

规定树形结构的数据对象如下：

```js
const obj = {
  tag: 'div',
  children: [
    {
      tag: 'span',
      children: 'hello world',
    },
  ],
}
```

每个对象有两个属性：

* tag 代表标签名称
* children 即可以是一个数据组（代表子节点），也可以直接是一个文本（代表文本节点）

Render 函数如下：

```js
function Render(obj, root) {
  const el = document.createElement(obj.tag)
  if (typeof obj.children === 'string') {
    const text = document.createTextNode(obj.children)
    el.appendChild(text)
  } else if (obj.children) {
    // 数组，递归调用Render，使用el作为root参数
    obj.children.forEach(child => Render(child, el))
  }

  //  将元素添加到root
  root.appendChild(el)
}
```

使用

```js
Render(obj, document.body)
```

下面内容为代码演示结果

:::normal-demo 运行时 Render 函数示例

```html
<div id="code-demo-render-basic"></div>
```

```js
const obj = {
  tag: 'div',
  children: [
    {
      tag: 'span',
      children: 'hello world',
    },
  ],
}

function Render(obj, root) {
  const el = window.document.createElement(obj.tag)
  if (typeof obj.children === 'string') {
    const text = window.document.createTextNode(obj.children)
    el.appendChild(text)
  } else if (obj.children) {
    // 数组，递归调用Render，使用el作为root参数
    obj.children.forEach(child => Render(child, el))
  }

  //  将元素添加到root
  root.appendChild(el)
}

Render(obj, window.document.querySelector('#code-demo-render-basic'))
```

:::

::: warning
本主题的代码演示采用了 `ShadowRoot` 方式，将代码演示和文档的主 DOM 树分开渲染。
所以，代码中的 `document` 会被定义为 演示代码块的一个 `ShadowRoot` \[^shadowroot]，
`document.createElement` 会报错，没法直接显示代码演示的结果。

本例直接使用了 `window.document` 来强制使用文档的主 DOM ，
为了能看到输出结果，在代码演示的外面，加了一个 id 为 `code-demo-render-basic` 的 `div`。
:::

上面的 Render 函数虽然可以根据树形结构数据渲染内容，但是手写树形结构数据太麻烦，而且不直观，能够用 HTML 标签的方式来描述就好了。

为了满足这个需求，考虑加入编译手段，把 HTML 标签编译成树形结构就可以继续使用 Render 函数了。

于是，可以考虑写一个 Compiler 函数，配合 Render 函数使用。这样我们的框架就编程了**运行时 + 编译时**。

## 1.5 总结

* 讨论了声明式和命令式的区别
* 讨论了虚拟 DOM 的性能
  声明式的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗
* 介绍了运行时和编译时，并且可以看出 Vue.js 3 是一个编译时 + 运行时的框架

\[^shadowroot]: Shadow DOM API 的 [ShadowRoot](https://developer.mozilla.org/zh-CN/docs/Web/API/ShadowRoot) 接口是一个 DOM 子树的根节点, 它与文档的主 DOM 树分开渲染。

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3-book/chapter02.md'
---
# 第 2 章 框架设计的核心要素

## 2.1 提升用户的开发体验

在框架设计和开发过程中，提供友好的警告信息至关重要。

Vue.js 3 中为了方便的在控制台输出 `ref` 数据，提供了自定义的 formatter，在 `initCustomFormatter` 函数中。

在 Chrome 中，打开 DevTools 的设置，勾选 "Console" -> "Enable custom formatters" 开启。

## 2.2 控制框架代码的体积

框架的大小也是衡量框架的标准之一。

Vue.js 3 的源代码中，每个 `warn` 函数的调用都会配合 `__DEV__` 常量的检查，例如：

```js
if (__DEV__ && !res) {
  warn(
    `Failed to mount app: mount target selector "${container}"` returned null.
  )
}
```

Vue.js 使用 rollup.js 对项目进行构建，这里的 `__DEV__` 常量实际上是通过 rollup.js 的插件配置来预定义的，其功能类似于 webpack 中的 DefinePlugin 插件。

针对不同的环境，比如开发环境和生产环境，把 `__DEV__` 替换成 `true` 和 `false` 来控制这块代码的执行与否。
当 `__DEV__` 为 `false` 时，这段代码永远都不会执行，被认为是 dead code, 它不会出现在最终产物中，在构建资源的时候就会被移除。

这样，我们就做到了**在开发环境中为用户提供友好的警告信息的同时，不会增加生产环境代码的体积。**。

## 2.3 框架要做到良好的 Tree-Shaking

简单来说，Tree-Shaking 指的是消除那些永远不会执行的代码，也就是排除 dead code。

想要实现 Tree-Shaking ，必须满足一个条件，即模块必须是 ESM(ES Module) ，因为 Tree-Shaking 依赖 ESM 的静态结构。

使用 rollup 打包 esm:

```js
npx rollup input.js -f esm -o bundle.js
```

这句命令的意思是，以 input.js 文件为入口，输出 ESM，输出的文件叫 bundle.js。

Tree-Shaking 的第二个关键点 —— 副作用。如果一个函数调用会产生副作用，那么就不能将其移除。

简单地说，副作用就是，当调用函数的时候会对外部产生影响，例如修改了全局变量。

而到底会不会产生副作用，只有代码真正运行的时候才会知道。

JavaScript 本身是动态语言，静态地分析 JavaScript 代码很困难，
因此，像 rollup.js 这类的工具会提供一个机制，让我们能明确的告诉 rollup.js：
“放心吧，这段代码不会产生副作用，你可以移除它。”

如下所示：

```js
import { foo } from './utils'
/*#__PURE__*/ foo()
```

注意注释代码 `/*#__PURE__*/`，其作用就是告诉 rollup.js，对应 foo 函数的调用不会产生副作用，你可以放心地对其进行 Tree-Shaking。

因此，在编写框架时，合理使用`/*#__PURE__*/`注释，可以做到更好的 Tree-Shaking，Vue.js 3 中大量使用了该注释。

例如：

```js
export const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS)
```

这样编写代码也不会造成很大的心智负担，因为通常产生副作用的代码都是模块内的顶级调用。

什么是顶级调用？如下所示：

```js
foo() // 顶级调用

function bar() {
  foo() // 函数内调用
}
```

只要 bar 没有被调用，自然不会产生副作用。

## 2.4 框架应该输出怎样的构建产物

在 HTML 中直接使用时，需要输出一种叫 IIFE 格式的资源。

```html
<body>
  <script src="/path/to/vue.js"></script>
  <script>
    const { createApp } = Vue
    // ...
  </script>
</body>
```

IIFE 的全称是 Immediately Invoked Function Expression，即“立即调用的函数表达式”，例如：

```js
;(function () {
  // ...
})()
```

实际上，vue.global.js 文件就是 IIFE 格式的资源，它的代码结构如下所示：

```js
var Vue = (function (exports) {
  // ...
  exports.createApp = createApp
  // ...
  return exports
})({})
```

这样当我们使用 \<script> 标签直接引入 vue.global.js 文件后，全局变量 Vue 就是可用的了。

现在主流浏览器对原生 ESM 支持也都不错，所以，可以直接用\<script type="module">标签引入 ESM 资源。

```js
<script type="module" src="/path/to/vue.esm-browser.js"></script>
```

除了可以直接使用\<script>标签引入外，还可以在 Node.js 中通过 require 语句引用：

```js
const Vue = require('vue')
```

## 2.5 特性开关

在设计框架时，框架会给用户提供诸多特性或功能。
比如，我们提供了 A, B, C 三个特性给用户，同时还提供了 a, b, c 三个对应的特性开关，
用户可以通过设置 a, b, c 为 true 或 false 来开启或关闭对应的特性。

这样会带来很多好处：

* 对于用户关闭的特性，利用 Tree-Shaking 减小打包体积
* 该机制为框架设计带来了灵活性，通过特性开关任意为框架添加新的特性，而不担心资源体积变大。
  同时，当框架升级时，也可以通过特性开关来支持遗留 API 。

怎么实现特性开关呢？原理和上文提到的`__DEV__`常量一样，本质上是利用 rollup.js 的预定义常量插件来实现。

## 2.6 错误处理

框架错误处理机制的好坏，直接决定了用户应用程序的健壮性，还决定了用户开发时处理错误的心智负担。

异常处理，可以通过 `try...catch` 来让用户自己处理，但这样会增加用户的负担，那么我们可以做统一异常处理。

例如下面的代码：

```js
export default {
  foo(fn) {
    try {
      fn && fn()
    } catch (e) {
      // ...
    }
  },
  bar(fn) {
    try {
      fn && fn()
    } catch (e) {
      // ...
    }
  },
}
```

上面的每个函数都加了 `try...catch` ,实际上，我们可以更进一步将错误处理封装为一个函数，假设叫它 callWithErrorHandling:

```js
export default {
  foo(fn) {
    callWithErrorHandling(fn)
  },
  bar(fn) {
    callWithErrorHandling(fn)
  },
}

function callWithErrorHandling(fn) {
  try {
    fn && fn()
  } catch (e) {
    console.log(e)
  }
}
```

可以看到，代码变得简洁多了。但简洁不是目的，这么做真正的好处是，我们能为用户提供统一的错误处理接口，如下所示：

```js
let handleError = null
export default {
  foo(fn) {
    callWithErrorHandling(fn)
  },
  // 用户可以调用改函数注册统一的错误处理函数
  registerErrorHandler(fn) {
    handleError = fn
  },
}
function callWithErrorHandling(fn) {
  try {
    fn && fn()
  } catch (e) {
    // 将捕获的错误传递给用户的错误处理程序
    handleError(e)
  }
}
```

我们提供了 registerErrorHandler 函数，用户可以用它来注册错误处理程序。

这样用户侧的代码就会变的非常简洁且健壮：

```js
import utils from 'utils'
// 注册错误处理程序
utils.registerErrorHandler(e => {
  console.log(e)
})
utils.foo(() => {
  // ...
})
utils.bar(() => {
  // ...
})
```

这时，错误处理的能力完全由用户控制，用户可以选择忽略错误，也可以调用上报程序，将错误上报给监控系统。

实际上，这就是 Vue.js 的原理，可以在源码中搜索到 callWithErrorHandling 函数。
另外，在 Vue.js 中，我们也可以注册统一的错误处理函数：

```js
import App from 'App.vue'
const app = createApp(App)
app.config.errorHandler = () => {
  // 错误处理程序
}
```

## 2.7 良好的 TypeScript 类型支持

框架使用 TS 编写，不等于对 TS 类型友好，其实这是两件完全不同的事。示例如下：

```ts
function foo(val: any) {
  return val
}
const res = foo('str')
```

当调用 foo 函数时，如果传递了参数'str'，按照之前的分析，得到的结果 res 也应该是字符串类型，然而并不是。
为了达到理想状态，我们只需要对 foo 函数做简单的修改即可：

```ts
function foo<T extends any>(val: T): T {
  return val
}
```

在写框架时，为了做到完善的 TS 类型支持很不容易，许岙付出相当大的努力。

## 2.8 总结

* 框架设计需要提供友好的警告信息至关重要
* 利用 Tree-Shaking 和 构建工具预定义常量的能力，实现代码体积的可控性
* 可以利用 `/*#__PURE__*/`来辅助构建工具进行 Tree-Shaking
* 框架需要提供多种输出产物
  * IIFE 格式 立即执行的函数表达式
  * ESM 格式
    * esm-browser.js 用于浏览器
    * esm-bundler.js 用于打包工具
* 框架会提供多种能力或功能，处于灵活性和兼容性的考虑，可以通过特性开关来实现
* 框架需要为用户提供统一的错误处理接口
* 做到完事的类型支持，需要花费很多的时间和精力

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3-book/chapter03.md'
---
# 第 3 章 Vue.js 3 的设计思路

## 3.1 声明式地描述 UI

Vue.js 3 的声明式解决方案

* 使用与 HTML 标签 一致的方式描述**DOM 元素**
* 使用与 HTML 标签 一致的方式描述**属性**
* 使用`:`或`v-bind`描述动态绑定的**属性**
* 使用`@`或`v-on`来描述**事件**
* 使用与 HTML 标签 一致的方式描述**层级结构**

除了使用**模板**来声明式地描述 UI 之外，我们还可以用 JavaScript 对象来描述，如下所示：

```js
const title = {
  // 标签名称
  tag: 'h1',
  // 标签属性
  props: {
    onClick: handler,
  },
  // 子节点
  children: [
    {
      tag: 'span',
    },
  ],
}
```

对应的 Vue.js 模板：

```vue
<h1 @click="handler"><span></span></h1>
```

如果要动态生成 `h1`- `h6` 标签的话，可以设置一个变量 `tag: h${level}`，这时 JavaScript 的形式就比较灵活。

Vue.js 3 除了支持使用模板描述 UI 外， 还支持使用虚拟 DOM 描述 UI 。

```js
import { h } from 'vue'

export default {
  render() {
    return h('h1', { onClick: handler }) // 虚拟 DOM
  },
}
```

等价于：

```js
import { h } from 'vue'

export default {
  render() {
    return {
      tag: 'h1',
      props: {
        onClick: handler,
      },
    }
  },
}
```

上面的 `h` 函数是一个辅助创建虚拟 DOM 的工具函数。Vue.js 会根据组件的**渲染函数**的返回值拿到虚拟 DOM，然后把组件的内容渲染出来。
上面代码中的`render`函数就是渲染函数。

## 3.2 初识渲染器

虚拟 DOM 是 JavaScript 对象来描述真实 DOM 结构，然后通过**渲染器**将虚拟 DOM 渲染成真实 DOM。

渲染器非常重要，大家平时编写的 Vue.js 组件都是依赖渲染器来工作的。

假设我们有如下的虚拟 DOM:

```js
const vnode = {
  tag: 'div',
  props: {
    onClick: () => alert('hello'),
  },
  children: 'click me',
}
```

接下来，编写一个**渲染器**，把上面的虚拟 DOM 渲染为真实 DOM:

```js
function renderer(vnode, container) {
  // 使用vnode.tag作为标签名称创建 DOM
  const el = document.createElement(vnode.tag)
  // 遍历 vnode.props，将属性，事件添加到 DOM 元素
  for (const key in vnode.props) {
    if (/^on/.test(key)) {
      // 如果 key 以 on 开头，说明是事件
      el.addEventListener(
        key.substr(2).toLowerCase(), // 事件名称 onClick -> click
        vnode.props[key] // 事件处理函数
      )
    }
  }

  // 处理 children
  if (typeof vnode.children === 'string') {
    // 如果 children 是 字符串，说明它是文本子节点
    el.appendChild(document.createTextNode(vnode.children))
  } else if (Array.isArray(vnode.children)) {
    // 递归调用 renderer 函数，渲染子节点
    node.children.forEach(child => renderer(child, el))
  }

  // 将元素添加到挂载点下
  container.appendChild(el)
}
```

使用：

```js
renderer(vnode, document.body)
```

::: note 执行效果

::: normal-demo 渲染器示例

```html
<div id="renderer-demo1"></div>
```

```js
const vnode = {
  tag: 'div',
  props: {
    onClick: () => alert('hello'),
  },
  children: 'click me',
}

function renderer(vnode, container) {
  // 使用vnode.tag作为标签名称创建 DOM
  const el = window.document.createElement(vnode.tag)
  // 遍历 vnode.props，将属性，事件添加到 DOM 元素
  for (const key in vnode.props) {
    if (/^on/.test(key)) {
      // 如果 key 以 on 开头，说明是事件
      el.addEventListener(
        key.substr(2).toLowerCase(), // 事件名称 onClick -> click
        vnode.props[key] // 事件处理函数
      )
    }
  }

  // 处理 children
  if (typeof vnode.children === 'string') {
    // 如果 children 是 字符串，说明它是文本子节点
    el.appendChild(window.document.createTextNode(vnode.children))
  } else if (Array.isArray(vnode.children)) {
    // 递归调用 renderer 函数，渲染子节点
    node.children.forEach(child => renderer(child, el))
  }

  // 将元素添加到挂载点下
  container.appendChild(el)
}

renderer(vnode, window.document.querySelector('#renderer-demo1'))
```

:::

## 3.3 组件的本质

一句话总结：**组件就是一组 DOM 元素的封装**。

这组 DOM 元素就是组件要渲染的内容，因此我们可以定义一个函数来代表组件，而函数的返回值就代表组件要渲染的内容：

```js
const MyComponent = function () {
  return {
    tag: 'div',
    props: {
      onClick: () => alert('hello'),
    },
    children: 'click me',
  }
}
```

用虚拟 DOM 来描述组件：

```js
const vnode = {
  tag: MyComponent,
}
```

就想 `tag: 'div'` 一样，用 `tag: MyComponent` 来描述组件。为了能渲染组件，修改前面的 renderer 函数：

```js
function renderer(vnode, container) {
  if (typeof vnode.tag === 'string') {
    // 说明 vnode 描述的是元素
    mountElement(vnode, container)
  } else if if (typeof vnode.tag === 'function') {
    // 说明 vnode 描述的是组件
    mountComponent(vnode, container)
  }
}

function mountElement(vnode, container) {
  // 使用vnode.tag作为标签名称创建 DOM
  const el = document.createElement(vnode.tag)
  // 遍历 vnode.props，将属性，事件添加到 DOM 元素
  for (const key in vnode.props) {
    if (/^on/.test(key)) {
      // 如果 key 以 on 开头，说明是事件
      el.addEventListener(
        key.substr(2).toLowerCase(), // 事件名称 onClick -> click
        vnode.props[key] // 事件处理函数
      )
    }
  }

  // 处理 children
  if (typeof vnode.children === 'string') {
    // 如果 children 是 字符串，说明它是文本子节点
    el.appendChild(document.createTextNode(vnode.children))
  } else if (Array.isArray(vnode.children)) {
    // 递归调用 renderer 函数，渲染子节点
    node.children.forEach((child) => renderer(child, el))
  }

  // 将元素添加到挂载点下
  container.appendChild(el)
}

function mountComponent(vnode, container) {
  //调用组件函数，获取组件要渲染的内容（虚拟DOM）
  const subtree = vnode.tag()
  // 递归调用 renderer 渲染 虚拟 DOM
  renderer(subtree, container)
}
```

组件也不一定是函数，也可以是对象：

```js
const MyComponent2 = {
  render() {
    return {
      tag: 'div',
      props: {
        onClick: () => alert('hello'),
      },
      children: 'click me',
    }
  },
}
```

对应的 renderer 函数修改：

```js
function renderer(vnode, container) {
  if (typeof vnode.tag === 'string') {
    // 说明 vnode 描述的是元素
    mountElement(vnode, container)
  } else if (typeof vnode.tag === 'object') {
    // 说明 vnode 描述的是组件
    mountComponent(vnode, container)
  }
}
```

接着修改 mountComponent 函数：

```js
function mountComponent(vnode, container) {
  //调用组件函数，获取组件要渲染的内容（虚拟DOM）
  const subtree = vnode.tag.render()
  // 递归调用 renderer 渲染 虚拟 DOM
  renderer(subtree, container)
}
```

下面为改造后的示例：

::: note 示例运行结果

::: normal-demo 组件示例

```html
<div id="component-function-demo"></div>
<div id="component-object-demo"></div>
```

```js
// 函数组件
const MyComponent = function () {
  return {
    tag: 'div',
    props: {
      onClick: () => alert('hello'),
    },
    children: 'click me',
  }
}

// 对象组件
const MyComponent2 = {
  render() {
    return {
      tag: 'div',
      props: {
        onClick: () => alert('hello'),
      },
      children: 'click me',
    }
  },
}

const vnode1 = {
  tag: MyComponent,
}

const vnode2 = {
  tag: MyComponent2,
}

// 渲染函数
function renderer(vnode, container) {
  if (typeof vnode.tag === 'string') {
    // 说明 vnode 描述的是元素
    mountElement(vnode, container)
  } else if (typeof vnode.tag === 'function') {
    // 说明 vnode 描述的是组件
    mountFunctionalComponent(vnode, container)
  } else if (typeof vnode.tag === 'object') {
    // 说明 vnode 描述的是组件
    mountObjectComponent(vnode, container)
  }
}

function mountElement(vnode, container) {
  // 使用vnode.tag作为标签名称创建 DOM
  const el = window.document.createElement(vnode.tag)
  // 遍历 vnode.props，将属性，事件添加到 DOM 元素
  for (const key in vnode.props) {
    if (/^on/.test(key)) {
      // 如果 key 以 on 开头，说明是事件
      el.addEventListener(
        key.substr(2).toLowerCase(), // 事件名称 onClick -> click
        vnode.props[key] // 事件处理函数
      )
    }
  }

  // 处理 children
  if (typeof vnode.children === 'string') {
    // 如果 children 是 字符串，说明它是文本子节点
    el.appendChild(window.document.createTextNode(vnode.children))
  } else if (Array.isArray(vnode.children)) {
    // 递归调用 renderer 函数，渲染子节点
    node.children.forEach(child => renderer(child, el))
  }

  // 将元素添加到挂载点下
  container.appendChild(el)
}

function mountFunctionalComponent(vnode, container) {
  //调用组件函数，获取组件要渲染的内容（虚拟DOM）
  const subtree = vnode.tag()
  // 递归调用 renderer 渲染 虚拟 DOM
  renderer(subtree, container)
}

function mountObjectComponent(vnode, container) {
  //调用组件函数，获取组件要渲染的内容（虚拟DOM）
  const subtree = vnode.tag.render()
  // 递归调用 renderer 渲染 虚拟 DOM
  renderer(subtree, container)
}

// 使用
renderer(vnode1, window.document.querySelector('#component-function-demo'))
renderer(vnode2, window.document.querySelector('#component-object-demo'))
```

:::

## 3.4 模板的工作原理

无论是手续虚拟 DOM （渲染函数）还是使用模板，都属于声明式地描述 UI，Vue.js 同时支持 ，这是因为 Vue.js 框架中有**编译器**。

编译器的作用就是将模板编译为渲染函数，比如：

```vue
<div @click="handler">
  click me
</div>
```

编译器生成的渲染函数：

```js
render() {
  return h('div', { onClick: handler }, 'click me')
}
```

对应 .vue 文件来说：

```vue
<template>
  <div @click="handler">click me</div>
</template>

<script>
export default {
  data() {
    /* ... */
  },
  methods: {
    handler: () => {
      /* ... */
    },
  },
}
</script>
```

将被编译为：

```js
export default {
  data() {
    /* ... */
  },
  methods: {
    handler: () => {
      /* ... */
    },
  },
  render() {
    return h('div', { onClick: handler }, 'click me')
  },
}
```

无论是使用模板还是直接手写渲染函数，对于一个组件来说，它要渲染的内容最终都是通过渲染函数产生的。

## 3.5 Vue.js 是各个模块组成的有机整体

Vue.js 中**编译器**和**渲染器**会配合工作，以提升性能。

比如，编译器有分析动态内容的能力，能识别哪些是静态属性，哪些是动态属性，生成代码时附带这些信息，供渲染器使用，比如 `patchFlags`。

## 3.6 总结

* Vue.js 是声明式框架，可以用模板方式描述，也可以用渲染函数（虚拟 DOM）来描述
* 渲染器的作用是把虚拟 DOM 对象渲染为真实 DOM 元素
* 组件的本质是一组虚拟 DOM 的封装，它可以是一个返回虚拟 DOM 的函数，也可以是一个对象
* Vue.js 的模板 会被编译器编译为渲染函数

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3-book/chapter04.md'
---
# 第 4 章 响应系统的作用与实现

响应系统是 Vue.js 的重要组成部分，Vue.js 3 采用 Proxy 实现响应式数据。

## 4.1 响应式数据与副作用函数

副作用函数是指会产生副作用的函数。副作用函数的执行会直接或间接影响其他的变量或其他函数的执行。

如下所示：

```js
const state = { text: null }
const obj = { text: 'hello world' }
function effect() {
  state.text = obj.text
  document.body.innerText = obj.text
}
```

effect 执行会读取 obj，并设置 state，以及更改 DOM 元素，这个就是副作用。

但是，obj.text 改了之后，并不会自动执行 effect 函数。

## 4.2 响应式数据的基本实现

观察可以看出：

* 副作用函数 effect 执行时，会出发 obj.text 的**读取**操作
* 修改 obj.text 时，会触发**设置**操作

如果我们能拦截一个对象的读取和设置操作，那么就能做一些额外的操作。

在 ES2015 之前只能通过 Object.defineProperty 函数实现，这也是 Vue.js 2 所采用的方式。在 ES2015+ 中，可以使用代理对象 Proxy 来实现，这也是 Vue.js 3 所采用的方式。

::: note Proxy 示例

::: normal-demo Proxy 示例

```html
<div id="effect-proxy-demo"></div>
<button onclick="changeText()">Change Text</button>
```

```js
// 存储副作用函数的桶
const bucket = new Set()

// 原始数据
const data = { text: 'hello world' }
// 对原始数据的代理
const obj = new Proxy(data, {
  // 拦截读取操作
  get(target, key) {
    // 将副作用函数 effect 添加到副作用函数桶中
    bucket.add(effect)
    // 返回属性值
    return target[key]
  },
  // 拦截设置操作
  set(target, key, newVal) {
    // 设置属性值
    target[key] = newVal
    // 把副作用函数从桶中取出来并执行
    bucket.forEach(fn => fn())
    // 返回 true 代表 设置成功
    return true
  },
})

// 副作用函数
function effect() {
  window.document.querySelector('#effect-proxy-demo').innerText = obj.text
}

// 执行副作用函数，触发读取
effect()

function changeText() {
  obj.text = 'hello vue3'
}
```

:::

上述示例，可以达到响应式的结果。

## 4.3 设计一个完善的响应式系统

从上一节中看出，一个响应式系统的工作流如下：

* 当**读取**操作发生时，将副作用收集到桶中
* 当**设置**操作发生时，从桶中取出副作用函数并执行

上节中的副作用函数 effect 硬编码，不合适，我们要做的是，哪怕副作用是匿名函数也能够被正确的收集。
为了实现这一点，我们需要提供一个用来注册副作用函数的机制，如下所示：

::: note 改进后的示例

::: normal-demo 改进后的示例

```html
<div id="effect-proxy-demo2"></div>
<button onclick="changeText()">Change Text</button>
```

```js
// 用一个全局变量存储被注册的副作用函数
let activeEffect

// effect 函数用于注册副作用函数
function effect(fn) {
  // 当调用 effect 注册副作用函数时，将副作用函数 fn 赋值给 activeEffect
  activeEffect = fn
  // 执行副作用函数
  fn()
}

// 存储副作用函数的桶
const bucket = new Set()

// 原始数据
const data = { text: 'hello world' }
// 对原始数据的代理
const obj = new Proxy(data, {
  // 拦截读取操作
  get(target, key) {
    // 将 activeEffect 中存储的副作用函数收集到桶中
    if (activeEffect) {
      // 新增
      bucket.add(activeEffect)
    }
    // 返回属性值
    return target[key]
  },
  // 拦截设置操作
  set(target, key, newVal) {
    // 设置属性值
    target[key] = newVal
    // 把副作用函数从桶中取出来并执行
    bucket.forEach(fn => fn())
    // 返回 true 代表 设置成功
    return true
  },
})

// 使用 effect 注册副作用函数
effect(() => {
  // 匿名副作用函数
  console.log('effect run') // 会打印 2 次，注册时立即执行了一次，后面更改 obj.notExist 时会再执行一次
  window.document.querySelector('#effect-proxy-demo2').innerText = obj.text
})

function changeText() {
  obj.notExist = 'hello vue3'
}
```

:::

上面代码可以看出，匿名副作用函数内部读取了 obj.text 的值，于是匿名函数与字段 obj.text 之间建立了响应联系。
但是，点击 change text 时，在匿名副作用内并没有读取 obj.notExist 属性的值，所以，理论上字段 obj.notExist 并没有与副作用建立响应联系。
因此，点击按钮时，不应该出发匿名副作用，这是不正确的，为了解决这个问题，我们应该重新设计桶。

在上例中，我们**没有在副作用函数与被操作的目标字段之间建立明确的联系**。当读取属性时，无论读取的是哪一个属性，都会把副作用函数收集到桶中；
当设置属性时，也都会把桶中的副作用函数取出来并执行。解决办法只需要在副作用与被操作的字段直接建立联系。

Set 类型的桶，不能实现这个目的，需要使用 WeakMap 代替 Set 作为桶的数据结构。

::: note WeakMap 类型的桶

::: normal-demo WeakMap 类型的桶

```html
<div id="effect-proxy-weakmap"></div>
<button onclick="changeText()">Change Text</button>
```

```js
// 元素数据
const data = {
  ok: true,
  text: 'hello world',
}

// 存储副作用的桶
const bucket = new WeakMap()
let activeEffect

const obj = new Proxy(data, {
  // 拦截读取操作
  get(target, key) {
    // 将副作用函数 添加到桶中
    track(target, key)
    // 返回属性值
    return target[key]
  },
  // 拦截设置操作
  set(target, key, newVal) {
    // 设置属性值
    target[key] = newVal
    // 把副作用函数从桶中取出并执行
    trigger(target, key)
    return true
  },
})

// 在 get 拦截函数内调用 track 函数追踪变化
function track(target, key) {
  // 没有 activeEffect 直接返回
  if (!activeEffect) return
  // 根据 target 从桶中取得 depsMap，它也是一个 Map 类型，key: effects
  let depsMap = bucket.get(target)
  // 如果不存在 depsMap，则新建一个 Map 与 target 关联
  if (!depsMap) {
    bucket.set(target, (depsMap = new Map()))
  }
  // 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型
  // 里面存储着所有与当前 key 关联的副作用函数：effects
  let deps = depsMap.get(key)
  // 如果 deps 不存在，则同样新建一个 Set 与 key 关联
  if (!deps) {
    depsMap.set(key, (deps = new Set()))
  }
  // 最后将当前激活的副作用添加到桶中
  deps.add(activeEffect)
}

// 在 set 拦截函数内调用 trigger 函数出发变化
function trigger(target, key) {
  // 根据 target 从桶中取得 depsMap，它是 key: effects
  const depsMap = bucket.get(target)
  if (!depsMap) return
  // 根据 key 取得所有副作用函数
  const effects = depsMap.get(key)
  // 执行副作用函数
  effects && effects.forEach(fn => fn())
}

// effect 函数用于注册副作用函数
function effect(fn) {
  // 当调用 effect 注册副作用函数时，将副作用函数 fn 赋值给 activeEffect
  activeEffect = fn
  // 执行副作用函数
  fn()
}

// 使用 effect 注册副作用函数
effect(() => {
  // 匿名副作用函数
  console.log('effect run - weekmap') // 会打印 2 次，注册时立即执行了一次，后面更改 obj.text 时会再执行一次，obj.notExist 不执行
  window.document.querySelector('#effect-proxy-weakmap').innerText = obj.text
})

function changeText() {
  obj.text = 'hello vue3'
  obj.notExist = 'hello vue3'
}
```

:::

从上述代码中可以看出构建数据的方式，分别使用了 WeakMap, Map 和 Set:

* WeakMap 是 target: Map 键值对
* Map 是 target.key: effects （副作用） 键值对

那么，WeakMap 跟 Map 有什么区别呢？

WeakMap 对 key 是弱引用，WeakMap 的 key 是不可枚举的，不影响垃圾回收器的工作。
参考资料：[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)

::: normal-demo Map 和 WeakMap

请打开控制台查看：

```js
const map = new Map()
const weakmap = new WeakMap()

;(function () {
  const foo = { foo: 1 }
  const bar = { bar: 2 }

  map.set(foo, 1)
  weakmap.set(bar, 2)
})()

// 可以打印出 foo，说明 foo 没有被回收
console.log('map.keys', map.keys().next().value)
// WeakMap 无法获取 key，也就无法获取对象 bar
console.log('weakmap', weakmap)
```

:::

## 4.4 分支切换与 cleanup

什么是分支定义？先看下面的代码：

```js
const data = { ok: true, text: 'hello world' }
const obj = new Proxy(data, {
  /* ... */
})

effect(() => {
  document.body.innerText = obj.ok ? obj.text : 'not'
})
```

上面的三元表达式中，当字段 obj.ok 发送变化时，代码执行的分支就会跟着变化，这就是分支切换。

分支切换可能会产生遗留的副作用函数。上面的代码中，会触发 obj.ok 和 obj.text 的读取操作，所以会收集它们俩对应的副作用函数。

当 obj.ok 修改为 false 时，会触发副作用函数重新执行后，由于此时字段 obj.text 不会被读取，只会执行 obj.ok 的读取操作。
所以，理想情况下，副作用函数不应该被字段 obj.text 所对应的依赖集合收集。

遗留的副作用会导致不必要的更新。

但是上例中，obj.ok 改为 false 时，无论 obj.text 如何变，document.body.innerText 的值始终是 'not' 。
所以，最好的结果是，无论 obj.text 如何变，都不需要重新执行副作用函数。

解决这个问题的思路很简单，就是每次副作用执行时，我们可以先把它从所有与之关联的依赖集合中删除。

当副作用函数执行完毕后，会重新建立联系，但在新的联系中不会包含遗留的副作用函数。

要将一个副作用函数从所有与之关联的依赖集合中移除，需要明确有哪些依赖集合中包含它，因此，我们要重新设计副作用函数。

```js
// 用一个全局变量存储被注册的副作用函数
let activeEffect
function effect(fn) {
  const effectFn = () => {
    // 调用 cleanup 函数完成清除工作
    cleanup(effectFn)
    // 当 effectFn 执行时，将其设为当前激活的副作用函数
    activeEffect = effectFn
    fn()
  }
  // effectFn.deps 用来存储所有与该副作用函数相关联的依赖集合
  effectFn.deps = []
  // 执行副作用函数
  effectFn()
}

function track(target, key) {
  // 没有 activeEffect 直接返回
  if (!activeEffect) return
  // 根据 target 从桶中取得 depsMap，它也是一个 Map 类型，key: effects
  let depsMap = bucket.get(target)
  // 如果不存在 depsMap，则新建一个 Map 与 target 关联
  if (!depsMap) {
    bucket.set(target, (depsMap = new Map()))
  }
  // 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型
  // 里面存储着所有与当前 key 关联的副作用函数：effects
  let deps = depsMap.get(key)
  // 如果 deps 不存在，则同样新建一个 Set 与 key 关联
  if (!deps) {
    depsMap.set(key, (deps = new Set()))
  }
  // 把当前激活的副作用函数添加到依赖集合 deps 中
  deps.add(activeEffect)
  // deps 就是一个与当前副作用函数存在联系的依赖集合
  // 将其添加到 activeEffect.deps 数组中
  activeEffect.deps.push(deps)
}

function cleanup(effectFn) {
  // 遍历 effectFn 的 deps 数组
  for (let i = 0; i < effectFn.deps.length; i++) {
    // deps 是依赖集合
    const deps = effectFn.deps[i]
    // 将 effectFn 从依赖集合中移除
    deps.delete(effectFn)
  }
  // 最后需要重置 effectFn.deps 数组
  effectFn.deps.length = 0
}

function trigger(target, key) {
  const depsMap = bucket.get(target)
  if (!depsMap) {
    return
  }
  const effects = depsMap.get(key)
  // effects && effects.forEach(fn => fn()) // 删除，这个会导致死循环

  // 构造一个新的集合 effectToRun 然后变量它，用来遍历删除，避免死循环
  const effectToRun = new Set(effects)
  effectToRun.forEach(effectFn => effectFn())
}
```

在 trigger 中我们遍历 effects 集合，它是一个 Set 集合，当执行副作用函数时，会调用 cleanup 进行清除，实际上是从 effects 中将当前副作用函数剔除。
但是副作用函数的执行会导致其重新被收集，此时对于 effects 的遍历仍在进行，会引起死循环。

剪短的代码来表达：

```js
const set = new Set([1])

set.forEach(item => {
  set.delete(1)
  set.add(1)
  console.log('遍历中')
})
```

语言规范中对此有明确的说明：在调用 forEach 遍历 Set 集合时，如果一个值已经被访问过了，但该值被删除并重新添加到集合，
如果此时 forEach 遍历没有结束，那么该值会重新被访问。

因此，上面的代码会无限循环。解决办法也很简单，构造领一个 Set 集合并遍历它：

```js
const set = new Set([1])

const newSet = new Set(set)
newSet.forEach(item => {
  set.delete(1)
  set.add(1)
  console.log('遍历中')
})
```

::: note 分支切换与 cleanup demo 运行结果

::: normal-demo 分支切换与 cleanup demo

```html
<div id="effect-branch-cleanup"></div>
<button onclick="changeText()">Change Text</button>
<input
  type="checkbox"
  checked="obj.ok"
  onclick="changeOk(event.target.checked)"
/>Change OK
```

```js
// 存储副作用的桶
const bucket = new WeakMap()
// 用一个全局变量存储被注册的副作用函数
let activeEffect

function effect(fn) {
  const effectFn = () => {
    // 调用 cleanup 函数完成清除工作
    cleanup(effectFn)
    // 当 effectFn 执行时，将其设为当前激活的副作用函数
    activeEffect = effectFn
    fn()
  }
  // effectFn.deps 用来存储所有与该副作用函数相关联的依赖集合
  effectFn.deps = []
  // 执行副作用函数
  effectFn()
}

function track(target, key) {
  // 没有 activeEffect 直接返回
  if (!activeEffect) return
  // 根据 target 从桶中取得 depsMap，它也是一个 Map 类型，key: effects
  let depsMap = bucket.get(target)
  // 如果不存在 depsMap，则新建一个 Map 与 target 关联
  if (!depsMap) {
    bucket.set(target, (depsMap = new Map()))
  }
  // 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型
  // 里面存储着所有与当前 key 关联的副作用函数：effects
  let deps = depsMap.get(key)
  // 如果 deps 不存在，则同样新建一个 Set 与 key 关联
  if (!deps) {
    depsMap.set(key, (deps = new Set()))
  }
  // 把当前激活的副作用函数添加到依赖集合 deps 中
  deps.add(activeEffect)
  // deps 就是一个与当前副作用函数存在联系的依赖集合
  // 将其添加到 activeEffect.deps 数组中
  activeEffect.deps.push(deps)
}

function cleanup(effectFn) {
  // 遍历 effectFn 的 deps 数组
  for (let i = 0; i < effectFn.deps.length; i++) {
    // deps 是依赖集合
    const deps = effectFn.deps[i]
    // 将 effectFn 从依赖集合中移除
    deps.delete(effectFn)
  }
  // 最后需要重置 effectFn.deps 数组
  effectFn.deps.length = 0
}

function trigger(target, key) {
  const depsMap = bucket.get(target)
  if (!depsMap) {
    return
  }
  const effects = depsMap.get(key)
  // effects && effects.forEach(fn => fn()) // 删除，这个会导致死循环

  // 构造一个新的集合 effectToRun 然后变量它，用来遍历删除，避免死循环
  const effectToRun = new Set(effects)
  effectToRun.forEach(effectFn => effectFn())
}

// 元素数据
const data = {
  ok: true,
  text: 'hello world',
}

const obj = new Proxy(data, {
  // 拦截读取操作
  get(target, key) {
    // 将副作用函数 添加到桶中
    track(target, key)
    // 返回属性值
    return target[key]
  },
  // 拦截设置操作
  set(target, key, newVal) {
    // 设置属性值
    target[key] = newVal
    // 把副作用函数从桶中取出并执行
    trigger(target, key)
    return true
  },
})

// 使用 effect 注册副作用函数
effect(() => {
  // 匿名副作用函数
  console.log('effect run - branch-cleanup')
  window.document.querySelector('#effect-branch-cleanup').innerText = obj.ok
    ? obj.text
    : 'not'
})

function changeText() {
  obj.text = 'hello vue3'
  obj.notExist = 'hello vue3'
}

function changeOk(val) {
  obj.ok = val
}
```

:::

## 4.5 嵌套的 effect 与 effect 栈

effect 是可以发生嵌套的，例如：

```js
effect(function effectFn1() {
  effect(function effectFn2() {
    /* ... */
  })
})
```

effectFn1 里嵌套了 effectFn2，什么场景会有呢？比如，Foo 组件有 effect，Foo 组件里调用了 Bar 组件， Bar 里有 effect 的话，就会发送 effect 嵌套。

但是，前面的代码中，全局变量 activeEffect 只能存储一个，有嵌套时不能正确的恢复外层的副作用函数。

为了解决这个问题，我们需要一个副作用栈 effectStack，在副作用函数执行时，将当前副作用函数压入栈中，待副作用函数执行完毕后将其从栈中弹出，并始终让 activeEffect 指向栈顶的副作用函数。
代码如下：

```js
// 用一个全局变量存储被注册的副作用函数
let activeEffect
// effect 栈
let effectStack = []

function effect(fn) {
  const effectFn = () => {
    // 调用 cleanup 函数完成清除工作
    cleanup(effectFn)
    // 当调用 effect 注册副作用函数时，将副作用函数复制给 activeEffect
    activeEffect = effectFn
    // 在调用副作用函数之前，将当前副作用函数压入栈中
    effectStack.push(effectFn)
    fn()
    // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，
    // 并把 activeEffect 还原为之前的值
    effectStack.pop()
    activeEffect = effectStack[effectStack.length - 1]
  }
  // effectFn.deps 用来存储所有与该副作用函数相关联的依赖集合
  effectFn.deps = []
  // 执行副作用函数
  effectFn()
}
```

## 4.6 避免无限递归循环

当有如下的代码时，会发生无限递归循环：

```js
const data = { foo: 1 }
const obj = new Proxy(data, {
  /* ... */
})

effect(() => obj.foo++)
// 上句相当于
effect(() => {
  obj.foo = obj.foo + 1
})
```

在副作用中，既读取 obj.foo，又设置 obj.foo，读取会触发 track 操作，将副作用函数放入桶中；设置会触发 trigger，从桶中取出副作用函数并执行。

但问题是该副作用函数正在执行中，还没执行完毕，就要开始下一次的执行。这将会导致无限递归调用自己，产生栈溢出。

通过分析发现，读取和设置操作是在同一个副作用函数内进行的。不管是 track 收集的副作用函数，还是 trigger 执行的副作用函数都是 activeEffect。
基于此，我们可以加个条件，**如果 trigger 执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行**，如下所示：

```js
function trigger(target, key) {
  const depsMap = bucket.get(target)
  if (!depsMap) {
    return
  }
  const effects = depsMap.get(key)

  // 构造一个新的集合 effectToRun 然后变量它，用来遍历删除，避免死循环
  const effectsToRun = new Set()
  effects &&
    effects.forEach(effectFn => {
      if (effectFn !== activeEffectFn) {
        // 如果 trigger 执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行
        effectsToRun.add(effectFn)
      }
    })
  effectsToRun.forEach(effectFn => effectFn())
}
```

## 4.7 调度执行

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/index.md'
---
# Vue3 官方资料笔记

Vue3 官方资料的学习，分成了两个部分，第一部分在另一个工程里 [hello-vue3](https://github.com/FuckDoctors/hello-vue3)，后面的在本站内记录。

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/basic/index.md'
---
# 基础

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/basic/reactivity-fundamentals.md'
---
# 响应式基础

## 声明响应式状态

我们可以使用 reactive() 函数创建一个响应式对象或数组：

::: vue-playground reactive 示例
@file App.vue

```vue
<script>
import { reactive } from 'vue'

export default {
  setup() {
    const state = reactive({ count: 0 })

    function increment() {
      state.count++
    }

    // 不要忘记同时暴露 increment 函数
    return {
      state,
      increment,
    }
  },
}
</script>

<template>
  <button @click="increment">{{ state.count }}</button>
</template>
```

:::

### `<script setup>`

在 `setup()` 函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用构建工具来简化该操作。
当使用单文件组件（SFC）时，我们可以使用 `<script setup>` 来大幅度地简化代码。

::: vue-playground  示例

@file App.vue

```vue
<script setup>
import { reactive } from 'vue'

const state = reactive({ count: 0 })

function increment() {
  state.count++
}
</script>

<template>
  <button @click="increment">{{ state.count }}</button>
</template>
```

:::

### DOM 更新时机

当你更改响应式状态后，DOM 会自动更新。然而，你得注意 DOM 的更新并不是同步的。
相反，Vue 将缓冲它们直到更新周期的 “下个时机” 以确保无论你进行了多少次状态更改，每个组件都只更新一次。

若要等待一个状态改变后的 DOM 更新完成，你可以使用 `nextTick()` 这个全局 API。

### 深层响应性

在 Vue 中，状态都是默认深层响应式的。

你也可以直接创建一个浅层响应式对象 `shallowReactive`。它们仅在顶层具有响应性，一般仅在某些特殊场景中需要。

### reactive() 的局限性

`reactive()` API 有两条限制：

1. 仅对对象类型有效（对象、数组和 Map、Set 这样的集合类型），而对 string、number 和 boolean 这样的 原始类型 无效。
2. 因为 Vue 的响应式系统是通过属性访问进行追踪的，因此我们必须始终保持对该响应式对象的相同引用。这意味着我们不可以随意地“替换”一个响应式对象，因为这将导致对初始引用的响应性连接丢失。
   同时这也意味着当我们将响应式对象的属性赋值或解构至本地变量时，或是将该属性传入一个函数时，我们会失去响应性。

## 用 `ref()` 定义响应式变量

`reactive()` 的种种限制归根结底是因为 JavaScript 没有可以作用于所有值类型的 “引用” 机制。
为此，Vue 提供了一个 `ref()` 方法来允许我们创建可以使用任何值类型的响应式 `ref`。

`ref()` 将传入参数的值包装为一个带 `.value` 属性的 `ref` 对象：

::: vue-playground ref 示例

@file App.vue

```vue
<script setup>
import { ref } from 'vue'

const count = ref(0)

function increment() {
  count.value++
}
</script>

<template>
  <button @click="increment">{{ count }}</button>
</template>
```

:::

```js
const count = ref(0)

console.log(count) // { value: 0 }
console.log(count.value) // 0

count.value++
console.log(count.value) // 1
```

和响应式对象的属性类似，`ref` 的 `.value` 属性也是响应式的。
同时，当值为对象类型时，会用 `reactive()` 自动转换它的 `.value`。

一个包含对象类型值的 `ref` 可以响应式地替换整个对象：

```js
const objectRef = ref({ count: 0 })

// 这是响应式的替换
objectRef.value = { count: 1 }
```

`ref` 被传递给函数或是从一般对象上被解构时，不会丢失响应性：

```js
const obj = {
  foo: ref(1),
  bar: ref(2),
}

// 该函数接收一个 ref
// 需要通过 .value 取值
// 但它会保持响应性
callSomeFunction(obj.foo)

// 仍然是响应式的
const { foo, bar } = obj
```

简言之，`ref()` 让我们能创造一种对任意值的 “引用”，并能够在不丢失响应性的前提下传递这些引用。

这个功能很重要，因为它经常用于将逻辑提取到 **组合函数** 中。

### ref 在模板中的解包

当 ref 在模板中作为顶层属性被访问时，它们会被自动“解包”，所以不需要使用 `.value`。

### ref 在响应式对象中的解包

当一个 `ref` 被嵌套在一个响应式对象中，作为属性被访问或更改时，它会自动解包，因此会表现得和一般的属性一样：

```js
const count = ref(0)
const state = reactive({ count })

console.log(state.count) // 0

state.count = 1
console.log(count.value) // 1
```

如果将一个新的 `ref` 赋值给一个关联了已有 `ref` 的属性，那么它会替换掉旧的 `ref`：

```js
const otherCount = ref(2)

state.count = otherCount
console.log(state.count) // 2
// 原始 ref 现在已经和 state.count 失去联系
console.log(count.value) // 1
```

只有当嵌套在一个深层响应式对象内时，才会发生 `ref` 解包。当其作为浅层响应式对象 `shallowReactive` 的属性被访问时不会解包。

### 数组和集合类型的 ref 解包

跟响应式对象不同，当 `ref` 作为响应式数组或像 `Map` 这种原生集合类型的元素被访问时，不会进行解包。

```js
const books = reactive([ref('Vue 3 Guide')])
// 这里需要 .value
console.log(books[0].value)

const map = reactive(new Map([['count', ref(0)]]))
// 这里需要 .value
console.log(map.get('count').value)
```

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/basic/template-syntax.md'
---
# 模板语法

## 文本插值

```vue
<span>
Message: {{ msg }}
</span>
```

## 原始 HTML

```vue
<p>
Using v-html directive: <span v-html="rawHtml"></span>
</p>
```

## Attribute 绑定

想要响应式地绑定一个 attribute，应该使用 v-bind 指令：

```vue
<div v-bind:id="dynamicId"></div>
```

因为 v-bind 非常常用，我们提供了特定的简写语法：

```vue
<div :id="dynamicId"></div>
```

动态绑定多个值:

如果你有像这样的一个包含多个 attribute 的 JavaScript 对象：

```js
const objectOfAttrs = {
  id: 'container',
  class: 'wrapper',
}
```

通过不带参数的 `v-bind`，你可以将它们绑定到单个元素上：

```vue
<div v-bind="objectOfAttrs"></div>
```

## 指令 Directives

指令是带有 `v-` 前缀的特殊 attribute。

### 参数 Arguments

某些指令会需要一个“参数”，在指令名后通过一个冒号（`:`）隔开做标识。
例如用 `v-bind` 指令来响应式地更新一个 HTML attribute：

```vue
<a v-bind:href="url">
 ...
</a>

<!-- 简写 -->
<a :href="url">
 ...
</a>
```

这里 `href` 就是一个参数，它告诉 `v-bind` 指令将表达式 `url` 的值绑定到元素的 `href` attribute 上。

另一个例子是 `v-on` 指令，它将监听 DOM 事件：

```vue
<a v-on:click="doSomething">
 ...
</a>

<!-- 简写 -->
<a @click="doSomething">
 ...
</a>
```

### 动态参数

同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号(`[]`)内：

```vue
<a v-bind:[attributeName]="url">
 ...
</a>

<!-- 简写 -->
<a :[attributeName]="url">
 ...
</a>
```

### 修饰符 Modifiers

修饰符是以点(`.`)开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。
例如 `.prevent` 修饰符会告知 `v-on` 指令对触发的事件调用 `event.preventDefault()`：

```vue
<form @submit.prevent="onSubmit">
 ...
</form>
```

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/built-ins/index.md'
---
# 内置组件

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/built-ins/keep-alive.md'
---
# KeepAlive

`<KeepAlive>` 是一个内置组件，使我们可以在动态切换多个组件时视情况缓存组件实例。

## 基本用法

在组件基础章节中，我们已经介绍了动态组件的用法，即使用特殊的 `<component>` 元素：

```vue
<component :is="activeComponent" />
```

默认情况下，一个活跃的组件实例会在切走后被卸载。这会导致它丢失其中所有已变化的状态。

我们是的确想要组件能在非活跃状态时保留它们的状态。要解决这个问题，我们可以用内置的 `<KeepAlive>` 组件将这些动态组件包装起来：

```vue
<!-- 非活跃的组件将会被缓存！ -->
<KeepAlive>
  <component :is="activeComponent" />
</KeepAlive>
```

::: playground#vue KeepAlive 基本用法
@file App.vue

```vue
<script setup>
import { shallowRef } from 'vue'
import CompA from './CompA.vue'
import CompB from './CompB.vue'

const current = shallowRef(CompA)
</script>

<template>
  <div class="demo">
    <label><input v-model="current" type="radio" :value="CompA" /> A</label>
    <label><input v-model="current" type="radio" :value="CompB" /> B</label>
    <KeepAlive>
      <component :is="current" />
    </KeepAlive>
  </div>
</template>
```

@file CompA.vue

```vue
<script setup>
import { ref } from 'vue'

const counter = ref(0)
</script>

<template>
  <p>Current component: A</p>
  <span>Count: {{ counter }}</span>
  <button @click="counter++">+</button>
</template>
```

@file CompB.vue

```vue
<script setup>
import { ref } from 'vue'

const msg = ref('')
</script>

<template>
  <p>Current component: B</p>
  <span>Message is: {{ msg }}</span>
  <input v-model="msg" />
</template>
```

:::

## 包含 / 排除

默认情况下，`<KeepAlive>` 会缓存内部的任何组件实例。但我们可以通过 `include` 和 `exclude` prop 来定制该行为。
这两个 prop 的值都可以是一个以英文逗号分隔的字符串、一个正则表达式，或是包含这两种类型的一个数组：

```vue
<!-- 以英文逗号分隔的字符串 -->
<KeepAlive include="a,b">
  <component :is="view">
</KeepAlive>

<!-- 以正则表达式（需要使用 v-bind） -->
<KeepAlive :include="/a|b/">
  <component :is="view">
</KeepAlive>

<KeepAlive :include="['a', 'b']">
  <component :is="view">
</KeepAlive>
```

::: warning
它会根据组件的 `name` 选项进行匹配，所以组件如果想要条件性地被 `KeepAlive` 缓存，就必须显式声明一个 `name` 选项。
:::

## 最大缓存实例数

我们可以通过传入 `max` prop 来限制可被缓存的最大组件实例数。
`<KeepAlive>` 的行为在指定了 `max` 后类似一个 LRU 缓存：
如果缓存的实例数量即将超过指定的那个最大数量，则最久没有被访问的缓存实例将被销毁，以便为新的实例腾出空间。

```vue
<KeepAlive :max="10">
  <component :is="activeComponent" />
</KeepAlive>
```

## 缓存实例的生命周期

当一个组件实例从 DOM 上移除但因为被 `<KeepAlive>` 缓存而仍作为组件树的一部分时，它将变为不活跃状态而不是被卸载。
当一个组件实例作为缓存树的一部分插入到 DOM 中时，它将重新被激活。

一个持续存在的组件可以通过 `onActivated()` 和 `onDeactivated()` 注册相应的两个状态的生命周期钩子：

```vue
<script setup>
import { onActivated, onDeactivated } from 'vue'

onActivated(() => {
  // 调用时机为首次挂载
  // 以及每次从缓存中被重新插入时
})

onDeactivated(() => {
  // 在从 DOM 上移除、进入缓存
  // 以及组件卸载时调用
})
</script>
```

请注意：

* `onActivated` 在组件挂载时也会调用，并且 `onDeactivated` 在组件卸载时也会调用。
* 这两个钩子不仅适用于 `<KeepAlive>` 缓存的根组件，也适用于缓存树中的后代组件。

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/built-ins/suspense.md'
---
# Suspense

`<Suspense>` 是一个内置组件，用来在组件树中编排异步依赖。它可以在等待组件树下的多个嵌套异步依赖项解析完成时，呈现加载状态。

## 异步依赖

有了 `<Suspense>` 组件后，我们就可以在等待整个多层级组件树中的各个异步依赖获取结果时，在顶层展示出加载中或加载失败的状态。

`<Suspense>` 可以等待的异步依赖有两种：

1. 带有异步 `setup()` 钩子的组件。这也包含了使用 `<script setup>` 时有顶层 `await` 表达式的组件。
2. [异步组件](https://staging-cn.vuejs.org/guide/components/async.html)

### async setup()

组合式 API 中组件的 `setup()` 钩子可以是异步的:

```js
export default {
  async setup() {
    const res = await fetch(...)
    const posts = await res.json()

    return {
      posts
    }
  }
}
```

如果使用 `<script setup>`，那么顶层 `await` 表达式会自动让该组件成为一个异步依赖：

```vue
<script setup>
const res = await fetch(...)
const posts = await res.json()
</script>
```

### 异步组件

异步组件默认就是\*\*"suspensible"\*\*的。这意味着如果组件关系链上有一个 `<Suspense>`，那么这个异步组件就会被当作这个 `<Suspense>` 的一个异步依赖。
在这种情况下，加载状态是由 `<Suspense>` 控制，而该组件自己的加载、报错、延时和超时等选项都将被忽略。

异步组件也可以通过在选项中指定 `suspensible: false` 表明不用 `Suspense` 控制，并让组件始终自己控制其加载状态。

## 加载中状态

`<Suspense>` 组件有两个插槽：`#default` 和 `#fallback`。
两个插槽都只允许一个直接子节点。在可能的时候都将显示默认槽中的节点。否则将显示后备槽中的节点。

```vue
<Suspense>
  <!-- 具有深层异步依赖的组件 -->
  <Dashboard />

  <!-- 在 #fallback 插槽中显示 “正在加载中”  -->
  <template #fallback>
    <div>Loading...</div>
  </template>
</Suspense>
```

在初始渲染时，`<Suspense>` 将在内存中渲染其默认的插槽内容。
如果在这个过程中遇到任何异步依赖，则会进入挂起状态。在挂起状态期间，展示的是后备内容。
当所有遇到的异步依赖都完成后，`<Suspense>` 会进入完成状态，并将展示出默认插槽的内容。

如果在初次渲染时没有遇到异步依赖，`<Suspense>` 会直接进入完成状态。

进入完成状态后，只有当默认插槽的根节点被**替换**时，`<Suspense>` 才会回到挂起状态。组件树中新的更深层次的异步依赖**不会**造成 `<Suspense>` 回退到挂起状态。

发生回退时，后备内容不会立即展示出来。相反，`<Suspense>` 在等待新内容和异步依赖完成时，会展示之前 `#default` 插槽的内容。
这个行为可以通过一个 `timeout` prop 进行配置：
在等待渲染新内容耗时超过 `timeout` 之后，`<Suspense>` 将会切换为展示后备内容。若 `timeout` 值为 `0` 将导致在替换默认内容时立即显示后备内容。

## 事件

除了 `pending` 事件之外，`<suspense>` 组件还有 `resolve` 和 `fallback` 事件。
`pending` 事件是在进入挂起状态时触发。`resolve` 事件是在 `default` 插槽完成获取新内容时触发。`fallback` 事件则是在 `fallback` 插槽展示时触发。

例如，可以使用这些事件在加载新组件时在之前的 DOM 最上层显示一个加载指示器。

## 错误处理

`<Suspense>` 组件自身目前还不提供错误处理，不过你可以使用 `errorCaptured` 选项或者 `onErrorCaptured()` 钩子，在使用到 `<Suspense>` 的父组件中捕获和处理异步错误。

## 和其他组件结合

我们常常会将 `<Suspense>` 和 `<Transition>`、`<KeepAlive>` 等组件结合。要保证这些组件都能正常工作，嵌套的顺序非常重要。

另外，这些组件都通常与 Vue Router 中的 `<RouterView>` 组件结合使用。

```vue
<RouterView v-slot="{ Component }">
  <template v-if="Component">
    <Transition mode="out-in">
      <KeepAlive>
        <Suspense>
          <!-- 主要内容 -->
          <component :is="Component" />

          <!-- 加载中的状态 -->
          <template #fallback>
            <div>正在加载中...</div>
          </template>
        </Suspense>
      </KeepAlive>
    </Transition>
  </template>
</RouterView>
```

Vue Router 使用动态导入对[懒加载组件](https://next.router.vuejs.org/guide/advanced/lazy-loading.html)进行了内置支持。
这些与异步组件不同，目前他们不会触发 `<Suspense>`。但是，它们仍然可以有异步组件作为后代，这些组件可以照常触发 `<Suspense>`。

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/built-ins/teleport.md'
---
# Teleport 传送门

`<Teleport>` 是一个内置组件，使我们可以将一个组件的一部分模板“传送”到该组件的 DOM 层次结构之外的 DOM 节点中。

## 基本使用

为 `<Teleport>` 指定的目标 `to` 期望接收一个 CSS 选择器字符串或者一个真实的 DOM 节点。这里我们其实就是让 Vue 去“传送这部分模板片段到 `body` 标签下”。

```vue
<button @click="open = true">
Open Modal
</button>

<Teleport to="body">
  <div v-if="open" class="modal">
    <p>Hello from the modal!</p>
    <button @click="open = false">Close</button>
  </div>
</Teleport>
```

你可以点击下面这个按钮，然后通过浏览器的开发者工具，在 `<body>` 标签下找到模态框元素：

::: tip
`<Teleport>` 挂载时，传送门的 to 目标必须是已经存在于 DOM 之中。
理想情况下，这应该是整个 Vue 应用程序之外的一个元素。
如果目标是由 Vue 呈现的另一个元素，你需要确保在 `<Teleport>` 之前挂载该元素。
:::

## 搭配组件使用

`<Teleport>` 只改变了渲染的 DOM 结构，它不会影响组件间的逻辑关系。
也就是说，如果 `<Teleport>` 包含了一个组件，那么该组件始终和这个使用了 `<Teleport>` 的组件保持逻辑上的父子关系。
传入的 props 和触发的事件也会照常工作。

这也意味着来自父组件的注入也会按预期工作，子组件将在 Vue Devtools 中嵌套在父级组件下面，而不是放在实际内容移动到的地方。

## 禁用传送门

在某些场景中，你们可能需要视情况禁用 `<Teleport>`。
举个例子，我们想要在桌面端将一个组件当做浮层来渲染，但在移动端则当作行内组件。
可以对 `<Teleport>` 动态地传入一个 `disabled` prop 来处理这两种不同情况。

```vue
<Teleport :disabled="isMobile">
  <!-- ... -->
</Teleport>
```

## 同一目标上多个传送门

一个常见的应用场景就是写一个可重用的 `<Modal>` 组件，可能同时存在多个实例。
对于此类场景，多个 `<Teleport>` 组件可以将其内容挂载在同一个目标元素上，
而顺序就是简单的顺次追加，后挂载的将排在目标元素下更后面的位置上。

```vue
<Teleport to="#modals">
  <div>A</div>
</Teleport>

<Teleport to="#modals">
  <div>B</div>
</Teleport>
```

渲染结果：

```html
<div id="modals">
  <div>A</div>
  <div>B</div>
</div>
```

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/built-ins/transition-group.md'
---
# TransitionGroup

`<TransitionGroup>` 是一个内置组件，设计用于呈现一个列表中的元素或组件的插入、移除和顺序改变的动画效果。

## 和 `<Transition>` 的区别

`<TransitionGroup>` 支持和 `<Transition>` 基本相同的 prop、CSS 过渡 class 和 JavaScript 钩子监听器，但有以下几点区别：

* 默认情况下，它不会渲染一个包装器元素。但你可以通过传入 `tag` 属性来指定一个元素作为包装器元素来渲染。
* 过渡模式在这里不可用，因为我们不再是在互斥的元素之间进行切换。
* 其中的元素**总是必须**有一个独一无二的 `key` attribute。
* CSS 过渡 class 会被应用在其中的**每一个元素**上，**而不是**这个组的容器上。

## 进入 / 离开过渡

这里是 `<TransitionGroup>` 对一个 `v-for` 列表应用进入 / 离开过渡的示例：

```vue
<TransitionGroup name="list" tag="ul">
  <li v-for="item in list" :key="item">{{ item }}</li>
</TransitionGroup>
```

```css
.list-enter-active,
.list-leave-active {
  transition: all 0.5s ease;
}
.list-enter-from,
.list-leave-to {
  opacity: 0;
  transform: translateX(30px);
}
```

::: playground#vue 简单列表过渡
@file App.vue

```vue
<script setup>
import { ref } from 'vue'
import { shuffle as _shuffle } from 'lodash-es'

const getInitialItems = () => [1, 2, 3, 4, 5]
const items = ref(getInitialItems())
let id = items.value.length + 1

function insert() {
  const i = Math.round(Math.random() * items.value.length)
  items.value.splice(i, 0, id++)
}

function reset() {
  items.value = getInitialItems()
}

function shuffle() {
  items.value = _shuffle(items.value)
}

function remove(item) {
  const i = items.value.indexOf(item)
  if (i > -1) {
    items.value.splice(i, 1)
  }
}
</script>

<template>
  <div class="actions">
    <button @click="insert">随机插入</button>
    <button @click="reset">重置</button>
    <button @click="shuffle">打乱</button>
  </div>

  <TransitionGroup tag="ul" name="fade" class="container">
    <li v-for="item in items" :key="item" class="item">
      {{ item }}
      <button class="btn" @click="remove(item)">x</button>
    </li>
  </TransitionGroup>
</template>

<style scoped>
.container {
  position: relative;
  padding: 5px;
  list-style: none;
}
.container .item {
  display: block;
  list-style-type: none;
  overflow: hidden;
  height: 30px;
  line-height: 30px;
  padding-left: 5px;
  padding-right: 5px;
  border: gray 1px dashed;
  background: #f3f3f3;
  box-sizing: border-box;
}
.container .item .btn {
  margin-top: 3px;
  float: right;
}
.container .item::after {
  content: '';
  clear: both;
}

/* 对移动中的元素应用的过渡 */
.fade-move, /* apply transition to moving elements */
.fade-enter-active,
.fade-leave-active {
  transition: all 0.5s cubic-bezier(0.55, 0, 0.1, 1);
}
.fade-enter-from,
.fade-leave-to {
  opacity: 0;
  transform: scaleY(0.01) translate(30px, 0);
}
/* 确保将离开的元素从布局流中删除
  以便能够正确地计算移动的动画。 */
.fade-leave-active {
  position: absolute;
}
</style>
```

@import

```json
{
  "imports": {
    "lodash-es": "https://cdn.jsdelivr.net/npm/lodash-es@4.17.21/lodash.min.js"
  }
}
```

:::

## 交错的列表过渡

如果通过 data attribute 用 JavaScript 来执行过渡时，那么我们也可以实现列表中的交错过渡。
首先，我们把某一项的索引作为 DOM 元素上的一个 data attribute 呈现出来。

```vue {11}
<TransitionGroup
  tag="ul"
  :css="false"
  @before-enter="onBeforeEnter"
  @enter="onEnter"
  @leave="onLeave"
>
  <!-- prettier-ignore-attribute -->
  <li v-for="(item, index) in computedList" :key="item.msg" :data-index="index">
    {{ item.msg }}
  </li>
</TransitionGroup>
```

接着，在 JavaScript 钩子中，我们基于这个 data attribute 对该元素执行一个延迟动画：

```js {5}
function onEnter(el, done) {
  gsap.to(el, {
    opacity: 1,
    height: '1.6em',
    delay: el.dataset.index * 0.15,
    onComplete: done,
  })
}
```

::: playground#vue 交错的列表过渡
@file App.vue

```vue
<script setup>
import { computed, ref } from 'vue'
import gsap from 'gsap'

const list = [
  { msg: 'Bruce Lee' },
  { msg: 'Jackie Chan' },
  { msg: 'Chuck Norris' },
  { msg: 'Jet Li' },
  { msg: 'Kung Fury' },
]

const query = ref('')

const computedList = computed(() => {
  return list.filter(item => item.msg.toLowerCase().includes(query.value))
})

function onBeforeEnter(el) {
  el.style.opacity = 0
  el.style.height = 0
}

function onEnter(el, done) {
  gsap.to(el, {
    opacity: 1,
    height: '1.6em',
    delay: el.dataset.index * 0.15,
    onComplete: done,
  })
}

function onLeave(el, done) {
  gsap.to(el, {
    opacity: 0,
    height: 0,
    delay: el.dataset.index * 0.15,
    onComplete: done,
  })
}
</script>

<template>
  <input v-model="query" />
  <TransitionGroup
    tag="ul"
    :css="false"
    @before-enter="onBeforeEnter"
    @enter="onEnter"
    @leave="onLeave"
  >
    <li
      v-for="(item, index) in computedList"
      :key="item.msg"
      :data-index="index"
    >
      {{ item.msg }}
    </li>
  </TransitionGroup>
</template>
```

@import

```json
{
  "imports": {
    "gsap": "https://unpkg.com/gsap?module"
  }
}
```

:::

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/built-ins/transition.md'
---
# Transition

Vue 提供了两个内置组件，可以帮助你制作基于状态变化的过渡和动画：

* `Transition` 会在一个元素或组件进入和离开 DOM 时应用动画。
* `TransitionGroup` 会在一个元素或组件被插入到 `v-for` 列表中，或是被移动或从其中移除时应用动画。

除了这两个组件，我们也可以通过其他技术手段来应用动画，比如切换 CSS class 或用状态绑定样式来驱动动画。

## `Transition` 组件

它可以将进入和离开动画应用到通过默认插槽传递给它的元素或组件上。进入或离开可以由以下的条件之一触发：

* 由 `v-if` 所带来的条件渲染
* 由 `v-show` 所带来的条件显示
* 由特殊元素 `<component>` 切换的动态组件

最基本的示例：

::: playground#vue transistion 示例
@file App.vue

```vue
<script setup>
import { ref } from 'vue'

const show = ref(true)
</script>

<template>
  <button @click="show = !show">Toggle</button>
  <Transition>
    <p v-if="show">hello</p>
  </Transition>
</template>

<style>
.v-enter-active,
.v-leave-active {
  transition: opacity 0.5s ease;
}
.v-enter-from,
.v-leave-to {
  opacity: 0;
}
</style>
```

:::

::: tip
`<Transition>` 仅支持单个元素或组件作为其插槽内容。如果内容是一个组件，这个组件必须仅有一个根元素。
:::

当一个 `Transition` 组件中的元素被插入或移除时，会发生下面这些事情：

1. Vue 会自动检查目标元素是否应用了 CSS 过度或动画。如果是，则一些 CSS 过度 class 会在适当的时机被添加或移除。
2. 如果有作为监听器的 JavaScript 钩子，这些钩子函数会在适当时机被调用。
3. 如果没有探测到 CSS 过度或动画，没有提供 JavaScript 钩子，那么 DOM 的插入，删除操作将在浏览器的下一个动画帧上进行。

## 基于 CSS 的过渡

### CSS 过渡 class

一共有 6 个应用于进入与离开过渡效果的 CSS class。

```mermaid
stateDiagram-v2
  direction LR

  state Enter {
    direction LR
    Opacity#58;&nbsp;0<br/><br/>v#45;enter#45;from --> Opacity#58;&nbsp;1<br/><br/>v#45;enter#45;to : v#45;enter#45;active
  }

  state Leave {
    direction LR
    Opacity#58;&nbsp;1<br/><br/>v#45;leave#45;from --> Opacity#58;&nbsp;0<br/><br/>v#45;leave#45;to : v#45;leave#45;active
  }
```

::: tip mermaid escapse
Numbers given are base 10, so `#` can be encoded as `#35;`. It is also supported to use HTML character names.

Because semicolons can be used instead of line breaks to define the markup, you need to use `#59;` to include a semicolon in message text.

冒号 `:` = `#58;`, 空格 `&nbsp;`，换行 `<br />`，减号 `-` = `#45;`
:::

1. `v-enter-from`：进入动画的起始状态。在元素插入之前添加，在元素插入完成后的下一帧移除。
2. `v-enter-active`：进入动画的生效状态。应用于整个进入动画阶段。
   在元素被插入之前添加，在过渡或动画完成之后移除。这个 class 可以被用来定义进入动画的持续时间、延迟与速度曲线类型。
3. `v-enter-to`：进入动画的结束状态。在元素插入完成后的下一帧被添加 (也就是 `v-enter-from` 被移除的同时)，在过渡或动画完成之后移除。
4. `v-leave-from`：离开动画的起始状态。在离开过渡效果被触发时立即添加，在一帧后被移除。
5. `v-leave-active`：离开动画的生效状态。应用于整个离开动画阶段。在离开过渡效果被触发时立即添加，在过渡或动画完成之后移除。
   这个 class 可以被用来定义离开动画的持续时间、延迟与速度曲线类型。
6. `v-leave-to`：离开动画的结束状态。在一个离开动画被触发后的下一帧被添加 (也就是 `v-leave-from` 被移除的同时)，在过渡或动画完成之后移除。

`v-enter-active` 和 `v-leave-active` 给我们提供了为进入和离开动画指定不同速度曲线的能力。

### 为过渡命名

可以通过一个 `name` 属性来声明一种过渡：

```vue
<Transition name="fade">
...
</Transition>
```

对于一个已命名的过渡，它的过渡相关 class 会以其名字而不是 `v` 作为前缀。
比如，上方例子中被应用的 class 将会是 `fade-enter-active` 而不是 `v-enter-active`。这个 "fade" 过渡的 class 应该是这样：

```css
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.5s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
```

### CSS 的 transition

`<Transition>` 一般都会搭配[原生 CSS 过渡](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions)一起使用，这个 transition CSS 属性是一个简写形式，使我们可以一次定义一个过渡的各个方面，包括需要执行动画的属性、持续时间和[速度曲线](https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function)。

下面是一个更高级的例子，它使用了不同的持续时间和速度曲线来过渡多个 property：

::: playground#vue CSS Transition
@file App.vue

```vue
<script setup>
import { ref } from 'vue'

const show = ref(true)
</script>

<template>
  <button @click="show = !show">Toggle Slide + Fade</button>
  <Transition name="slide-fade">
    <p v-if="show">hello</p>
  </Transition>
</template>

<style scoped>
.slide-fade-enter-active {
  transition: all 0.3s ease-out;
}
.slide-fade-leave-active {
  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);
}
.slide-fade-enter-from,
.slide-fade-leave-to {
  transform: translateX(20px);
  opacity: 0;
}
</style>
```

:::

### CSS 的 animation

[原生 CSS 动画](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations)和 CSS trasition 的应用方式基本上是相同的，只有一点不同，那就是 `*-enter-from` 不是在元素插入后立即移除，而是在一个 `animationend` 事件触发时被移除。

对于大多数的 CSS 动画，我们可以简单地在 `*-enter-active` 和 `*-leave-active` class 下声明它们。下面是一个示例：

::: playground#vue CSS animation
@file App.vue

```vue
<script setup>
import { ref } from 'vue'

const show = ref(true)
</script>

<template>
  <button @click="show = !show">Toggle</button>
  <Transition name="bounce">
    <p v-if="show" style="text-align: center;">
      Hello here is some bouncy text!
    </p>
  </Transition>
</template>

<style scoped>
.bounce-enter-active {
  animation: bounce-in 0.5s;
}
.bounce-leave-active {
  animation: bounce-in 0.5s reverse;
}
@keyframes bounce-in {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1.25);
  }
  100% {
    transform: scale(1);
  }
}
</style>
```

:::

### 自定义过渡 class

你也可以向 `<Transition>` 传递以下的 props 来指定自定义的过渡 class：

* `enter-from-class`
* `enter-active-class`
* `enter-to-class`
* `leave-from-class`
* `leave-active-class`
* `leave-to-class`

你传入的这些 class 会覆盖相应阶段的默认 class 名。这个功能在你想要在 Vue 的动画机制下集成其他的第三方 CSS 动画库时非常有用，比如 [Animate.css](https://daneden.github.io/animate.css/)：

::: playground#vue 自定义过渡 class
@file App.vue

```vue
<script setup>
import { ref } from 'vue'

const show = ref(true)
</script>

<template>
  <button @click="show = !show">Toggle</button>
  <Transition
    name="custom-class"
    enter-active-class="animate__animated animate__tada"
    leave-active-class="animate__animated animate__bounceOutRight"
  >
    <p v-if="show">hello</p>
  </Transition>
</template>

<style scoped>
@import 'https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css';
</style>
```

:::

### 同时使用 transition 和 animation

Vue 需要附加事件侦听器，以便知道过渡何时结束。可以是 `transitionend` 或 `animationend`，这取决于你所应用的 CSS 规则。
如果你仅仅使用二者的其中之一，Vue 可以自动探测到正确的类型。

然而在某些场景中，你或许想要在同一个元素上同时使用它们两个。
举个例子，Vue 触发了一个 CSS 动画，同时鼠标悬停触发另一个 CSS 过渡。
此时你需要显式地传入 type prop 来声明，告诉 Vue 需要关心哪种类型，传入的值是 `animation` 或 `transition`：

```vue
<Transition type="animation">
...
</Transition>
```

### 深层级过渡与显示过渡时间

尽管过渡 class 仅能应用在 `<Transition>` 的直接子元素上，我们还是可以使用深层级的 CSS 选择器，使深层级的元素发生过渡。

```vue
<Transition name="nested">
  <div v-if="show" class="outer">
    <div class="inner">
      Hello
    </div>
  </div>
</Transition>
```

```css
/* 应用于嵌套元素的规则 */
.nested-enter-active .inner,
.nested-leave-active .inner {
  transition: all 0.3s ease-in-out;
}

.nested-enter-from .inner,
.nested-leave-to .inner {
  transform: translateX(30px);
  opacity: 0;
}
```

我们甚至可以在嵌套元素上添加一个过渡延迟，这会创建一个交错进入动画序列：

```css {3}
/* 延迟嵌套元素的进入以获得交错效果 */
.nested-enter-active .inner {
  transition-delay: 0.25s;
}
```

然而，这会带来一个小问题。默认情况下，`<Transition>` 组件会通过监听过渡根元素上的**第一个** `transitionend` 或者 `animationend` 事件来尝试自动判断过渡何时结束。
而在嵌套的过渡中，期望的行为应该是等待所有内部元素的过渡完成。

在这种情况下，你可以通过向 `<Transition>` 组件传入 `duration` 属性来显式指定过渡的持续时间 (以毫秒为单位)。总持续时间应该匹配延迟加上内部元素的过渡持续时间：

```vue
<Transition :duration="550">
...
</Transition>
```

如果有必要的话，你也可以用对象的形式传入，分开指定进入和离开所需的时间：

```vue
<Transition :duration="{ enter: 500, leave: 800 }">
...
</Transition>
```

::: playground#vue 深层级过渡与显式过渡时间
@file App.vue

```vue
<script setup>
import { ref } from 'vue'

const show = ref(true)
</script>

<template>
  <button @click="show = !show">Toggle</button>
  <Transition :duration="550" name="nested">
    <div v-if="show" class="outer">
      <div class="inner">Hello</div>
    </div>
  </Transition>
</template>

<style scoped>
.outer,
.inner {
  background: #eee;
  padding: 30px;
  min-height: 50px;
}

.inner {
  background: #ccc;
}

.nested-enter-active,
.nested-leave-active {
  transition: all 0.3s ease-in-out;
}

/* delay leave of parent element */
.nested-leave-active {
  transition-delay: 0.25s;
}

.nested-enter-from,
.nested-leave-to {
  transform: translateY(30px);
  opacity: 0;
}

/* we can also transition nested elements using nested selectors */
.nested-enter-active .inner,
.nested-leave-active .inner {
  transition: all 0.3s ease-in-out;
}
/* delay enter of nested element */
.nested-enter-active .inner {
  transition-delay: 0.25s;
}

.nested-enter-from .inner,
.nested-leave-to .inner {
  transform: translateX(30px);
  /*
    Hack around a Chrome 96 bug in handling nested opacity transitions.
    This is not needed in other browsers or Chrome 99+ where the bug
    has been fixed.
  */
  opacity: 0.001;
}
</style>
```

:::

### 性能考量

你可能注意到我们上面例子中展示的动画所用到的属性大多是 `transform` 和 `opacity` 之类的。用这些属性制作动画非常高效，因为：

1. 他们在动画过程中不会影响到 DOM 结构，因此每一个动画帧都不会触发昂贵的 CSS 布局重新计算。
2. 大多数的现代浏览器都可以在执行 `transform` 动画时利用 GPU 进行硬件加速。

相比之下，像 `height` 或者 `margin` 这样的属性会触发 CSS 布局变动，因此执行它们的动画效果更昂贵，需要谨慎使用。
我们可以在 [CSS-Triggers](https://csstriggers.com/) 这类的网站查询哪些属性会在执行动画时触发 CSS 布局变动。

### JavaScript 钩子

你可以通过监听 `<Transition>` 组件事件的方式在过渡过程中挂上钩子函数：

```vue
<Transition
  @before-enter="onBeforeEnter"
  @enter="onEnter"
  @after-enter="onAfterEnter"
  @enter-cancelled="onEnterCancelled"
  @before-leave="onBeforeLeave"
  @leave="onLeave"
  @after-leave="onAfterLeave"
  @leave-cancelled="onLeaveCancelled"
>
  <!-- ... -->
</Transition>
```

```js
// 在元素被插入到 DOM 之前被调用
// 用这个来设置元素的 "enter-from" 状态
function onBeforeEnter(el) {},

// 在元素被插入到 DOM 之后的下一帧被调用
// 用这个来开始进入动画
function onEnter(el, done) {
  // 调用回调函数 done 表示过渡结束
  // 如果与 CSS 结合使用，则这个回调是可选参数
  done()
}

// 当进入过渡完成时调用。
function onAfterEnter(el) {}
function onEnterCancelled(el) {}

// 在 leave 钩子之前调用
// 大多数时候，你应该只会用到 leave 钩子
function onBeforeLeave(el) {}

// 在离开过渡开始时调用
// 用这个来开始离开动画
function onLeave(el, done) {
  // 调用回调函数 done 表示过渡结束
  // 如果与 CSS 结合使用，则这个回调是可选参数
  done()
}

// 在离开过渡完成、
// 且元素已从 DOM 中移除时调用
function onAfterLeave(el) {}

// 仅在 v-show 过渡中可用
function leaveCancelled(el) {}
```

这些钩子可以与 CSS 过渡或动画结合使用，也可以单独使用。

在使用仅由 JavaScript 执行的动画时，最好是添加一个 `:css="false"` 属性。
这显式地向 Vue 表明跳过对 CSS 过渡的自动探测。除了性能稍好一些之外，还可以防止 CSS 规则意外地干扰过渡。

```vue {3}
<Transition ... :css="false">
 ...
</Transition>
```

在有了 `:css="false"` 后，我们就自己全权负责控制什么时候过渡结束了。
这种情况下对于 `@enter` 和 `@leave` 钩子来说，回调函数 `done` 就是必须的。否则，钩子将被同步调用，过渡将立即完成。

可以使用 [GreenSock](https://greensock.com/), [Anime.js](https://animejs.com/), 或者 [Motion One](https://motion.dev/) 等库来执行动画。

::: playground#vue JavaScript 钩子
@file App.vue

```vue
<script setup>
import { ref } from 'vue'
import gsap from 'gsap'

const show = ref(true)

function onBeforeEnter(el) {
  gsap.set(el, {
    scaleX: 0.25,
    scaleY: 0.25,
    opacity: 1,
  })
}

function onEnter(el, done) {
  gsap.to(el, {
    duration: 1,
    scaleX: 1,
    scaleY: 1,
    opacity: 1,
    ease: 'elastic.inOut(2.5, 1)',
    onComplete: done,
  })
}

function onLeave(el, done) {
  gsap.to(el, {
    duration: 0.7,
    scaleX: 1,
    scaleY: 1,
    x: 300,
    ease: 'elastic.inOut(2.5, 1)',
  })
  gsap.to(el, {
    duration: 0.2,
    delay: 0.5,
    opacity: 0,
    onComplete: done,
  })
}
</script>

<template>
  <button @click="show = !show">Toggle</button>

  <Transition
    :css="false"
    @before-enter="onBeforeEnter"
    @enter="onEnter"
    @leave="onLeave"
  >
    <div v-if="show" class="gsap-box" />
  </Transition>
</template>

<style>
.gsap-box {
  background: #42b883;
  margin-top: 20px;
  width: 30px;
  height: 30px;
  border-radius: 50%;
}
</style>
```

@import

```json
{
  "imports": {
    "gsap": "https://unpkg.com/gsap?module"
  }
}
```

:::

### 可重用过渡

得益于 Vue 的组件系统，过渡是可以被重用的。要创建一个可被重用的过渡，我们需要为 `<Transition>` 组件创建一个包装组件，并向内传入插槽内容:

```vue
<template>
  <Transition name="my-transition">
    <slot />
  </Transition>
</template>
```

现在 `MyTransition` 可以在导入后像内置组件那样使用了：

```vue
<MyTransition>
  <div v-if="show">hello</div>
</MyTransition>
```

### 出现时过渡

如果你想在某个节点初次渲染时应用一个过渡效果，你可以添加 `appear` attribute：

```vue
<Transition appear>
  <!-- ... -->
</Transition>
```

### 元素间过渡

除了通过 `v-if` / `v-show` 切换一个元素，我们也可以通过 `v-if` / `v-else` / `v-else-if` 在几个组件间进行切换过：

```vue
<Transition>
  <button v-if="docState === 'saved'">Edit</button>
  <button v-if="docState === 'edited'">Save</button>
  <button v-if="docState === 'editing'">Cancel</button>
</Transition>
```

### 过渡模式

在之前的例子中，进入和离开的元素都是在同时开始动画的，并且我们必须将它们设为 `position: absolute` 以避免二者同时存在时出现的布局问题。

然而，在某些场景中这可能不是个好的方案，或者并不能符合行为预期。
我们可能想要先执行离开动画，然后在其完成**之后**再执行元素的进入动画。
手动编排这样的动画是非常复杂的，好在我们可以通过向 `<Transition>` 传入一个 `mode` prop 来实现这个行为：

```vue
<Transition mode="out-in">
  <!-- ... -->
</Transition>
```

### 组件间过渡

`<Transition>` 也可以用在动态组件之间：

```vue
<Transition name="fade" mode="out-in">
  <component :is="activeComponent"></component>
</Transition>
```

::: playground#vue 组件间过渡 & 动态过渡
@file App.vue

```vue
<script setup>
import { ref, shallowRef } from 'vue'

import CompA from './CompA.vue'
import CompB from './CompB.vue'

const activeComponent = shallowRef(CompA)
const transitionName = ref('fade')
</script>

<template>
  <div>
    <div class="selector">
      <label>
        <input
          v-model="activeComponent"
          type="radio"
          name="comp"
          :value="CompA"
        />
        A
      </label>
      <label>
        <input
          v-model="activeComponent"
          type="radio"
          name="comp"
          :value="CompB"
        />
        B
      </label>
    </div>
    <div class="comps">
      <Transition :name="transitionName" mode="out-in">
        <component :is="activeComponent" />
      </Transition>
    </div>
    <div class="effect">
      <label>
        <input
          v-model="transitionName"
          type="radio"
          name="transition"
          value="fade"
        />
        fade
      </label>
      <label>
        <input
          v-model="transitionName"
          type="radio"
          name="transition"
          value="slide"
        />
        slide
      </label>
    </div>
  </div>
</template>

<style>
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.5s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}

.slide-enter-active,
.slide-leave-active {
  transition:
    opacity,
    transform 0.5s ease;
}

.slide-enter-from {
  transform: translateX(100px);
}

.slide-leave-to {
  transform: translateX(-100px);
}

.comps {
  overflow: hidden;
}
</style>
```

@file CompA.vue

```vue
<template>
  <div>Component A</div>
</template>
```

@file CompB.vue

```vue
<template>
  <div>Component B</div>
</template>
```

:::

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/extra/index.md'
---
# 进阶主题

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/extra/animation.md'
---
# 动画技巧

## 基于 CSS class 的动画

对于那些不是正在进入或离开 DOM 的元素，我们可以通过给它们动态添加 CSS class 来触发动画：

::: vue-playground 基于 CSS class 的动画

@file App.vue

```vue
<script setup>
import { ref } from 'vue'

const disabled = ref(false)

function warnDisabled() {
  disabled.value = true
  setTimeout(() => {
    disabled.value = false
  }, 1500)
}
</script>

<template>
  <div :class="{ shake: disabled }">
    <button @click="warnDisabled">Click me</button>
    <span v-if="disabled">This feature is disabled.</span>
  </div>
</template>

<style scoped>
.shake {
  animation: shake 0.82s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  transform: translate3d(0, 0, 0);
}

@keyframes shake {
  10%,
  90% {
    transform: translate3d(-1px, 0, 0);
  }
  20%,
  80% {
    transform: translate3d(2px, 0, 0);
  }
  30%,
  50%,
  70% {
    transform: translate3d(-4px, 0, 0);
  }
  40%,
  60% {
    transform: translate3d(4px, 0, 0);
  }
}
</style>
```

:::

## 状态驱动的动画

有些过渡效果可以通过动态地插值来实现，例如，在交互时动态地绑定样式到元素，以这个例子为例：

::: vue-playground 状态驱动的动画

@file App.vue

```vue
<script setup>
import { ref } from 'vue'

const x = ref(0)

function onMousemove(e) {
  x.value = e.clientX
}
</script>

<template>
  <div
    :style="{ backgroundColor: `hsl(${x}, 80%, 50%)` }"
    class="movearea"
    @mousemove="onMousemove"
  >
    <p>Move your mouse across the div...</p>
    <p>x: {{ x }}</p>
  </div>
</template>

<style scoped>
.movearea {
  transition: 0.3s background-color ease;

  color: #fff;
  border: none;
  border-radius: 10px;
  padding: 10px;
}
</style>
```

:::

## 带侦听器的动画

在一些动画创意里，我们可以根据一些数字状态，使用侦听器将任何东西做成动画。例如，我们可以将数字本身变成动画：

::: vue-playground 带侦听器的动画

@file App.vue

```vue
<script setup>
import { reactive, ref, watch } from 'vue'
import gsap from 'gsap'

const number = ref(0)
const tweened = reactive({
  number: 0,
})
watch(number, n => {
  gsap.to(tweened, {
    duration: 0.5,
    number: Number(n) || 0,
  })
})
</script>

<template>
  <div>
    Type a number: <input v-model.number="number" />
    <p>{{ tweened.number.toFixed(0) }}</p>
  </div>
</template>
```

@import

```json
{
  "imports": {
    "gsap": "https://unpkg.com/gsap?module"
  }
}
```

:::

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/extra/composition-api.md'
---
# 组合式 API FAQ

## 什么是组合式 API？

组合式 API 是一系列 API 的集合，使我们可以使用函数而不是声明式选项的方式来书写 Vue 组件。
它包含以下 API:

* [响应式 API](https://vuejs.org/api/reactivity-core.html): 例如 `ref()` 和 `reactive()`，使我们可以直接创建响应式状态、计算属性和侦听器。
* [生命周期钩子](https://vuejs.org/api/composition-api-lifecycle.html): 例如，`onMounted()` 和 `onUnmounted()`, 使我们可以在组件的各个生命周期阶段添加逻辑。
* [依赖注入](https://vuejs.org/api/composition-api-dependency-injection.html): 例如 `privide()` 和 `inject()`，使我们可以在使用响应性 API 时，利用 Vue 的依赖注入系统。

组合式 API 是 Vue 3 的内置功能，而要在 Vue 2 中使用，则需要使用 [`@vue/composition-api`](https://github.com/vuejs/composition-api)。

虽然，响应式 API 是基于函数的组合，但是，组合式 API 并不是函数式编程。
组合式 API 是以 Vue 中数据可变的、细粒度的响应性系统为基础的，而函数式编程更强调数据不可变。

## 为什么要有组合式 API？

* 更好的逻辑复用
* 更灵活的代码组织
* 更好的类型推导
* 更小的打包体积

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/extra/reactivity-transform.md'
---
# 响应性语法糖

响应性语法糖目前是一个实验性功能，默认是禁用的，需要显式选择使用。

Vue 的响应性语法糖是一个编译时的转换过程，使我们可以像这样书写代码：

## ref vs. 响应式变量

::: playground#vue 响应性语法糖

@file App.vue

```vue
<script setup>
let count = $ref(0)
console.log(count)
function increment() {
  count++
}
</script>

<template>
  <button @click="increment">
    {{ count }}
  </button>
</template>
```

@setting

```json
{
  "showCompileOutput": true
}
```

:::

这里的这个 `$ref()` 方法是一个编译时的宏命令：它不是一个真实的、在运行时会调用的方法。
而是用作 Vue 编译器的标记，表明最终的 `count` 变量需要是一个响应式变量。

每一个会返回 `ref` 的响应性 API 都有一个相对应的、以 `$` 为前缀的宏函数。包括以下这些 API：

* `ref` -> `$ref`
* `computed` -> `$computed`
* `shallowRef` -> `$shalloRef`
* `customRef` -> `$customRef`
* `toRef` -> `$toRef`

当启用响应性语法糖时，这些宏函数都是全局可用的、无需手动导入。
但如果你想让它更明显，你也可以选择从 `vue/macros` 中引入它们：

```js
import { $ref } from 'vue/macros'

const count = $ref(0)
```

## 通过 `$()` 结构

我们常常会让一个组合函数返回一个含数个 `ref` 的对象，然后解构得到这些 `ref`。对于这种场景，响应性语法糖提供了一个 `$()` 宏：

::: playground#vue 通过 `$()` 结构

@file App.vue

```vue
<script setup>
import { ref } from 'vue'

import { useMouse } from '@vueuse/core'

const { x, y } = $(useMouse())

console.log('useMouse', x, y)

function myCreateRef(num) {
  return ref(num)
}

const count = $(myCreateRef(0))
console.log('count', count)
</script>

<template>
  <div>请查看控制台。</div>
</template>
```

@import

```json
{
  "imports": {
    "@vueuse/core": "https://unpkg.com/@vueuse/core/dist/index.esm.js"
  }
}
```

@setting

```json
{
  "showCompileOutput": true
}
```

:::

## 响应式 props 解构

现在的 `<script setup>` 中对 `defineProps` 宏的使用有两个痛点：

1. 和 `.value` 类似，为了保持响应性，你需要以 `props.x` 的方式访问这些 prop。
   这意味着你不能通过结构 `defineProps`，因为得到的变量不是响应式的，不会更新。
2. 使用基于类型的 `props` 声明时，无法方便地声明这些 prop 的默认值。
   为此，有了 `withDefaults()` API，但使用起来不方便。

有了响应式语法糖，我们就可以在 `defineProps` 时，使用响应式变量相同的结构写法了：

::: playground#vue 响应式 props 解构

@file App.vue

```vue
<script setup lang="ts">
import { defineProps, watchEffect } from 'vue'

interface Props {
  msg: string
  count?: number
  foo?: string
}

// 此次的 Props 解构，会自动编译成 普通的 props 定义，指定默认值
const {
  msg,
  // 设置默认值
  count = 1,
  // 解构时命别名
  // 这里我们将 props.foo 命名未 bar
  foo: bar,
} = defineProps<Props>()

watchEffect(() => {
  console.log(msg, count, bar)
})
</script>

<template>
  <div>请查看编译后的 JS.</div>
</template>
```

@setting

```json
{
  "showCompileOutput": true
}
```

:::

## 保持在函数间的响应性

虽然响应式变量使我们可以不再受 `.value` 的困扰，但它也使得我们在函数间传递响应式变量时可能造成**响应性丢失**的问题。
这可能在以下两种场景中出现：

### 以参数形式传入函数

```js
function trackChange(x: Ref<number>) {
  watch(x, x => {
    console.log('x 改变了！')
  })
}

const count = $ref(0)
trackChange(count) // 无效！
```

上面的例子不会正常工作，因为代码被编译成了这样：

```js
const count = ref(0)
trackChange(count.value)
```

这里的 `count.value` 是以一个 `number` 类型值的形式传入，然而 trackChange 期望接收的是一个真正的 `ref`。
要解决这个问题，可以在将 count 作为参数传入之前，用 `$$()` 包装：

```diff
let count = $ref(0)
- trackChange(count)
+ trackChange($$(count))
```

上面的代码将被编译成：

```js
import { ref } from 'vue'

const count = ref(0)
trackChange(count)
```

我们可以看到，`$$()` 的效果就像是一个转义标识：`$$()` 中的响应式变量不会追加上 `.value`。

### 作为函数返回值

如果将响应式变量直接放在返回值表达式中会丢失掉响应性：

```js
function useMouse() {
  const x = $ref(0)
  const y = $ref(0)

  // 监听 mousemove 事件

  // 不起效！
  return {
    x,
    y,
  }
}
```

上面的语句将被翻译为：

```js
return {
  x: x.value,
  y: y.value,
}
```

为了保持响应性，我们需要返回的是真正的 `ref`，而不是返回时 `ref` 内的值。

我们还是可以使用 `$$()` 来解决这个问题。
在这个例子中，`$$()` 可以直接用在要返回的对象上，
`$$()` 调用时任何对响应式变量的引用都会保留为对相应 `ref` 的引用：

```js
function useMouse() {
  const x = $ref(0)
  const y = $ref(0)

  // 监听 mousemove 事件

  // 修改后起效
  return $$({
    x,
    y,
  })
}
```

### 在已解构的 prop 上使用 `$$()`

`$$()` 适用于已解构的 prop，因为它们也是响应式的变量。编译器会高效地通过 `toRef` 来做转换：

```js
const { count } = defineProps<{ count: number }>()

passAsRef($$(count))
```

编译结果为：

```js
setup(props) {
  const __props_count = toRef(props, 'count')
  passAsRef(__props_count)
}
```

## 显式启用

响应性语法糖目前默认是关闭状态，需要你显式选择[启用](https://vuejs.org/guide/extras/reactivity-transform.html#explicit-opt-in)。

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/extra/render-and-jsx.md'
---
# 渲染函数 & JSX

在绝大多数情况下，Vue 推荐使用模板语法来搭建 HTML。然而在某些使用场景下，我们真的需要用到 JavaScript 完全的编程能力。这时渲染函数就派上用场了。

## 基本用法

### 创建 VNodes

Vue 提供了一个 `h()` 函数用于创建 vnodes:

```js
import { h } from 'vue'

const vnode = h(
  'div', // type
  { id: 'foo', class: 'bar' }, // props
  [
    // children
  ]
)
```

`h()` 函数的使用非常灵活：

```js
// 除了类型必填以外，其他的参数都是可选的
h('div')
h('div', { id: 'foo' })

// attribute 和 property 都能在 props 中书写
// Vue 会自动将他们分配到正确的位置
h('div', { class: 'bar', innerHTML: 'hello' })

// props modifiers such as .prop and .attr can be added
// with '.' and `^' prefixes respectively
h('div', { '.name': 'some-name', '^width': '100' })

// 类与样式可以像在模板中一样
// 用数组或对象的形式书写
h('div', { class: [foo, { bar }], style: { color: 'red' } })

// 事件监听器应以 onXxx 的形式书写
h('div', { onClick: () => {} })

// children 可以是一个字符串
h('div', { id: 'foo' }, 'hello')

// 没有 props 时可以省略不写
h('div', 'hello')
h('div', [h('span', 'hello')])

// children 数组可以同时包含 vnodes 与字符串
h('div', ['hello', h('span', 'hello')])
```

### 声明渲染函数

当组合式 API 与模板一起使用时，`setup()` 钩子的返回值是用于暴露数据给模板。然而当我们使用渲染函数时，可以直接把渲染函数返回：

```js
import { h, ref } from 'vue'

export default {
  props: {
    // props
  },
  setup(props) {
    const count = ref(0)

    // 返回渲染函数
    return () => h('div', props.msg + count.value)
  },
}
```

除了返回一个 `vnode`，你还可以返回字符串或数组：

```js
import { h } from 'vue'

export default {
  setup() {
    // 使用数组返回多个根节点
    return () => [h('div'), h('div'), h('div')]
  },
}
```

::: tip
请确保返回的是一个**函数而**不是一个值！setup() 函数在每个组件中只会被调用一次，而返回的渲染函数将会被调用多次。
:::

### Vnodes 必须唯一

```js
function render() {
  const p = h('p', 'hi')
  return h('div', [
    // 啊哦，重复的 vnodes 是无效的
    p,
    p,
  ])
}
```

如果你真的非常想在页面上渲染多个重复的元素或者组件，你可以使用一个工厂函数来做这件事。
比如下面的这个渲染函数就可以完美渲染出 20 个相同的段落：

```js
function render() {
  return h(
    'div',
    Array.from({ length: 20 }).map(() => {
      return h('p', 'hi')
    })
  )
}
```

## JSX / TSX

[JSX](https://facebook.github.io/jsx/) 是 JavaScript 的一个类似 XML 的扩展，有了它，我们可以用以下的方式来书写代码：

```jsx
const vnode = <div>hello</div>
```

在 JSX 表达式中，使用大括号来嵌入动态值：

```js
const vnode = (
  <div id={dynamicId}>
    Hello,
    {username}
  </div>
)
```

### 渲染函数案例

#### `v-if`

模板:

```vue
<div>
  <div v-if="ok">yes
</div>

  <span v-else>
no
</span>
</div>
```

渲染函数 / JSX 语法：

```js
h('div', [ok.value ? h('div', 'yes') : h('span', 'no')])
```

```jsx
<div>{ok.value ? <div>yes</div> : <span>no</span>}</div>
```

#### `v-for`

模板：

```vue
<ul>
  <li v-for="{ id, text } in items" :key="id">{{ text }}</li>
</ul>
```

等价于使用如下渲染函数 / JSX 语法：

```js
h(
  'ul',
  items.value.map(({ id, text }) => {
    return h('li', { key: id }, text)
  })
)
```

```jsx
<ul>
  {items.value.map(({ id, text }) => {
    return <li id={id}>{text}</li>
  })}
</ul>
```

#### `v-on`

以 `on` 开头，并跟着大写字母的 `props` 会被当作事件监听器。比如，`onClick` 与模板中的 `@click` 等价。

```js
h(
  'button',
  {
    onClick(event) {
      // ...
    },
  },
  'click me'
)
```

```jsx
<button
  onClick={event => {
    // ...
  }}
>
  click me
</button>
```

#### 事件修饰符

对于 \`\`.passive`、`.capture`和`.once\` 事件修饰符，可以使用驼峰写法将他们拼接在事件名后面：

实例：

```js
h('input', {
  onClickCapture() {
    // 捕捉模式中的监听器
  },
  onKeyupOnce() {
    // 只触发一次
  },
  onMouseoverOnceCapture() {
    // 单次 + 捕捉
  },
})
```

```jsx
<input
  onClickCapture={() => {}}
  onKeyupOnce={() => {}}
  onMouseoverOnceCapture={() => {}}
/>
```

对于事件和按键修饰符，可以使用 `withModifiers` 函数：

```js
import { withModifiers } from 'vue'

h('div', {
  onClick: withModifiers(() -> {}, ['self'])
})
```

```jsx
<div onClick={withModifiers(() => {}, ['self'])}></div>
```

### 组件

在给组件创建 `vnode` 时，传递给 `h()` 函数的第一个参数应当是组件的定义。
这意味着使用渲染函数时不再需要注册组件了 —— 可以直接使用导入的组件：

```js
import Foo from './Foo.vue'
import Bar from './Bar.jsx'

function render() {
  return h('div', [h(Foo), h(Bar)])
}
```

```jsx
function render() {
  return (
    <div>
      <Foo />
      <Bar />
    </div>
  )
}
```

不管是什么类型的文件，只要从中导入的是有效的 Vue 组件，`h` 就能正常运作。

动态组件在渲染函数中也可直接使用：

```js
import Foo from './Foo.vue'
import Bar from './Bar.jsx'

function render() {
  return ok.value ? h(Foo) : h(Bar)
}
```

```jsx
function render() {
  return ok.value ? <Foo /> : <Bar />
}
```

如果一个组件是用名字注册的，不能直接导入 (例如，由一个库全局注册)，可以使用 `resolveComponent()` 来解决这个问题。

### 渲染插槽

在渲染函数中，插槽可以通过 `setup()` 的上下文来访问。每个 `slots` 对象中的插槽都是一个返回 `vnodes` 数组的函数：

```js
export default {
  props: ['message'],
  setup(props, { slots }) {
    return () => [
      // 默认插槽
      // <div><slot /></div>
      h('div', slots.default()),

      // 具名插槽
      // <div><slot name="footer" :text="message" /></div>
      h(
        'div',
        slots.footer({
          text: props.message,
        })
      ),
    ]
  },
}
```

等价 JSX 语法：

```jsx
// 默认插槽
<div>{slots.default()}</div>

// 具名插槽
<div>{slots.footer({ text: message })}</div>
```

### 传递插槽

我们需要传递一个插槽函数或者是一个包含插槽函数的对象而非是数组，
插槽函数的返回值同一个正常的渲染函数的返回值一样——并且在子组件中被访问时总是会被转化为一个 vnodes 数组。

```js
// 单个默认插槽

h(MyComponent, () => 'hello')

// 具名插槽
// 注意 null 是必须的
// 以避免 slot 对象被当成 props 处理
h(MyComponent, null, {
  default: () => 'default slot',
  foo: () => h('div', 'foo'),
  bar: () => [h('span', 'one'), h('span', 'two')],
})
```

等价 JSX 语法：

```jsx
// 默认插槽
<MyComponent>
  { () => 'hello' }
</MyComponent>

// 具名插槽
<MyComponent>
  {{
    default: () => 'default slot',
    foo: () => <div>foo</div>,
    bar: () => [
      <span>one</span>,
      <span>two</span>
    ]
  }}
</MyComponent>
```

插槽以函数的形式传递使得它们可以被子组件懒调用。这能确保它被注册为子组件的依赖关系，而不是父组件。这使得更新更加准确及有效。

### 内置组件

诸如 `KeepAlive`、`Transition`、`TransitionGroup`、`Teleport` 和 `Suspense` 等内置组件在渲染函数中必须导入才能使用：

```js
import { KeepAlive, Teleport, Transition, TransitionGroup, h } from 'vue'

export default {
  setup() {
    return () => h(Transition, { mode: 'out-in' } /* ... */)
  },
}
```

### `v-model`

`v-model` 指令扩展为 `modelValue` 和 `onUpdate:modelValue` 在模板编译过程中，我们必须自己提供这些 props:

```js
export default {
  props: ['modelValue'],
  emits: ['update:modelValue'],
  setup(props, { emit }) {
    return () =>
      h(SomeComponent, {
        modelValue: props.modelValue,
        'onUpdate:modelValue': value => emit('update:modelValue', value),
      })
  },
}
```

### 自定义指令

可以使用 `withDirectives` 将自定义指令应用于 VNode:

```js
import { h, withDirectives } from 'vue'

// 自定义指令
const pin = {
  mounted() {
    // ...
  },
  updated() {
    // ...
  },
}

// <div v-pin:top.animate="200"></div>
const vnode = withDirectives(h('div'), [[pin, 200, 'top', { animate: true }]])
```

当一个指令是以名称注册并且不能被直接导入时，可以使用 `resolveDirective` 函数来解决这个问题。

### 函数式组件

函数式组件是自身没有任何状态的组件的另一种形式。它们在渲染过程中不会创建组件实例，并跳过常规的组件生命周期。

我们使用的是一个简单函数，而不是一个选项对象，来创建函数式组件。该函数实际上就是该组件的 `render` 函数。

函数式组件的签名与 `setup()` 钩子相同：

```js
function MyComponent(props, { slots, emit, attrs }) {
  // ...
}
```

大多数常规组件的配置选项在函数式组件中都不可用。然而我们还是可以把 `props` 和 `emits` 作为 property 加入，以达到定义它们的目的：

```js
MyComponent.props = ['value']
MyComponent.emits = ['click']
```

如果这个 `props` 选项没有被定义，那么被传入函数的 `props` 对象就会像 `attrs` 一样会包含所有 attribute。
除非指定了 `props` 选项，否则每个 prop 的名字将不会基于驼峰命名法被一般化处理。

函数式组件可以像普通组件一样被注册和消费。如果你将一个函数作为第一个参数传入 `h`，它将会被当作一个函数式组件来对待。

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/reusability/index.md'
---
# 可重用性

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/reusability/composables.md'
---
# 组合式函数

## 什么是“组合式函数”？

在 Vue 应用的概念中，“组合式函数”是一个利用 Vue 组合式 API 来封装和复用**有状态逻辑**的函数。

当构建前端应用时，我们常常需要复用公共任务的逻辑，可以封装为**无状态的逻辑**。有状态逻辑负责管理会随时间而变化的状态。

## 鼠标跟踪器示例

如果我们想在多个组件中复用这个相同的逻辑，我们可以把这个逻辑以一个组合式函数的形式提取到外部文件中。

::: playground#vue 鼠标跟踪器示例
@file App.vue

```vue
<script setup>
import { useMouse } from './mouse.js'

const { x, y } = useMouse()
</script>

<template>Mouse position is at {{ x }}, {{ y }}</template>
```

@file mouse.js

```js
import { onMounted, onUnmounted, ref } from 'vue'

// 按照惯例，组合式函数名以 use 开头
export function useMouse() {
  // 被组合式封装和管理的状态
  const x = ref(0)
  const y = ref(0)

  // 组合式函数可以随时改变其管理的状态
  const update = event => {
    x.value = event.pageX
    y.value = event.pageY
  }

  // a composable can also hook into its owner component's
  // lifecycle to setup and teardown side effects.
  onMounted(() => {
    window.addEventListener('mousemove', update)
  })
  onUnmounted(() => {
    window.removeEventListener('mousemove', update)
  })

  // expose managed state as return value
  return { x, y }
}
```

:::

如你所见，核心逻辑一点都没有被改变，我们做的只是把它移到一个外部函数中去，并返回需要暴露的状态。
然而更酷的一点是，你还可以嵌套多个组合式函数：一个组合式函数可以调用一个或多个其他的组合式函数。
这使得我们可以像使用多个组件组合成整个应用一样，用多个较小且逻辑独立的单元来组合形成复杂的逻辑。
实际上，这正是我们决定将实现了这一设计模式的 API 集合命名为组合式 API 的原因。

举个例子，我们可以将添加和清除 DOM 事件监听器的逻辑放入一个组合式函数中：

::: playground#vue 鼠标跟踪器示例 嵌套调用
@file App.vue

```vue
<script setup>
import { useMouse } from './mouse.js'

const { x, y } = useMouse()
</script>

<template>Mouse position is at {{ x }}, {{ y }}</template>
```

@file mouse.js

```js
import { onMounted, onUnmounted, ref } from 'vue'
import { useEventListener } from './event.js'

// 按照惯例，组合式函数名以 use 开头
export function useMouse() {
  // 被组合式封装和管理的状态
  const x = ref(0)
  const y = ref(0)

  useEventListener(window, 'mousemove', event => {
    x.value = event.pageX
    y.value = event.pageY
  })

  // expose managed state as return value
  return { x, y }
}
```

@file event.js

```js
import { onMounted, onUnmounted } from 'vue'

export function useEventListener(target, event, callback) {
  onMounted(() => target.addEventListener(event, callback))
  onUnmounted(() => target.removeEventListener(event, callback))
}
```

:::

## 异步状态示例

`useMouse()` 组合式函数没有接收任何参数，因此让我们再来看一个需要接收一个参数的组合式函数示例。
在做异步数据请求时，我们常常需要处理不同的状态：加载中、加载成功和加载失败。

::: playground#vue 异步状态示例
@file App.vue

```vue
<script setup>
import { computed, ref } from 'vue'
import { useFetch } from './useFetch.js'

const baseUrl = 'https://jsonplaceholder.typicode.com/todos/'
const id = ref('1')
const url = computed(() => baseUrl + id.value)

const { data, error, retry } = useFetch(url)
</script>

<template>
  Load todo id:
  <button v-for="i in 5" @click="id = i">
    {{ i }}
  </button>

  <div v-if="error">
    <p>Oops! Error encountered: {{ error.message }}</p>
    <button @click="retry">Retry</button>
  </div>
  <div v-else-if="data">
    Data Loaded:
    <pre>{{ data }}</pre>
  </div>
  <div v-else>Loading...</div>
</template>
```

@file useFetch.js

```js
import { isRef, ref, unref, watchEffect } from 'vue'

export function useFetch(url) {
  const data = ref(null)
  const error = ref(null)

  function doFetch() {
    // reset state before fetching..
    data.value = null
    error.value = null

    // unref() unwraps potential refs
    fetch(unref(url))
      .then(res => res.json())
      .then(json => (data.value = json))
      .error(err => (error.value = err))
  }

  if (isRef(url)) {
    // setup reactive re-fetch if input URL is a ref
    // 若输入的 URL 是一个 ref，那么启动一个响应式的请求
    watchEffect(doFetch)
  } else {
    // otherwise, just fetch once
    // and avoid the overhead of a watcher
    // 避免监听器的额外开销
    doFetch()
  }

  return { data, error, retry: doFetch }
}
```

:::

这个版本的 useFetch() 现在同时可以接收静态的 URL 字符串和 URL 字符串的 ref。
当通过 isRef() 检测到 URL 是一个动态 ref 时，它会使用 watchEffect() 启动一个响应式的 effect。
该 effect 会立刻执行一次，并在此过程中将 URL 的 ref 作为依赖进行跟踪。
当 URL 的 ref 发生改变时，数据就会被重置，并重新请求。

## 约定和最佳实践

### 命名

组合式函数约定用驼峰命名法命名，并以 `use` 作为开头。

### 输入参数

尽管其响应性不依赖 ref，组合式函数仍可接收 ref 参数。如果编写的组合式函数会被其他开发者使用，你最好在处理输入参数时兼容 ref 而不只是原始的值。unref() 工具函数会对此非常有帮助：

```js
import { unref } fron 'vue'

function useFeature(maybeRef) {
  // 若 maybeRef 确实是一个 Ref，则返回它的 value
  // 否则，maybeRef 原样返回
  const value = unref(maybeRef)
}
```

如果你的组合式函数在接收 ref 为参数时会产生响应式 effect，请确保使用 `watch()` 显示地监听次 ref, 或者在 `watchEffect()` 中调用 `unref()` 来正确地追踪。

### 返回值

你可能已经注意到了，我们一直在组合式函数中使用 ref() 而不是 reactive()。我们推荐的约定是组合式函数始终返回 `ref` 对象，这样该函数在组件中解构之后仍可以保持响应性：

```js
// x 和 y 是两个 ref 对象
const { x, y } = useMouse()
```

从组合式函数返回一个响应式对象会导致在对象解构过程中丢失与组合式函数内状态的响应性连接。与之相反，ref 则可以维持这一响应性连接。

如果你更希望以对象 `property` 的形式从组合式函数中返回状态，你可以将要返回的对象用 `reactive()` 包装，这样其中的 ref 会被自动解包，例如：

```js
const mouse = reactive(useMouse())
// mouse.x 链接到了原来的 x ref
console.log(mouse.x)
```

```vue
Mouse position is at: {{ mouse.x }}, {{ mouse.y }}
```

### 副作用

在组合式函数中的确可以执行副作用 (例如：添加 DOM 事件监听器或者请求数据)，但请注意以下规则：

* 如果你在一个应用中使用了服务器端渲染 (SSR)，请确保在后置加载的声明钩子上执行 DOM 相关的副作用，例如：onMounted()。
  这些钩子仅会在浏览器中使用，因此可以确保能访问到 DOM。
* **确保在 onUnmounted() 时清理副作用。**
  举个例子，如果一个组合式函数设置了一个事件监听器，它就应该在 onUnmounted() 中被移除 (就像我们在 useMouse() 示例中看到的一样)。
  当然也可以像之前的 useEventListener() 示例那样，使用一个组合式函数来自动帮你做这些事。

### 使用限制

组合式函数在 `<script setup>` 或 `setup()` 钩子中，应始终被同步地调用。在某些场景下，你也可以在像 `onMounted()` 这样的生命周期钩子中使用他们。

这些是 Vue 得以确定当前活跃的组件实例的条件。有能力对活跃的组件实例进行访问是必要的，以便：

1. 可以在组合式函数中注册生命周期钩子
2. 计算属性和监听器可以连接到当前组件实例，以便在组件卸载时处理掉。

::: tip
`<script setup>` 是唯一在调用 `await` 之后仍可调用组合式函数的地方。编译器会在异步操作之后自动为你恢复当前活跃的组件实例。
:::

### 为更好的代码组织抽取组合式函数

抽取组合式函数不仅是为了复用，也是为了代码组织。随着组件复杂度的增高，你可能会最终发现组件多得难以查询和理解。
组合式 API 会给予你足够的灵活性，让你可以基于逻辑问题将组件代码拆分成更小的函数：

```vue
<script setup>
import { useFeatureA } from './featureA.js'
import { useFeatureB } from './featureB.js'
import { useFeatureC } from './featureC.js'

const { foo, bar } = useFeatureA()
const { baz } = useFeatureB(foo)
const { quz } = useFeatureC(baz)
</script>
```

### 在选项式 API 中使用组合式函数

如果你正在使用选项式 API，组合式函数必须在 `setup()` 中调用。且其返回的绑定必须在 `setup()` 中**返回**，以便暴露给 this 及其模板：

```js
import { useMouse } from './mouse.js'
import { useFetch } from './fetch.js'

export default {
  setup() {
    const { x, y } = useMouse()
    const { data, error } = useFetch('xx')

    return { x, y, data, error }
  },
  mounted() {
    // setup 中暴露的 property，可以通过 this 访问
    console.log(this.x)
  },
}
```

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/reusability/custom-directives.md'
---
# 自定义指令

## 介绍

除了 Vue 内置的一系列指令 (比如 v-model 或 v-show) 之外，Vue 还允许你注册自定义的指令。

我们已经介绍了两种在 Vue 中重用代码的方式：**组件**和**组合式函数**。组件是主要的构建模块，而组合式函数则侧重于有状态的逻辑。另一方面，自定义指令主要是为了重用涉及普通元素的底层 DOM 访问的逻辑。

一个自定义指令被定义为一个包含类似于组件的生命周期钩子的对象。钩子接收指令绑定到的元素。下面是一个自定义指令的例子，当一个 input 元素被 Vue 插入到 DOM 中后，它将被聚焦：

::: playground#vue v-focus 指令
@file App.vue

```vue
<script>
const focus = {
  mounted: el => el.focus(),
}

export default {
  directives: {
    // 注册指令，在模板中启用 v-focus
    focus,
  },
}
</script>

<template>
  <input v-focus />
</template>
```

:::

::: playground#vue 组合式 API v-focus 指令
@file App.vue

```vue
<script setup>
// enables v-focus in templates
const vFocus = {
  mounted: el => el.focus(),
}
</script>

<template>
  <input v-focus />
</template>
```

:::

和组件类似，自定义指令在模板中使用前必须先注册。在上面的例子中，我们使用 directives 选项完成了指令的局部注册。

将一个自定义指令全局注册到应用层级也是一种通用的做法：

```js
const app = createApp({})

// 全局注册，使 v-focus 在所有组件中都可用
app.directive('focus', {
  // ...
})
```

::: tip
只有当所需功能只能通过直接的 DOM 操作来实现时，才应该使用自定义指令。应该尽可能地通过像 `v-bind` 这样的内置指令以使用声明式的模板，因为这更高效，且对服务端渲染也更友好。
:::

## 指令钩子

一个指令的定义对象可以提供几种钩子函数 (都是可选的)：

```js
const myDirective = {
  // called before bound element's attributes
  // or event listeners are applied
  created(el, binding, vnode, preVnode) {
    // see below for details on arguments
  },
  // called right before the element is inserted into the DOM.
  beforeCreated() {},
  // called when the bound element's parent component
  // and all its children are mounted.
  mounted() {},
  // called before the parent component is updated
  beforeUpdate() {},
  // called before the parent component is updated
  // all of its children have updated
  updated() {},
  // called before the parent component is unmounted
  beforeUnmounted() {},
  // called when the parent component is unmounted
  unmounted() {},
}
```

### 钩子参数

指令的钩子会传递以下几种参数：

* `el`: 指令绑定到的元素。这可以用于直接操作 DOM。
* `binding`: 一个对象，包含以下 property。
  * `value`: 传递给指令的值。例如在 `v-my-directive="1 + 1"` 中，值是 2。
  * `oldValue`: 之前的值，仅在 `beforeUpdate` 和 `updated` 中可用。无论值是否更改，它都可用。
  * `arg`: 传递给指令的参数（如果有的话）。例如在 `v-my-directive:foo` 中，参数是 `"foo"`。
  * `modifiers`：一个包含修饰符的对象 (如果有的话)。例如在 `v-my-directive.foo.bar` 中，修饰符对象是 `{ foo: true, bar: true }`。
  * `instance`：使用该指令的组件实例
  * `dir`：指令的定义对象。
* `vnode`: 代表绑定元素的底层 VNode。
* `preVnode`: 之前的渲染中代表指令所绑定元素的 VNode。仅在 `beforeUpdate` 和 `updated` 钩子中可用。

举个例子，像下面这样使用指令：

```vue
<div v-example.foo.bar="baz" />
```

`binding` 参数会是一个这样的对象：

```js
{
  arg: 'foo',
  modifiers: { bar: true },
  value: // baz 的值
  oldValue: // 上一次更新时 baz 的值
}
```

和内置指令类似，自定义指令的参数也可以是动态的：

```vue
<div v-example:[arg]="value" />
```

里指令的参数会基于组件状态 `arg` 属性响应式地更新。

::: note
除了 `el` 外，你应该将这些参数都视为只读的，并一律不更改它们。若你需要在不同的钩子间共享信息，推荐通过元素的 [dataset](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset) 实现
:::

### 简化形式

对于自定义指令来说，需要在 `mounted` 和 `updated` 上实现相同的行为、又并不关心其他钩子的情况很常见。此时我们可以将指令定义成一个下面这样的函数：

```vue
<div v-color="color"></div>
```

```js
app.directive('color', (el, binding) => {
  // this will be called for both `mounted` and `updated`
  el.style.color = binding.value
})
```

### 对象字面量

如果你的指令需要多个值，你可以向它传递一个 JavaScript 对象字面量。请记住，指令也可以接收任何合法的 JavaScript 表达式。

```vue
<div v-demo="{ color: 'white', text: 'hello' }"></div>
```

```js
app.directive('demo', (el, binding) => {
  console.log(binding.value.color) // "white"
  console.log(binding.value.text) // "hello"
})
```

### 在组件上使用

当在组件上使用自定义指令时，它会始终应用于组件的根节点，和[透传 attributes](https://staging-cn.vuejs.org/guide/components/attrs.html) 类似。

```vue
<MyComponent v-demo="test" />
```

```vue
<!-- MyComponent 模板 -->
<div>
 <!-- v-demo 指令会被应用在此处 -->
  <span>My Component content</span>
</div>
```

需要注意的是组件可能含有多个根节点。当应用到一个多根组件时，指令将会被忽略且抛出一个警告。和 attribute 不同，指令不能通过 `v-bind="$attrs"` 来传递给一个不同的元素。总而言之，**不推荐**在组件上使用自定义指令。

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/reusability/plugins.md'
---
# 插件

## 介绍

插件是一种能为 Vue 添加全局功能的工具代码。我们会这样安装一个插件：

```js
import { createApp } from 'vue'

const app = createApp({})

app.use('myPlugin', {
  // 可选的选项
})
```

它可以是一个拥有 `install()` 方法的对象，或者就简单地只是一个函数，它自己就是安装函数。安装函数接收应用实例和传递给 `app.use()` 的额外选项：

```js
const myPlugin = {
  install(app, options) {
    // 配置此应用
  },
}
```

插件没有严格定义的使用范围，但是插件发挥作用的常见场景主要包括以下几种：

1. 通过 `app.component()` 和 `app.directive()` 注册一到多个全局组件或自定义指令。
2. 通过 `app.provide()` 使一个资源可被注入进整个应用
3. 向 `app.config.globalProperties` 中添加一些全局实例属性或方法
4. 一个可能上述 3 种都包含的功能库（例如 vue-router）

### 编写一个插件

为了更好地理解如何构建 Vue.js 插件，我们可以试着写一个简单的 i18n (国际化 (Internationalization) 的缩写) 插件。

我们想让整个应用程序有一个按 key 名翻译文本内容的函数，因此我们将它暴露在 `app.config.globalProperties` 上。这个函数接收一个以 . 作为分隔符的 key 字符串，用来在用户提供的翻译字典中查找对应语言的文本。

```js
// plugins/i18n.js
export default {
  install: (app, options) => {
    // 注入一个全局可用的 $translate() 方法
    app.config.globalProperties.$translate = key => {
      // 获取 `options` 对象的深层属性
      // 使用 `key` 作为索引
      return key.split('.').reduce((o, i) => {
        if (o) {
          return o[i]
        }
      }, options)
    }
  },
}
```

该插件希望用户在使用该插件时通过选项传入一个翻译字典对象，所以应该这样使用：

```js
import i18nPlugin from './plugins/i18n.js'

app.use(i18nPlugin, {
  greetings: {
    hello: 'Bonjour!',
  },
})
```

```vue
<h1>
{{ $translate('greetings.hello') }}
</h1>
```

### 插件中的 provide / inject

在插件中，我们可以通过 provide 来为插件用户供给一些内容。举个例子，我们可以将 options 参数提供给整个应用，以便各个组件都能使用这个翻译字典对象。

```js {13}
// plugins/i18n.js
export default {
  install: (app, options) => {
    // 注入一个全局可用的 $translate() 方法
    app.config.globalProperties.$translate = key => {
      // 获取 `options` 对象的深层属性
      // 使用 `key` 作为索引
      return key.split('.').reduce((o, i) => {
        if (o) {
          return o[i]
        }
      }, options)
    }

    app.provide('i18n', options)
  },
}
```

现在，插件用户就可以在他们的组件中以 i18n 为 key 注入并访问插件的选项对象了。

```js
<script setup>
  import {inject} from 'vue' const i18n = inject('i18n')
  console.log(i18n.greetings.hello)
</script>
```

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/typescript/index.md'
---
# TypeScript

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/typescript/composition-api.md'
---
# TypeScript 与组合式 API

## 为组件的 props 标注类型

## 使用 `<script setup>`

当使用 `<script setup>` 时，`defineProps()` 宏函数支持从它的参数中推导类型：

```vue
<script setup lang="ts">
const props = defineProps({
  foo: {
    type: String,
    required: true,
  },
  bar: Number,
})

props.foo // string
props.bar // number | undefined
</script>
```

这被称之为“运行时声明”，因为传递给 `defineProps()` 的参数会作为运行时的 `props` 选项使用。

然而，通过泛型参数来定义 `props` 的类型通常更直接：

```vue
<script setup lang="ts">
const props = defineProps<{
  foo: string
  bar?: number
}>()
</script>
```

这被称之为“基于类型的声明”。编译器会尽可能地尝试根据类型参数推导出等价的运行时选项。在这种场景下，我们第二个例子中编译出的运行时选项和第一个是完全一致的。

基于类型的声明或者运行时声明可以择一使用，但是不能同时使用。

我们也可以将 props 的类型移入一个单独的接口中：

```vue
<script setup lang="ts">
interface Props {
  foo: string
  bar?: number
}

const props = defineProps<Props>()
</script>
```

这同样适用于 Props 从另一个源文件中导入的情况。该功能要求 TypeScript 作为 Vue 的一个 peer dependency。

```vue
<script setup lang="ts">
import type { Props } from './Props'

const props = defineProps<Props>()
</script>
```

## Props 解构默认值

当使用基于类型的声明时，我们失去了为 `props` 声明默认值的能力。这可以通过 `withDefaults` 编译器宏解决：

```ts
export interface Props {
  msg?: string
  labels?: string[]
}

const props = withDefaults(defineProps<Props>(), {
  msg: 'hello',
  labels: () => ['one', 'two'],
})
```

这将被编译为等效的运行时 props default 选项。此外，`withDefaults` 帮助程序为默认值提供类型检查，并确保返回的 props 类型删除了已声明默认值的属性的可选标志。

::: tip
请注意，可变引用类型 (如数组或对象) 的默认值应封装在函数中，以避免被意外修改或产生外部副作用。这样可以确保每个组件实例都能获得属于自己的默认值副本。
:::

### 非 `<script setup>` 场景下

如果没有使用 `<script setup>`，那么为了开启 props 的类型推导，必须使用 `defineComponent()`。传入 `setup()` 的 props 对象类型是从 props 选项中推导而来。

```ts
import { defineComponent } from 'vue'

export default defineComponent({
  props: {
    message: String,
  },
  setup(props) {
    props.message // <-- 类型：string
  },
})
```

### 复杂的 prop 类型

通过基于类型的声明，一个 prop 可以像使用其他任何类型一样使用一个复杂类型：

```vue
<script setup lang="ts">
interface Book {
  title: string
  author: string
  year: number
}

const props = defineProps<{
  book: Book
}>()
</script>
```

对于运行时声明，我们可以使用 `PropType` 工具类型：

```ts
import type { PropType } from 'vue'

const props = defineProps({
  book: Object as PropType<Book>,
})
```

其工作方式与直接指定 props 选项基本相同：

```ts
import { defineComponent } from 'vue'
import type { PropType } from 'vue'

export default defineComponent({
  props: {
    book: Object as PropType<Book>,
  },
})
```

## 为组件的 emits 标注类型

在 `<script setup>` 中，`emit` 函数的类型标注也可以通过运行时声明或是类型声明进行：

```vue
<script setup lang="ts">
// 运行时
const emit = defineEmits(['change', 'update'])
</script>
```

```vue
<script setup lang="ts">
// 基于选项
const emit = defineEmits({
  change: (id: number) => {
    // 返回 `true` 或 `false`
    // 表明验证通过或失败
    return true
  },
  update: (value: string) => {
    // 返回 `true` 或 `false`
    // 表明验证通过或失败
    return true
  },
})
</script>
```

````vue
<script setup lang="ts">
// 基于类型
const emit = defineEmits<{
  (e: 'change', id: number): void
  (e: 'update', value: string): void
}>()
</script>

```vue
<script setup lang="ts">
// 3.3+: 可选的、更简洁的语法
const emit = defineEmits<{
  change: [id: number]
  update: [value: string]
}>()
</script>
````

类型参数可以是以下的一种：

1. 一个可调用的函数类型，但是写作一个包含调用签名的类型字面量。它将被用作返回的 emit 函数的类型。
2. 一个类型字面量，其中键是事件名称，值是数组或元组类型，表示事件的附加接受参数。上面的示例使用了具名元组，因此每个参数都可以有一个显式的名称。

若没有使用 `<script setup>`，`defineComponent()` 也可以根据 `emits` 选项推导暴露在 setup 上下文中的 emit 函数的类型：

```ts
import { defineComponent } from 'vue'

export default defineComponent({
  emits: ['change'],
  setup(props, { emit }) {
    emit('change') // <-- 类型检查 / 自动补全
  },
})
```

## 为 provide / inject 标注类型

`provide` 和 `inject` 通常会在不同的组件中运行。要正确地为注入的值标记类型，Vue 提供了一个 `InjectionKey` 接口，它是一个继承自 `Symbol` 的泛型类型，可以用来在提供者和消费者之间同步注入值的类型：

```ts
import { inject, provide } from 'vue'
import type { InjectionKey } from 'vue'

const key = Symbol() as InjectionKey<string>

provide(key, 'foo') // 若提供的是非字符串值会导致错误

const foo = inject(key) // foo 的类型：string | undefined
```

::: tip
建议将注入 key 的类型放在一个单独的文件中，这样它就可以被多个组件导入。
:::

当使用字符串注入 key 时，注入值的类型是 unknown，需要通过泛型参数显式声明：

```ts
const foo = inject<string>('foo') // 类型：string | undefined
```

注意注入的值仍然可以是 `undefined`，因为无法保证提供者一定会在运行时 `provide` 这个值。

当提供了一个默认值后，这个 `undefined` 类型就可以被移除：

```ts
const foo = inject<string>('foo', 'bar') // 类型：string
```

如果你确定该值将始终被提供，则还可以强制转换该值：

```ts
const foo = inject('foo') as string // 类型：string
```

## 为模板引用标注类型

模板引用需要通过一个显式指定的泛型参数和一个初始值 null 来创建：

```vue {4}
<script setup lang="ts">
import { onMounted, ref } from 'vue'

const el = ref<HTMLInputElement | null>(null)

onMounted(() => {
  el.value?.focus()
})
</script>

<template>
  <input ref="el" />
</template>
```

::: warning
为了严格的类型安全，有必要在访问 `el.value` 时使用可选链或类型守卫。这是因为直到组件被挂载前，这个 `ref` 的值都是初始的 `null`，并且在由于 `v-if` 的行为将引用的元素卸载时也可以被设置为 `null`。
:::

## 为组件模板引用标注类型

有时，你可能需要为一个子组件添加一个模板引用，以便调用它公开的方法。举例来说，我们有一个 `MyModal` 子组件，它有一个打开模态框的方法：

```vue
<!-- MyModal.vue -->
<script setup lang="ts">
import { ref } from 'vue'

const isContentShown = ref(false)
const open = () => (isContentShown.value = true)

defineExpose({
  open,
})
</script>
```

为了获取 `MyModal` 的类型，我们首先需要通过 `typeof` 得到其类型，再使用 TypeScript 内置的 `InstanceType` 工具类型来获取其实例类型：

```vue
<!-- App.vue -->
<script setup lang="ts">
import { ref } from 'vue'
import MyModal from './MyModal.vue'

const modal = ref<InstanceType<typeof MyModal> | null>(null)

function openModal() {
  modal.value.open()
}
</script>
```

如果组件的具体类型无法获得，或者你并不关心组件的具体类型，那么可以使用 `ComponentPublicInstance`。这只会包含所有组件都共享的属性，比如 `$el`。

```vue
<!-- App.vue -->
<script setup lang="ts">
import { ref } from 'vue'
import type { ComponentPublicInstance } from 'vue'

const child = ref<ComponentPublicInstance | null>(null)
</script>
```

---

---
url: 'https://zhaobc.site/notes/frontend/vue/vue3/typescript/overview.md'
---
# 搭配 TypeScript 使用 Vue

Vue 本身就是用 TypeScript 编写的，所有的 Vue 官方库都自带了类型声明文件，开箱即用。

## 配置 tsconfig.json

通过 create-vue 搭建的项目包含了预先配置好的 tsconfig.json。其底层配置抽象于 @vue/tsconfig 包中。

手动配置 tsconfig.json 时，请留意以下选项：

* `compilerOptions.isolatedModules` 应当设置为 `true`，因为 Vite 使用 esbuild 来转译 TypeScript，并受限于单文件转译的限制。

* 如果你正在使用选项式 API，需要将 `compilerOptions.strict` 设置为 `true` (或者至少开启 `compilerOptions.noImplicitThis`，它是 `strict` 模式的一部分)，才可以获得对组件选项中 `this` 的类型检查。否则 `this` 会被认为是 `any`。

* 如果你在构建工具中配置了路径解析别名，例如 `@/\*` 这个别名被默认配置在了 `create-vue` 项目中，你需要通过 `compilerOptions.paths` 选项为 TypeScript 再配置一遍。

如果你打算在 Vue 中使用 TSX，请将 `compilerOptions.jsx` 设置为 `"preserve"`，并将 `compilerOptions.jsxImportSource` 设置为 `"vue"`。

## 常见使用说明

### `defineComponent()`

为了让 TypeScript 正确地推导出组件选项内的类型，我们需要通过 `defineComponent()` 这个全局 API 来定义组件：

```ts
import { defineComponent } from 'vue'

export default defineComponent({
  props: {
    name: String,
    msg: {
      type: String,
      required: true,
    },
  },
  data() {
    return {
      count: 1,
    }
  },
  mounted() {
    this.name // string | undefined
    this.msg // string
    this.count // number
  },
})
```

当没有结合 `<script setup>` 使用组合式 API 时，`defineComponent()` 也支持对传递给 `setup()` 的 `prop` 的推导：

```ts
import { defineComponent } from 'vue'

export default defineComponent({
  props: {
    message: String,
  },
  setup(props) {
    props.message // string | undefined
  },
})
```

::: tip
`defineComponent()` 也支持对纯 JavaScript 编写的组件进行类型推导。
:::

## 在单文件组件中的用法

要在单文件组件中使用 TypeScript，需要在 `<script>` 标签上加上 `lang="ts"` 的属性。

```vue
<script lang="ts">
import { defineComponent } from 'vue'
export default defineComponent({
  data() {
    return {
      count: 1,
    }
  },
})
</script>

<template>
  <!-- 启用了类型检查和自动补全 -->
  {{ count.toFixed(2) }}
</template>
```

`lang="ts"` 也可以用于 `<script setup>`：

```vue
<script setup lang="ts">
import { ref } from 'vue'

const count = ref(1)
</script>

<template>
  <!-- 启用了类型检查和自动补全 -->
  {{ count.toFixed(2) }}
</template>
```

### 模板中的 TypeScript

在使用了 `<script lang="ts">` 或 `<script setup lang="ts">` 后，`<template>` 在绑定表达式中也支持 TypeScript。这对需要在模板表达式中执行类型转换的情况下非常有用。

```vue
<script setup lang="ts">
let x: string | number
</script>

<template>
  <!-- 出错，因为 x 可能是字符串 -->
  {{ x.toFixed(2) }}
</template>
```

可以使用内联类型强制转换解决此问题：

```vue {6}
<script setup lang="ts">
let x: string | number
</script>

<template>
  {{ (x as number).toFixed(2) }}
</template>
```

---

---
url: 'https://zhaobc.site/notes/other/index.md'
---
# 其他内容

---

---
url: 'https://zhaobc.site/notes/other/demo/index.md'
---
# 测试示例

## ECharts 示例

::: echarts echarts demo

```json
{
  "xAxis": {
    "type": "category",
    "data": ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
  },
  "yAxis": {
    "type": "value"
  },
  "series": [
    {
      "data": [150, 230, 224, 218, 135, 147, 260],
      "type": "line",
      "smooth": true
    }
  ]
}
```

:::

## Playground 示例

::: playground#vue Playground demo

@file App.vue

```vue
<script setup>
import { ref } from 'vue'
import Comp from './Comp.vue'

const msg = ref('Hello World!')
</script>

<template>
  <h1>{{ msg }}</h1>
  <input v-model="msg" />
  <div>
    <Comp />
  </div>
</template>
```

@file Comp.vue

```vue
<template>
  <div>Comp</div>
</template>
```

@import

```json
{
  "imports": {
    "lodash-es": "https://cdn.jsdelivr.net/npm/lodash-es@4.17.21/lodash.min.js"
  }
}
```

:::

::: vue-playground Vue Playground demo

@file App.vue

```vue
<script setup>
import { ref } from 'vue'
import Comp from './Comp.vue'

const msg = ref('Hello World!')
</script>

<template>
  <h1>{{ msg }}</h1>
  <input v-model="msg" />
  <div>
    <Comp />
  </div>
</template>
```

@file Comp.vue

```vue
<template>
  <div>Comp</div>
</template>
```

@import

```json
{
  "imports": {
    "lodash-es": "https://cdn.jsdelivr.net/npm/lodash-es@4.17.21/lodash.min.js"
  }
}
```

@setting

```json
{
  "service": "https://play.zhaobc.site"
}
```

:::

## Element-Plus 示例

::: playground#vue Element-Plus demo

@file App.vue

```vue
<script lang="ts" setup>
import {
  Check,
  Delete,
  Edit,
  Message,
  Search,
  Star,
} from '@element-plus/icons-vue'
</script>

<template>
  <el-row class="mb-4">
    <el-button>Default</el-button>
    <el-button type="primary"> Primary </el-button>
    <el-button type="success"> Success </el-button>
    <el-button type="info"> Info </el-button>
    <el-button type="warning"> Warning </el-button>
    <el-button type="danger"> Danger </el-button>
    <el-button>中文</el-button>
  </el-row>
  <el-row>
    <el-button :icon="Search" circle />
    <el-button type="primary" :icon="Edit" circle />
    <el-button type="success" :icon="Check" circle />
    <el-button type="info" :icon="Message" circle />
    <el-button type="warning" :icon="Star" circle />
    <el-button type="danger" :icon="Delete" circle />
  </el-row>
</template>
```

@import import\_map.json

```json
{
  "imports": {
    "a": "b"
  }
}
```

@setting

```json
{
  "service": "https://element-plus.run/"
}
```

:::

## Replit Demo

```md
<Replit user="FuckDoctors" repl="Java-Test" file="Main.java" />
```

## Flippy Card

---

---
url: 'https://zhaobc.site/notes/other/dev/regex.md'
---
# 正则表达式

## 查找不含指定字符串的行

```txt
^(?!指定字符串).*$
```

可视化

@startregex
title 查找不含指定字符串的行
^(?!指定字符串).\*$
@endregex

::: warning
直接书写 plantuml 会被替换成一个图片，直接在 `[vp-content]` 下面。
主题默认使用 `plugin-photo-swipe` 来浏览图片，它默认的选择器不能选择 `[vp-content]` 直接儿子元素，所以，需要在 plantuml 外面包一层 `div` 才可以。
另外，`<div>` 与 plantuml 内容直接需要空一行，不然 plantuml 不能正确渲染。
:::

需求：查找 MyBatis 的 sqlmap 中未指定 `jdbcType` 的参数。

```txt
// 查找以 # 或 $ 开头，且不含 jdbcType 或包含no 或 offset 或 limit 的行
^.*[#\$]\{(?!.*jdbcType)(?!*.no)(?!offset)(?!limit).*$
```

---

---
url: 'https://zhaobc.site/notes/other/linux/index.md'
---
# Linux 相关内容

记录一些 linux 相关的东西。

---

---
url: 'https://zhaobc.site/notes/other/linux/certs.md'
---
# SSL 证书

生成 Apache 所需的 SSL 证书。

```shell
# 生成CA认证机构的证书密钥key
# 需要设置密码，输入两次
openssl genrsa -des3 -out ca.key 2048

# 比如 123456

# 去除密钥里的密码(可选)
# 这里需要再输入一次原来设的密码
openssl rsa -in ca.key -out ca.key

# 用私钥ca.key生成CA认证机构的证书ca.crt
# 其实就是相当于用私钥生成公钥，再把公钥包装成证书
openssl  req -new -x509 -key ca.key -out ca.crt -days 3650
# 这个证书ca.crt有的又称为"根证书",因为可以用来认证其他证书

# 生成自己网站的密钥server.key
openssl genrsa -des3 -out server.key 2048

openssl rsa -in server.key -out server.key

# 比如 123456

# 生成自己网站证书的请求文件
# 如果找外面的CA机构认证，也是发个请求文件给他们
# 这个私钥就包含在请求文件中了，认证机构要用它来生成网站的公钥，然后包装成一个证书
openssl req -new -key server.key -out server.csr

# 使用虚拟的CA认证机构的证书ca.crt，来对自己网站的证书请求文件server.csr进行处理，生成签名后的证书server.crt
# 注意设置序列号和有效期（一般都设1年，这里设了10年）
openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt -days 3650
```

---

---
url: 'https://zhaobc.site/notes/other/linux/gitlab-pages.md'
---
# Gitlab Pages 配置

## Gitlab 配置

`/etc/gitlab/gitlab.rb` :

```ruby
##! Define to enable GitLab Pages
#pages_external_url 'http://192.168.201.16'
pages_external_url 'http://dev.bhh'
gitlab_pages['enable'] = true
```

重新配置 gitlab :

```shell
gitlab-ctl reconfigure
```

## Gitlab Pages 域名访问

`gitlab-pages.conf` 如下：

```conf
server {
  listen *:80;
  server_name  ~^(?<group>.*)\.dev\.bhh$;
  server_tokens off; ## Don't show the nginx version number, a security best practice

  ## Disable symlink traversal
  disable_symlinks on;


  ## Real IP Module Config
  ## http://nginx.org/en/docs/http/ngx_http_realip_module.html

  ## Individual nginx logs for this GitLab vhost
  access_log  /var/log/gitlab/nginx/gitlab_pages_access.log gitlab_access;
  error_log   /var/log/gitlab/nginx/gitlab_pages_error.log;

  # Pass everything to pages daemon
  location / {
    proxy_set_header Host $http_host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto http;

    # Prevent NGINX from caching pages in response to the pages `Cache-Control`
    # header.
    #
    # Browsers already respect this directive and Pages can handle the request
    # volume without help from NGINX.
    #
    # If this changes in the future, ensure `proxy_cache_key` is set to a value
    # like `$scheme$host$request_uri`, as the default value does not take the
    # Pages hostname into account, leading to incorrect responses being served.
    #
    # See https://gitlab.com/gitlab-org/gitlab-pages/issues/73
    proxy_cache off;

    proxy_pass          http://localhost:8090;
  }

  # Define custom error pages
  error_page 403 /403.html;
  error_page 404 /404.html;


}
```

## Gitlab Pages IP 访问

Gitlab Pages 的 nginx 配置文件在 `/var/opt/gitlab/nginx/conf` 下面。

添加一个新的配置文件，名为 `gitlab-pages-ip.conf`，内容如下：

```conf
server {
  listen 8088;
  server_name  192.168.201.16;
  server_tokens off; ## Don't show the nginx version number, a security best practice

  ## Disable symlink traversal
  disable_symlinks on;


  ## Real IP Module Config
  ## http://nginx.org/en/docs/http/ngx_http_realip_module.html

  ## Individual nginx logs for this GitLab vhost
  access_log  /var/log/gitlab/nginx/gitlab_pages_ip_access.log gitlab_access;
  error_log   /var/log/gitlab/nginx/gitlab_pages_ip_error.log;

  # Pass everything to pages daemon
  location / {
    root /var/opt/gitlab/gitlab-rails/shared/pages;
    index index.html;

    proxy_set_header Host $http_host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto http;

    # Prevent NGINX from caching pages in response to the pages `Cache-Control`
    # header.
    #
    # Browsers already respect this directive and Pages can handle the request
    # volume without help from NGINX.
    #
    # If this changes in the future, ensure `proxy_cache_key` is set to a value
    # like `$scheme$host$request_uri`, as the default value does not take the
    # Pages hostname into account, leading to incorrect responses being served.
    #
    # See https://gitlab.com/gitlab-org/gitlab-pages/issues/73
    #proxy_cache off;

    #proxy_pass          http://localhost:8090;
  }

#  location ~* ^/(.+)/(.+)/ {
#    root /var/opt/gitlab/gitlab-rails/shared/pages/$1/$2/public;
#    index index.html;
#
#    proxy_cache off;
#  }

#  location ^~ /bbx/wiki/ {
#    root /var/opt/gitlab/gitlab-rails/shared/pages/bbx/wiki/public;
#    index index.html;
#
#    proxy_cache off;
#  }

  location ^~ /wiki {
    #root /var/opt/gitlab/gitlab-rails/shared/pages/bbx/wiki/public;
    alias /var/opt/gitlab/gitlab-rails/shared/pages/bbx/wiki/public;
    index index.html;

    #proxy_cache off;
  }

  # Define custom error pages
  error_page 403 /403.html;
  error_page 404 /404.html;


}
```

::: warning
为了便捷访问 Gitlab Pages，不想多加 `public` 路径，所以自己重写了 `location`。
并且为了能同时使用域名，并且保持域名访问和 IP 访问的 `base` 一致，重写了 `location`。
nginx 中的 `root` 和 `alias` 不同，使用 `root` 时，会再拼上 `location`，会导致加载有问题，所以改用 `alias`。
:::

IP 访问地址：`http://192.168.201.16:8088/bbx/wiki/public/`，需要带 `public` 路径。

## Gitlab Pages Nginx 重启

```shell
gitlab-ctl restart nginx
```

## 开放端口

```shell
firewall-cmd --zone=public --add-port=8088/tcp --permanent
systemctl restart firewalld
```

---

---
url: 'https://zhaobc.site/notes/other/linux/misc.md'
---
# 杂项

## 更改语言

```shell
# centos
# change locale
sed "s/LANG=\"en_US.UTF-8\"/LANG=\"ja_JP.UTF-8\"/" -i /etc/locale.conf
localedef -i ja_JP -f UTF-8 ja_JP.UTF-8

# setup env
cat << EOF >> /etc/profile
export LANG=ja_JP.UTF-8
export LC_ALL=ja_JP.UTF-8
export LANGUAGE=ja_JP.UTF-8
EOF
```

## 更改主机名

```shell
hostnamectl set-hostname Xxx
```

注意：主机名带 `.` 的话，会忽略 `.` 之后的内容。
比如 `201.23` 会变为 `201`。

## 开发防火墙端口

### 查看端口

```shell
firewall-cmd --list-ports
```

### 添加端口

```shell
firewall-cmd --zone=public --add-port=80/tcp --permanent
```

### 重启防火墙

```shell
firewall-cmd --reload
```

---

---
url: 'https://zhaobc.site/notes/other/tools/git.md'
---
# git 小提示

设置用户：

```shell
git config user.email "413853119@qq.com"
git config user.name "ZhaoBin"
```

修改最后一次 commit 的用户信息:

```shell
git commit --amend --author="ZhaoBin <413853119@qq.com>" --no-edit
```

最近几次提交变基：

```shell
# 最近3次提交变基
git rebase -i HEAD~3
```

遍历文件获取第一次提交的信息：

```shell
echo "file,filename,hash,date,author,email,comment" > commit.txt

git ls-files -r --name-only "$branch" | while read file; do
  # 截取最后一个 "/" 后面的文件名
  filename="${file##*/}"
  # 输出第一次提交信息
  log=$(git log --reverse --pretty=format:"%h,%ad,%an,%ae,%s" --date=format:%Y/%m/%d -- "$file" | head -n 1)
  echo "$file,$filename,$log" >> commit.txt
done
```

---

---
url: 'https://zhaobc.site/posts/docker/deploy-waline.md'
---
# Waline 部署

[Waline](https://waline.js.org/) 是一款简洁、安全的评论系统。

## 独立部署

本次使用 Docker 独立部署，以便方便内网使用。

## 部署脚本

```yml
# docker-compose.yml
version: '3'

services:
  waline:
    container_name: waline
    image: lizheming/waline:latest
    restart: always
    links:
      - postgresql
    depends_on:
      - postgresql
    ports:
      - 8360:8360
    volumes:
      - /srv/waline/data:/app/data
    environment:
      TZ: 'Asia/Shanghai'
      SITE_NAME: 'Site Name'
      SITE_URL: 'http://www.zhaobc.site'
      #SECURE_DOMAINS: 'example.com'
      AUTHOR_EMAIL: 'zhbchwin@163.com'
      PG_DB: waline
      PG_USER: waline
      PG_PASSWORD: xxxxxx
      PG_HOST: postgresql
      PG_PORT: 5432
      PG_PREFIX: 'wl_'
      PG_SSL: false

  postgresql:
    container_name: postgres
    image: postgres:latest
    restart: always
    ports:
      - 5460:5432
    volumes:
      - /srv/waline/db/pgdata:/var/lib/postgresql/data
      - /srv/waline/db/initdb:/docker-entrypoint-initdb.d
    environment:
      POSTGRES_USER: waline
      POSTGRES_PASSWORD: xxxxxx
      POSTGRES_DB: waline
```

---

---
url: 'https://zhaobc.site/slides/demo.md'
---
# 幻灯片页
@slidestart

## 幻灯片演示

一个简单的幻灯片演示与各种小贴士。

> 作者 Mr.Hope. 请滚动鼠标滚轮进入下一页

***

## 标注幻灯片

[👇](#/1/1)

\--

## 标注幻灯片

使用 `---` 标注水平幻灯片

在水平幻灯片中使用 `--` 分割垂直幻灯片

使用 `<!-- .slide: ... -->` 在幻灯片上添加属性

使用 `<!-- .element: ... -->` 在前一个 HTML 元素上添加属性

***

## Markdown

你可以在幻灯片中使用 Markdown 语法的各种标记.

\--

## Markdown

你可以在幻灯片中使用 Markdown 语法的各种标记.

### 这是一个 H3

标题默认会自动转换为大写。

这是一个有着 **粗体**, *斜体*, ~~删除线~~ 文字并包含 [一个链接](https://mrhope.site) 的段落，并且它会自动换行。所以你无需担心它的长度。

\--

## Markdown

你可以在幻灯片中使用 Markdown 语法的各种标记.

列表默认为 `inline-block`

* 项目
* 项目
* 项目

1. 项目 1
2. 项目 2
3. 项目 3

\--

## Markdown

你可以在幻灯片中使用 Markdown 语法的各种标记.

在你启用 `highlight` 插件后，代码块会自动高亮。

```js
const a = 1
```

\--

## Markdown

你可以在幻灯片中使用 Markdown 语法的各种标记.

在你启用 `math` 插件后，你也可以使用 TEX 格式使用数学公式。

$$
J(\theta\_0,\theta\_1) = \sum\_{i=0}
$$

\--

## Markdown

你可以在幻灯片中使用 Markdown 语法的各种标记.

⚠**请注意**: 表格和分割线，以及所有不在 Markdown 标准语法中的内容均不受支持。

***

## 布局

\--

## 布局

👆 `r-fit-text` class 会让文字在不超出幻灯片范围的情况下尽可能大。

\--

## 布局

![Logo](/logo.svg)

👆 `r-stretch` class 帮助你控制注入图片或视频的大小，使它们填充满幻灯片垂直方向上的剩余空间。

\--

## 布局

### 背景

你可以通过向特定幻灯片添加 `data-background` 属性自定义幻灯片背景.

***

## 动画片段

\--

## 动画片段

动画片段用于高亮或显隐幻灯片中的元素。

你需要在元素上添加 `fragment` 和动画 class。

\--

## 动画片段

### 动画 class

* `fade-in`

- `fade-out`

* `fade-up`

- `fade-down`

* `fade-left`

- `fade-right`

* `fade-in-then-out`

- `fade-in-then-semi-out`

\--

## 动画片段

### 动画 class

* `grow`

- `shrink`

* `strike`

- `highlight-red`

* `highlight-green`

- `highlight-blue`

* `highlight-current-red`

- `highlight-current-green`

* `highlight-current-blue`

\--

## 动画片段

### 多个动画片段

你可以按照顺序包裹一个 HTML 元素使其拥有多个动画片段

\--

## 动画片段

### 顺序

你可以使用 `data-fragment-index` 属性改变元素的动画顺序。

不同元素可以有相同的动画顺序。

* 最后显示

- 第二个显示

* 第一个显示

- 第二个显示

***

## 渐变

\--

## 渐变

Transition 可以通过配置中的 `transition` 选项全局设置，也可以通过在特定幻灯片添加 `data-transition` 属性局部设置.

可能的值:

* none
* fade
* slide

- convex
- concave
- zoom

\--

## 渐变

### 过渡动画

你可以在相邻的幻灯片上添加 `data-auto-animate` 使相同的 HTML 元素产生过渡动画效果。

***

## 功能

\--

## 功能

### 代码

通过启用 `highlight` 插件，你可以对代码块进行高亮。

你可以使用 `[a-b|c-d]` 语法来分布高亮特定行。

```js [1-2|3|4]
let a = 1
let b = 2
let c = x => 1 + 2 + x
c(3)
```

\--

## 功能

### 预览模式

按下 `Esc` 或 `O` 即可在幻灯片获得焦点时进入预览模式。

\--

## 功能

### 全屏模式

按下 `F` 或 `F11` 即可在幻灯片获得焦点时进入全屏模式。

\--

## 功能

### 缩放

按下 `alt` (Linux 上使用 `ctrl`) 的同时点击幻灯片的任何元素，即可以向此元素进行放大。

再次点击即可缩小。

***

## 结束

@slideend
